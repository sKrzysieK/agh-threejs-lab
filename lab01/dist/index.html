<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lab 01</title>
    <style>
      body {
        margin: 0;
      }
    </style>
    <!-- <script type="module" crossorigin src="./assets/index-DNlukeIO.js"></script> -->
    <script type="module" crossorigin>
      var Rl = Object.defineProperty;
      var wa = (i) => {
        throw TypeError(i);
      };
      var Cl = (i, t, e) =>
        t in i
          ? Rl(i, t, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: e,
            })
          : (i[t] = e);
      var Ra = (i, t, e) => Cl(i, typeof t != "symbol" ? t + "" : t, e),
        Ca = (i, t, e) => t.has(i) || wa("Cannot " + e);
      var Mt = (i, t, e) => (
          Ca(i, t, "read from private field"), e ? e.call(i) : t.get(i)
        ),
        Ue = (i, t, e) =>
          t.has(i)
            ? wa("Cannot add the same private member more than once")
            : t instanceof WeakSet
            ? t.add(i)
            : t.set(i, e),
        we = (i, t, e, n) => (
          Ca(i, t, "write to private field"), n ? n.call(i, e) : t.set(i, e), e
        );
      (function () {
        const t = document.createElement("link").relList;
        if (t && t.supports && t.supports("modulepreload")) return;
        for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
          n(r);
        new MutationObserver((r) => {
          for (const s of r)
            if (s.type === "childList")
              for (const a of s.addedNodes)
                a.tagName === "LINK" && a.rel === "modulepreload" && n(a);
        }).observe(document, { childList: !0, subtree: !0 });
        function e(r) {
          const s = {};
          return (
            r.integrity && (s.integrity = r.integrity),
            r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
            r.crossOrigin === "use-credentials"
              ? (s.credentials = "include")
              : r.crossOrigin === "anonymous"
              ? (s.credentials = "omit")
              : (s.credentials = "same-origin"),
            s
          );
        }
        function n(r) {
          if (r.ep) return;
          r.ep = !0;
          const s = e(r);
          fetch(r.href, s);
        }
      })();
      /**
       * @license
       * Copyright 2010-2024 Three.js Authors
       * SPDX-License-Identifier: MIT
       */ const sa = "169",
        li = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
        ai = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
        Pl = 0,
        Pa = 1,
        Ll = 2,
        zo = 1,
        Ho = 2,
        nn = 3,
        Tn = 0,
        ye = 1,
        sn = 2,
        En = 0,
        ci = 1,
        La = 2,
        Da = 3,
        Ua = 4,
        Dl = 5,
        Fn = 100,
        Ul = 101,
        Il = 102,
        Nl = 103,
        Fl = 104,
        Ol = 200,
        Bl = 201,
        zl = 202,
        Hl = 203,
        vs = 204,
        xs = 205,
        Gl = 206,
        Vl = 207,
        kl = 208,
        Wl = 209,
        Xl = 210,
        Yl = 211,
        ql = 212,
        Kl = 213,
        jl = 214,
        Ms = 0,
        Ss = 1,
        Es = 2,
        pi = 3,
        ys = 4,
        Ts = 5,
        As = 6,
        bs = 7,
        Go = 0,
        Zl = 1,
        $l = 2,
        yn = 0,
        Jl = 1,
        Ql = 2,
        tc = 3,
        ec = 4,
        nc = 5,
        ic = 6,
        rc = 7,
        Vo = 300,
        mi = 301,
        _i = 302,
        ws = 303,
        Rs = 304,
        Pr = 306,
        Cs = 1e3,
        Bn = 1001,
        Ps = 1002,
        Ne = 1003,
        sc = 1004,
        Xi = 1005,
        ke = 1006,
        zr = 1007,
        zn = 1008,
        ln = 1009,
        ko = 1010,
        Wo = 1011,
        Oi = 1012,
        aa = 1013,
        Hn = 1014,
        an = 1015,
        Gi = 1016,
        oa = 1017,
        la = 1018,
        gi = 1020,
        Xo = 35902,
        Yo = 1021,
        qo = 1022,
        Xe = 1023,
        Ko = 1024,
        jo = 1025,
        hi = 1026,
        vi = 1027,
        Zo = 1028,
        ca = 1029,
        $o = 1030,
        ha = 1031,
        ua = 1033,
        _r = 33776,
        gr = 33777,
        vr = 33778,
        xr = 33779,
        Ls = 35840,
        Ds = 35841,
        Us = 35842,
        Is = 35843,
        Ns = 36196,
        Fs = 37492,
        Os = 37496,
        Bs = 37808,
        zs = 37809,
        Hs = 37810,
        Gs = 37811,
        Vs = 37812,
        ks = 37813,
        Ws = 37814,
        Xs = 37815,
        Ys = 37816,
        qs = 37817,
        Ks = 37818,
        js = 37819,
        Zs = 37820,
        $s = 37821,
        Mr = 36492,
        Js = 36494,
        Qs = 36495,
        Jo = 36283,
        ta = 36284,
        ea = 36285,
        na = 36286,
        ac = 3200,
        oc = 3201,
        Qo = 0,
        lc = 1,
        vn = "",
        pe = "srgb",
        bn = "srgb-linear",
        da = "display-p3",
        Lr = "display-p3-linear",
        yr = "linear",
        te = "srgb",
        Tr = "rec709",
        Ar = "p3",
        Xn = 7680,
        Ia = 519,
        cc = 512,
        hc = 513,
        uc = 514,
        tl = 515,
        dc = 516,
        fc = 517,
        pc = 518,
        mc = 519,
        Na = 35044,
        Fa = "300 es",
        on = 2e3,
        br = 2001;
      class kn {
        addEventListener(t, e) {
          this._listeners === void 0 && (this._listeners = {});
          const n = this._listeners;
          n[t] === void 0 && (n[t] = []),
            n[t].indexOf(e) === -1 && n[t].push(e);
        }
        hasEventListener(t, e) {
          if (this._listeners === void 0) return !1;
          const n = this._listeners;
          return n[t] !== void 0 && n[t].indexOf(e) !== -1;
        }
        removeEventListener(t, e) {
          if (this._listeners === void 0) return;
          const r = this._listeners[t];
          if (r !== void 0) {
            const s = r.indexOf(e);
            s !== -1 && r.splice(s, 1);
          }
        }
        dispatchEvent(t) {
          if (this._listeners === void 0) return;
          const n = this._listeners[t.type];
          if (n !== void 0) {
            t.target = this;
            const r = n.slice(0);
            for (let s = 0, a = r.length; s < a; s++) r[s].call(this, t);
            t.target = null;
          }
        }
      }
      const de = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff",
      ];
      let Oa = 1234567;
      const Ii = Math.PI / 180,
        Bi = 180 / Math.PI;
      function Mi() {
        const i = (Math.random() * 4294967295) | 0,
          t = (Math.random() * 4294967295) | 0,
          e = (Math.random() * 4294967295) | 0,
          n = (Math.random() * 4294967295) | 0;
        return (
          de[i & 255] +
          de[(i >> 8) & 255] +
          de[(i >> 16) & 255] +
          de[(i >> 24) & 255] +
          "-" +
          de[t & 255] +
          de[(t >> 8) & 255] +
          "-" +
          de[((t >> 16) & 15) | 64] +
          de[(t >> 24) & 255] +
          "-" +
          de[(e & 63) | 128] +
          de[(e >> 8) & 255] +
          "-" +
          de[(e >> 16) & 255] +
          de[(e >> 24) & 255] +
          de[n & 255] +
          de[(n >> 8) & 255] +
          de[(n >> 16) & 255] +
          de[(n >> 24) & 255]
        ).toLowerCase();
      }
      function me(i, t, e) {
        return Math.max(t, Math.min(e, i));
      }
      function fa(i, t) {
        return ((i % t) + t) % t;
      }
      function _c(i, t, e, n, r) {
        return n + ((i - t) * (r - n)) / (e - t);
      }
      function gc(i, t, e) {
        return i !== t ? (e - i) / (t - i) : 0;
      }
      function Ni(i, t, e) {
        return (1 - e) * i + e * t;
      }
      function vc(i, t, e, n) {
        return Ni(i, t, 1 - Math.exp(-e * n));
      }
      function xc(i, t = 1) {
        return t - Math.abs(fa(i, t * 2) - t);
      }
      function Mc(i, t, e) {
        return i <= t
          ? 0
          : i >= e
          ? 1
          : ((i = (i - t) / (e - t)), i * i * (3 - 2 * i));
      }
      function Sc(i, t, e) {
        return i <= t
          ? 0
          : i >= e
          ? 1
          : ((i = (i - t) / (e - t)), i * i * i * (i * (i * 6 - 15) + 10));
      }
      function Ec(i, t) {
        return i + Math.floor(Math.random() * (t - i + 1));
      }
      function yc(i, t) {
        return i + Math.random() * (t - i);
      }
      function Tc(i) {
        return i * (0.5 - Math.random());
      }
      function Ac(i) {
        i !== void 0 && (Oa = i);
        let t = (Oa += 1831565813);
        return (
          (t = Math.imul(t ^ (t >>> 15), t | 1)),
          (t ^= t + Math.imul(t ^ (t >>> 7), t | 61)),
          ((t ^ (t >>> 14)) >>> 0) / 4294967296
        );
      }
      function bc(i) {
        return i * Ii;
      }
      function wc(i) {
        return i * Bi;
      }
      function Rc(i) {
        return (i & (i - 1)) === 0 && i !== 0;
      }
      function Cc(i) {
        return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
      }
      function Pc(i) {
        return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
      }
      function Lc(i, t, e, n, r) {
        const s = Math.cos,
          a = Math.sin,
          o = s(e / 2),
          l = a(e / 2),
          c = s((t + n) / 2),
          h = a((t + n) / 2),
          f = s((t - n) / 2),
          p = a((t - n) / 2),
          m = s((n - t) / 2),
          v = a((n - t) / 2);
        switch (r) {
          case "XYX":
            i.set(o * h, l * f, l * p, o * c);
            break;
          case "YZY":
            i.set(l * p, o * h, l * f, o * c);
            break;
          case "ZXZ":
            i.set(l * f, l * p, o * h, o * c);
            break;
          case "XZX":
            i.set(o * h, l * v, l * m, o * c);
            break;
          case "YXY":
            i.set(l * m, o * h, l * v, o * c);
            break;
          case "ZYZ":
            i.set(l * v, l * m, o * h, o * c);
            break;
          default:
            console.warn(
              "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                r
            );
        }
      }
      function si(i, t) {
        switch (t.constructor) {
          case Float32Array:
            return i;
          case Uint32Array:
            return i / 4294967295;
          case Uint16Array:
            return i / 65535;
          case Uint8Array:
            return i / 255;
          case Int32Array:
            return Math.max(i / 2147483647, -1);
          case Int16Array:
            return Math.max(i / 32767, -1);
          case Int8Array:
            return Math.max(i / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function _e(i, t) {
        switch (t.constructor) {
          case Float32Array:
            return i;
          case Uint32Array:
            return Math.round(i * 4294967295);
          case Uint16Array:
            return Math.round(i * 65535);
          case Uint8Array:
            return Math.round(i * 255);
          case Int32Array:
            return Math.round(i * 2147483647);
          case Int16Array:
            return Math.round(i * 32767);
          case Int8Array:
            return Math.round(i * 127);
          default:
            throw new Error("Invalid component type.");
        }
      }
      const Dc = {
        DEG2RAD: Ii,
        RAD2DEG: Bi,
        generateUUID: Mi,
        clamp: me,
        euclideanModulo: fa,
        mapLinear: _c,
        inverseLerp: gc,
        lerp: Ni,
        damp: vc,
        pingpong: xc,
        smoothstep: Mc,
        smootherstep: Sc,
        randInt: Ec,
        randFloat: yc,
        randFloatSpread: Tc,
        seededRandom: Ac,
        degToRad: bc,
        radToDeg: wc,
        isPowerOfTwo: Rc,
        ceilPowerOfTwo: Cc,
        floorPowerOfTwo: Pc,
        setQuaternionFromProperEuler: Lc,
        normalize: _e,
        denormalize: si,
      };
      class Pt {
        constructor(t = 0, e = 0) {
          (Pt.prototype.isVector2 = !0), (this.x = t), (this.y = e);
        }
        get width() {
          return this.x;
        }
        set width(t) {
          this.x = t;
        }
        get height() {
          return this.y;
        }
        set height(t) {
          this.y = t;
        }
        set(t, e) {
          return (this.x = t), (this.y = e), this;
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), this;
        }
        add(t) {
          return (this.x += t.x), (this.y += t.y), this;
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), this;
        }
        addVectors(t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
        }
        addScaledVector(t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), this;
        }
        sub(t) {
          return (this.x -= t.x), (this.y -= t.y), this;
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), this;
        }
        subVectors(t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
        }
        multiply(t) {
          return (this.x *= t.x), (this.y *= t.y), this;
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), this;
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        applyMatrix3(t) {
          const e = this.x,
            n = this.y,
            r = t.elements;
          return (
            (this.x = r[0] * e + r[3] * n + r[6]),
            (this.y = r[1] * e + r[4] * n + r[7]),
            this
          );
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            this
          );
        }
        clampLength(t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y;
        }
        cross(t) {
          return this.x * t.y - this.y * t.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(t) {
          const e = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (e === 0) return Math.PI / 2;
          const n = this.dot(t) / e;
          return Math.acos(me(n, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            n = this.y - t.y;
          return e * e + n * n;
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
          );
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            this
          );
        }
        equals(t) {
          return t.x === this.x && t.y === this.y;
        }
        fromArray(t, e = 0) {
          return (this.x = t[e]), (this.y = t[e + 1]), this;
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), t;
        }
        fromBufferAttribute(t, e) {
          return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
        }
        rotateAround(t, e) {
          const n = Math.cos(e),
            r = Math.sin(e),
            s = this.x - t.x,
            a = this.y - t.y;
          return (
            (this.x = s * n - a * r + t.x), (this.y = s * r + a * n + t.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class Dt {
        constructor(t, e, n, r, s, a, o, l, c) {
          (Dt.prototype.isMatrix3 = !0),
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            t !== void 0 && this.set(t, e, n, r, s, a, o, l, c);
        }
        set(t, e, n, r, s, a, o, l, c) {
          const h = this.elements;
          return (
            (h[0] = t),
            (h[1] = r),
            (h[2] = o),
            (h[3] = e),
            (h[4] = s),
            (h[5] = l),
            (h[6] = n),
            (h[7] = a),
            (h[8] = c),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(t) {
          const e = this.elements,
            n = t.elements;
          return (
            (e[0] = n[0]),
            (e[1] = n[1]),
            (e[2] = n[2]),
            (e[3] = n[3]),
            (e[4] = n[4]),
            (e[5] = n[5]),
            (e[6] = n[6]),
            (e[7] = n[7]),
            (e[8] = n[8]),
            this
          );
        }
        extractBasis(t, e, n) {
          return (
            t.setFromMatrix3Column(this, 0),
            e.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(t) {
          const e = t.elements;
          return (
            this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
          );
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const n = t.elements,
            r = e.elements,
            s = this.elements,
            a = n[0],
            o = n[3],
            l = n[6],
            c = n[1],
            h = n[4],
            f = n[7],
            p = n[2],
            m = n[5],
            v = n[8],
            M = r[0],
            u = r[3],
            d = r[6],
            T = r[1],
            E = r[4],
            A = r[7],
            O = r[2],
            P = r[5],
            b = r[8];
          return (
            (s[0] = a * M + o * T + l * O),
            (s[3] = a * u + o * E + l * P),
            (s[6] = a * d + o * A + l * b),
            (s[1] = c * M + h * T + f * O),
            (s[4] = c * u + h * E + f * P),
            (s[7] = c * d + h * A + f * b),
            (s[2] = p * M + m * T + v * O),
            (s[5] = p * u + m * E + v * P),
            (s[8] = p * d + m * A + v * b),
            this
          );
        }
        multiplyScalar(t) {
          const e = this.elements;
          return (
            (e[0] *= t),
            (e[3] *= t),
            (e[6] *= t),
            (e[1] *= t),
            (e[4] *= t),
            (e[7] *= t),
            (e[2] *= t),
            (e[5] *= t),
            (e[8] *= t),
            this
          );
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            r = t[2],
            s = t[3],
            a = t[4],
            o = t[5],
            l = t[6],
            c = t[7],
            h = t[8];
          return (
            e * a * h -
            e * o * c -
            n * s * h +
            n * o * l +
            r * s * c -
            r * a * l
          );
        }
        invert() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            r = t[2],
            s = t[3],
            a = t[4],
            o = t[5],
            l = t[6],
            c = t[7],
            h = t[8],
            f = h * a - o * c,
            p = o * l - h * s,
            m = c * s - a * l,
            v = e * f + n * p + r * m;
          if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const M = 1 / v;
          return (
            (t[0] = f * M),
            (t[1] = (r * c - h * n) * M),
            (t[2] = (o * n - r * a) * M),
            (t[3] = p * M),
            (t[4] = (h * e - r * l) * M),
            (t[5] = (r * s - o * e) * M),
            (t[6] = m * M),
            (t[7] = (n * l - c * e) * M),
            (t[8] = (a * e - n * s) * M),
            this
          );
        }
        transpose() {
          let t;
          const e = this.elements;
          return (
            (t = e[1]),
            (e[1] = e[3]),
            (e[3] = t),
            (t = e[2]),
            (e[2] = e[6]),
            (e[6] = t),
            (t = e[5]),
            (e[5] = e[7]),
            (e[7] = t),
            this
          );
        }
        getNormalMatrix(t) {
          return this.setFromMatrix4(t).invert().transpose();
        }
        transposeIntoArray(t) {
          const e = this.elements;
          return (
            (t[0] = e[0]),
            (t[1] = e[3]),
            (t[2] = e[6]),
            (t[3] = e[1]),
            (t[4] = e[4]),
            (t[5] = e[7]),
            (t[6] = e[2]),
            (t[7] = e[5]),
            (t[8] = e[8]),
            this
          );
        }
        setUvTransform(t, e, n, r, s, a, o) {
          const l = Math.cos(s),
            c = Math.sin(s);
          return (
            this.set(
              n * l,
              n * c,
              -n * (l * a + c * o) + a + t,
              -r * c,
              r * l,
              -r * (-c * a + l * o) + o + e,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(t, e) {
          return this.premultiply(Hr.makeScale(t, e)), this;
        }
        rotate(t) {
          return this.premultiply(Hr.makeRotation(-t)), this;
        }
        translate(t, e) {
          return this.premultiply(Hr.makeTranslation(t, e)), this;
        }
        makeTranslation(t, e) {
          return (
            t.isVector2
              ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
              : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
            this
          );
        }
        makeRotation(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
        }
        makeScale(t, e) {
          return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
        }
        equals(t) {
          const e = this.elements,
            n = t.elements;
          for (let r = 0; r < 9; r++) if (e[r] !== n[r]) return !1;
          return !0;
        }
        fromArray(t, e = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const n = this.elements;
          return (
            (t[e] = n[0]),
            (t[e + 1] = n[1]),
            (t[e + 2] = n[2]),
            (t[e + 3] = n[3]),
            (t[e + 4] = n[4]),
            (t[e + 5] = n[5]),
            (t[e + 6] = n[6]),
            (t[e + 7] = n[7]),
            (t[e + 8] = n[8]),
            t
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      const Hr = new Dt();
      function el(i) {
        for (let t = i.length - 1; t >= 0; --t) if (i[t] >= 65535) return !0;
        return !1;
      }
      function zi(i) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", i);
      }
      function Uc() {
        const i = zi("canvas");
        return (i.style.display = "block"), i;
      }
      const Ba = {};
      function Sr(i) {
        i in Ba || ((Ba[i] = !0), console.warn(i));
      }
      function Ic(i, t, e) {
        return new Promise(function (n, r) {
          function s() {
            switch (i.clientWaitSync(t, i.SYNC_FLUSH_COMMANDS_BIT, 0)) {
              case i.WAIT_FAILED:
                r();
                break;
              case i.TIMEOUT_EXPIRED:
                setTimeout(s, e);
                break;
              default:
                n();
            }
          }
          setTimeout(s, e);
        });
      }
      function Nc(i) {
        const t = i.elements;
        (t[2] = 0.5 * t[2] + 0.5 * t[3]),
          (t[6] = 0.5 * t[6] + 0.5 * t[7]),
          (t[10] = 0.5 * t[10] + 0.5 * t[11]),
          (t[14] = 0.5 * t[14] + 0.5 * t[15]);
      }
      function Fc(i) {
        const t = i.elements;
        t[11] === -1
          ? ((t[10] = -t[10] - 1), (t[14] = -t[14]))
          : ((t[10] = -t[10]), (t[14] = -t[14] + 1));
      }
      const za = new Dt().set(
          0.8224621,
          0.177538,
          0,
          0.0331941,
          0.9668058,
          0,
          0.0170827,
          0.0723974,
          0.9105199
        ),
        Ha = new Dt().set(
          1.2249401,
          -0.2249404,
          0,
          -0.0420569,
          1.0420571,
          0,
          -0.0196376,
          -0.0786361,
          1.0982735
        ),
        Ti = {
          [bn]: {
            transfer: yr,
            primaries: Tr,
            luminanceCoefficients: [0.2126, 0.7152, 0.0722],
            toReference: (i) => i,
            fromReference: (i) => i,
          },
          [pe]: {
            transfer: te,
            primaries: Tr,
            luminanceCoefficients: [0.2126, 0.7152, 0.0722],
            toReference: (i) => i.convertSRGBToLinear(),
            fromReference: (i) => i.convertLinearToSRGB(),
          },
          [Lr]: {
            transfer: yr,
            primaries: Ar,
            luminanceCoefficients: [0.2289, 0.6917, 0.0793],
            toReference: (i) => i.applyMatrix3(Ha),
            fromReference: (i) => i.applyMatrix3(za),
          },
          [da]: {
            transfer: te,
            primaries: Ar,
            luminanceCoefficients: [0.2289, 0.6917, 0.0793],
            toReference: (i) => i.convertSRGBToLinear().applyMatrix3(Ha),
            fromReference: (i) => i.applyMatrix3(za).convertLinearToSRGB(),
          },
        },
        Oc = new Set([bn, Lr]),
        Xt = {
          enabled: !0,
          _workingColorSpace: bn,
          get workingColorSpace() {
            return this._workingColorSpace;
          },
          set workingColorSpace(i) {
            if (!Oc.has(i))
              throw new Error(`Unsupported working color space, "${i}".`);
            this._workingColorSpace = i;
          },
          convert: function (i, t, e) {
            if (this.enabled === !1 || t === e || !t || !e) return i;
            const n = Ti[t].toReference,
              r = Ti[e].fromReference;
            return r(n(i));
          },
          fromWorkingColorSpace: function (i, t) {
            return this.convert(i, this._workingColorSpace, t);
          },
          toWorkingColorSpace: function (i, t) {
            return this.convert(i, t, this._workingColorSpace);
          },
          getPrimaries: function (i) {
            return Ti[i].primaries;
          },
          getTransfer: function (i) {
            return i === vn ? yr : Ti[i].transfer;
          },
          getLuminanceCoefficients: function (i, t = this._workingColorSpace) {
            return i.fromArray(Ti[t].luminanceCoefficients);
          },
        };
      function ui(i) {
        return i < 0.04045
          ? i * 0.0773993808
          : Math.pow(i * 0.9478672986 + 0.0521327014, 2.4);
      }
      function Gr(i) {
        return i < 0.0031308 ? i * 12.92 : 1.055 * Math.pow(i, 0.41666) - 0.055;
      }
      let Yn;
      class Bc {
        static getDataURL(t) {
          if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u")
            return t.src;
          let e;
          if (t instanceof HTMLCanvasElement) e = t;
          else {
            Yn === void 0 && (Yn = zi("canvas")),
              (Yn.width = t.width),
              (Yn.height = t.height);
            const n = Yn.getContext("2d");
            t instanceof ImageData
              ? n.putImageData(t, 0, 0)
              : n.drawImage(t, 0, 0, t.width, t.height),
              (e = Yn);
          }
          return e.width > 2048 || e.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                t
              ),
              e.toDataURL("image/jpeg", 0.6))
            : e.toDataURL("image/png");
        }
        static sRGBToLinear(t) {
          if (
            (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement) ||
            (typeof HTMLCanvasElement < "u" &&
              t instanceof HTMLCanvasElement) ||
            (typeof ImageBitmap < "u" && t instanceof ImageBitmap)
          ) {
            const e = zi("canvas");
            (e.width = t.width), (e.height = t.height);
            const n = e.getContext("2d");
            n.drawImage(t, 0, 0, t.width, t.height);
            const r = n.getImageData(0, 0, t.width, t.height),
              s = r.data;
            for (let a = 0; a < s.length; a++) s[a] = ui(s[a] / 255) * 255;
            return n.putImageData(r, 0, 0), e;
          } else if (t.data) {
            const e = t.data.slice(0);
            for (let n = 0; n < e.length; n++)
              e instanceof Uint8Array || e instanceof Uint8ClampedArray
                ? (e[n] = Math.floor(ui(e[n] / 255) * 255))
                : (e[n] = ui(e[n]));
            return { data: e, width: t.width, height: t.height };
          } else
            return (
              console.warn(
                "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
              ),
              t
            );
        }
      }
      let zc = 0;
      class nl {
        constructor(t = null) {
          (this.isSource = !0),
            Object.defineProperty(this, "id", { value: zc++ }),
            (this.uuid = Mi()),
            (this.data = t),
            (this.dataReady = !0),
            (this.version = 0);
        }
        set needsUpdate(t) {
          t === !0 && this.version++;
        }
        toJSON(t) {
          const e = t === void 0 || typeof t == "string";
          if (!e && t.images[this.uuid] !== void 0) return t.images[this.uuid];
          const n = { uuid: this.uuid, url: "" },
            r = this.data;
          if (r !== null) {
            let s;
            if (Array.isArray(r)) {
              s = [];
              for (let a = 0, o = r.length; a < o; a++)
                r[a].isDataTexture ? s.push(Vr(r[a].image)) : s.push(Vr(r[a]));
            } else s = Vr(r);
            n.url = s;
          }
          return e || (t.images[this.uuid] = n), n;
        }
      }
      function Vr(i) {
        return (typeof HTMLImageElement < "u" &&
          i instanceof HTMLImageElement) ||
          (typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement) ||
          (typeof ImageBitmap < "u" && i instanceof ImageBitmap)
          ? Bc.getDataURL(i)
          : i.data
          ? {
              data: Array.from(i.data),
              width: i.width,
              height: i.height,
              type: i.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let Hc = 0;
      class xe extends kn {
        constructor(
          t = xe.DEFAULT_IMAGE,
          e = xe.DEFAULT_MAPPING,
          n = Bn,
          r = Bn,
          s = ke,
          a = zn,
          o = Xe,
          l = ln,
          c = xe.DEFAULT_ANISOTROPY,
          h = vn
        ) {
          super(),
            (this.isTexture = !0),
            Object.defineProperty(this, "id", { value: Hc++ }),
            (this.uuid = Mi()),
            (this.name = ""),
            (this.source = new nl(t)),
            (this.mipmaps = []),
            (this.mapping = e),
            (this.channel = 0),
            (this.wrapS = n),
            (this.wrapT = r),
            (this.magFilter = s),
            (this.minFilter = a),
            (this.anisotropy = c),
            (this.format = o),
            (this.internalFormat = null),
            (this.type = l),
            (this.offset = new Pt(0, 0)),
            (this.repeat = new Pt(1, 1)),
            (this.center = new Pt(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new Dt()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.colorSpace = h),
            (this.userData = {}),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1),
            (this.pmremVersion = 0);
        }
        get image() {
          return this.source.data;
        }
        set image(t = null) {
          this.source.data = t;
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.source = t.source),
            (this.mipmaps = t.mipmaps.slice(0)),
            (this.mapping = t.mapping),
            (this.channel = t.channel),
            (this.wrapS = t.wrapS),
            (this.wrapT = t.wrapT),
            (this.magFilter = t.magFilter),
            (this.minFilter = t.minFilter),
            (this.anisotropy = t.anisotropy),
            (this.format = t.format),
            (this.internalFormat = t.internalFormat),
            (this.type = t.type),
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            (this.rotation = t.rotation),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this.matrix.copy(t.matrix),
            (this.generateMipmaps = t.generateMipmaps),
            (this.premultiplyAlpha = t.premultiplyAlpha),
            (this.flipY = t.flipY),
            (this.unpackAlignment = t.unpackAlignment),
            (this.colorSpace = t.colorSpace),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            (this.needsUpdate = !0),
            this
          );
        }
        toJSON(t) {
          const e = t === void 0 || typeof t == "string";
          if (!e && t.textures[this.uuid] !== void 0)
            return t.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.6,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(t).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          return (
            Object.keys(this.userData).length > 0 &&
              (n.userData = this.userData),
            e || (t.textures[this.uuid] = n),
            n
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(t) {
          if (this.mapping !== Vo) return t;
          if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
            switch (this.wrapS) {
              case Cs:
                t.x = t.x - Math.floor(t.x);
                break;
              case Bn:
                t.x = t.x < 0 ? 0 : 1;
                break;
              case Ps:
                Math.abs(Math.floor(t.x) % 2) === 1
                  ? (t.x = Math.ceil(t.x) - t.x)
                  : (t.x = t.x - Math.floor(t.x));
                break;
            }
          if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
              case Cs:
                t.y = t.y - Math.floor(t.y);
                break;
              case Bn:
                t.y = t.y < 0 ? 0 : 1;
                break;
              case Ps:
                Math.abs(Math.floor(t.y) % 2) === 1
                  ? (t.y = Math.ceil(t.y) - t.y)
                  : (t.y = t.y - Math.floor(t.y));
                break;
            }
          return this.flipY && (t.y = 1 - t.y), t;
        }
        set needsUpdate(t) {
          t === !0 && (this.version++, (this.source.needsUpdate = !0));
        }
        set needsPMREMUpdate(t) {
          t === !0 && this.pmremVersion++;
        }
      }
      xe.DEFAULT_IMAGE = null;
      xe.DEFAULT_MAPPING = Vo;
      xe.DEFAULT_ANISOTROPY = 1;
      class Zt {
        constructor(t = 0, e = 0, n = 0, r = 1) {
          (Zt.prototype.isVector4 = !0),
            (this.x = t),
            (this.y = e),
            (this.z = n),
            (this.w = r);
        }
        get width() {
          return this.z;
        }
        set width(t) {
          this.z = t;
        }
        get height() {
          return this.w;
        }
        set height(t) {
          this.w = t;
        }
        set(t, e, n, r) {
          return (this.x = t), (this.y = e), (this.z = n), (this.w = r), this;
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setZ(t) {
          return (this.z = t), this;
        }
        setW(t) {
          return (this.w = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            case 3:
              this.w = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.z = t.z),
            (this.w = t.w !== void 0 ? t.w : 1),
            this
          );
        }
        add(t) {
          return (
            (this.x += t.x),
            (this.y += t.y),
            (this.z += t.z),
            (this.w += t.w),
            this
          );
        }
        addScalar(t) {
          return (
            (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
          );
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            (this.w = t.w + e.w),
            this
          );
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e),
            (this.y += t.y * e),
            (this.z += t.z * e),
            (this.w += t.w * e),
            this
          );
        }
        sub(t) {
          return (
            (this.x -= t.x),
            (this.y -= t.y),
            (this.z -= t.z),
            (this.w -= t.w),
            this
          );
        }
        subScalar(t) {
          return (
            (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
          );
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            (this.w = t.w - e.w),
            this
          );
        }
        multiply(t) {
          return (
            (this.x *= t.x),
            (this.y *= t.y),
            (this.z *= t.z),
            (this.w *= t.w),
            this
          );
        }
        multiplyScalar(t) {
          return (
            (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
          );
        }
        applyMatrix4(t) {
          const e = this.x,
            n = this.y,
            r = this.z,
            s = this.w,
            a = t.elements;
          return (
            (this.x = a[0] * e + a[4] * n + a[8] * r + a[12] * s),
            (this.y = a[1] * e + a[5] * n + a[9] * r + a[13] * s),
            (this.z = a[2] * e + a[6] * n + a[10] * r + a[14] * s),
            (this.w = a[3] * e + a[7] * n + a[11] * r + a[15] * s),
            this
          );
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        setAxisAngleFromQuaternion(t) {
          this.w = 2 * Math.acos(t.w);
          const e = Math.sqrt(1 - t.w * t.w);
          return (
            e < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(t) {
          let e, n, r, s;
          const l = t.elements,
            c = l[0],
            h = l[4],
            f = l[8],
            p = l[1],
            m = l[5],
            v = l[9],
            M = l[2],
            u = l[6],
            d = l[10];
          if (
            Math.abs(h - p) < 0.01 &&
            Math.abs(f - M) < 0.01 &&
            Math.abs(v - u) < 0.01
          ) {
            if (
              Math.abs(h + p) < 0.1 &&
              Math.abs(f + M) < 0.1 &&
              Math.abs(v + u) < 0.1 &&
              Math.abs(c + m + d - 3) < 0.1
            )
              return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            const E = (c + 1) / 2,
              A = (m + 1) / 2,
              O = (d + 1) / 2,
              P = (h + p) / 4,
              b = (f + M) / 4,
              F = (v + u) / 4;
            return (
              E > A && E > O
                ? E < 0.01
                  ? ((n = 0), (r = 0.707106781), (s = 0.707106781))
                  : ((n = Math.sqrt(E)), (r = P / n), (s = b / n))
                : A > O
                ? A < 0.01
                  ? ((n = 0.707106781), (r = 0), (s = 0.707106781))
                  : ((r = Math.sqrt(A)), (n = P / r), (s = F / r))
                : O < 0.01
                ? ((n = 0.707106781), (r = 0.707106781), (s = 0))
                : ((s = Math.sqrt(O)), (n = b / s), (r = F / s)),
              this.set(n, r, s, e),
              this
            );
          }
          let T = Math.sqrt(
            (u - v) * (u - v) + (f - M) * (f - M) + (p - h) * (p - h)
          );
          return (
            Math.abs(T) < 0.001 && (T = 1),
            (this.x = (u - v) / T),
            (this.y = (f - M) / T),
            (this.z = (p - h) / T),
            (this.w = Math.acos((c + m + d - 1) / 2)),
            this
          );
        }
        setFromMatrixPosition(t) {
          const e = t.elements;
          return (
            (this.x = e[12]),
            (this.y = e[13]),
            (this.z = e[14]),
            (this.w = e[15]),
            this
          );
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            (this.w = Math.min(this.w, t.w)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            (this.w = Math.max(this.w, t.w)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            (this.w = Math.max(t.w, Math.min(e.w, this.w))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            (this.w = Math.max(t, Math.min(e, this.w))),
            this
          );
        }
        clampLength(t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            (this.w = Math.trunc(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            (this.w += (t.w - this.w) * e),
            this
          );
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            (this.z = t.z + (e.z - t.z) * n),
            (this.w = t.w + (e.w - t.w) * n),
            this
          );
        }
        equals(t) {
          return (
            t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
          );
        }
        fromArray(t, e = 0) {
          return (
            (this.x = t[e]),
            (this.y = t[e + 1]),
            (this.z = t[e + 2]),
            (this.w = t[e + 3]),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this.x),
            (t[e + 1] = this.y),
            (t[e + 2] = this.z),
            (t[e + 3] = this.w),
            t
          );
        }
        fromBufferAttribute(t, e) {
          return (
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            (this.w = t.getW(e)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class Gc extends kn {
        constructor(t = 1, e = 1, n = {}) {
          super(),
            (this.isRenderTarget = !0),
            (this.width = t),
            (this.height = e),
            (this.depth = 1),
            (this.scissor = new Zt(0, 0, t, e)),
            (this.scissorTest = !1),
            (this.viewport = new Zt(0, 0, t, e));
          const r = { width: t, height: e, depth: 1 };
          n = Object.assign(
            {
              generateMipmaps: !1,
              internalFormat: null,
              minFilter: ke,
              depthBuffer: !0,
              stencilBuffer: !1,
              resolveDepthBuffer: !0,
              resolveStencilBuffer: !0,
              depthTexture: null,
              samples: 0,
              count: 1,
            },
            n
          );
          const s = new xe(
            r,
            n.mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.colorSpace
          );
          (s.flipY = !1),
            (s.generateMipmaps = n.generateMipmaps),
            (s.internalFormat = n.internalFormat),
            (this.textures = []);
          const a = n.count;
          for (let o = 0; o < a; o++)
            (this.textures[o] = s.clone()),
              (this.textures[o].isRenderTargetTexture = !0);
          (this.depthBuffer = n.depthBuffer),
            (this.stencilBuffer = n.stencilBuffer),
            (this.resolveDepthBuffer = n.resolveDepthBuffer),
            (this.resolveStencilBuffer = n.resolveStencilBuffer),
            (this.depthTexture = n.depthTexture),
            (this.samples = n.samples);
        }
        get texture() {
          return this.textures[0];
        }
        set texture(t) {
          this.textures[0] = t;
        }
        setSize(t, e, n = 1) {
          if (this.width !== t || this.height !== e || this.depth !== n) {
            (this.width = t), (this.height = e), (this.depth = n);
            for (let r = 0, s = this.textures.length; r < s; r++)
              (this.textures[r].image.width = t),
                (this.textures[r].image.height = e),
                (this.textures[r].image.depth = n);
            this.dispose();
          }
          this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.width = t.width),
            (this.height = t.height),
            (this.depth = t.depth),
            this.scissor.copy(t.scissor),
            (this.scissorTest = t.scissorTest),
            this.viewport.copy(t.viewport),
            (this.textures.length = 0);
          for (let n = 0, r = t.textures.length; n < r; n++)
            (this.textures[n] = t.textures[n].clone()),
              (this.textures[n].isRenderTargetTexture = !0);
          const e = Object.assign({}, t.texture.image);
          return (
            (this.texture.source = new nl(e)),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.resolveDepthBuffer = t.resolveDepthBuffer),
            (this.resolveStencilBuffer = t.resolveStencilBuffer),
            t.depthTexture !== null &&
              (this.depthTexture = t.depthTexture.clone()),
            (this.samples = t.samples),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      class Gn extends Gc {
        constructor(t = 1, e = 1, n = {}) {
          super(t, e, n), (this.isWebGLRenderTarget = !0);
        }
      }
      class il extends xe {
        constructor(t = null, e = 1, n = 1, r = 1) {
          super(null),
            (this.isDataArrayTexture = !0),
            (this.image = { data: t, width: e, height: n, depth: r }),
            (this.magFilter = Ne),
            (this.minFilter = Ne),
            (this.wrapR = Bn),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.layerUpdates = new Set());
        }
        addLayerUpdate(t) {
          this.layerUpdates.add(t);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class Vc extends xe {
        constructor(t = null, e = 1, n = 1, r = 1) {
          super(null),
            (this.isData3DTexture = !0),
            (this.image = { data: t, width: e, height: n, depth: r }),
            (this.magFilter = Ne),
            (this.minFilter = Ne),
            (this.wrapR = Bn),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      class Vn {
        constructor(t = 0, e = 0, n = 0, r = 1) {
          (this.isQuaternion = !0),
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._w = r);
        }
        static slerpFlat(t, e, n, r, s, a, o) {
          let l = n[r + 0],
            c = n[r + 1],
            h = n[r + 2],
            f = n[r + 3];
          const p = s[a + 0],
            m = s[a + 1],
            v = s[a + 2],
            M = s[a + 3];
          if (o === 0) {
            (t[e + 0] = l), (t[e + 1] = c), (t[e + 2] = h), (t[e + 3] = f);
            return;
          }
          if (o === 1) {
            (t[e + 0] = p), (t[e + 1] = m), (t[e + 2] = v), (t[e + 3] = M);
            return;
          }
          if (f !== M || l !== p || c !== m || h !== v) {
            let u = 1 - o;
            const d = l * p + c * m + h * v + f * M,
              T = d >= 0 ? 1 : -1,
              E = 1 - d * d;
            if (E > Number.EPSILON) {
              const O = Math.sqrt(E),
                P = Math.atan2(O, d * T);
              (u = Math.sin(u * P) / O), (o = Math.sin(o * P) / O);
            }
            const A = o * T;
            if (
              ((l = l * u + p * A),
              (c = c * u + m * A),
              (h = h * u + v * A),
              (f = f * u + M * A),
              u === 1 - o)
            ) {
              const O = 1 / Math.sqrt(l * l + c * c + h * h + f * f);
              (l *= O), (c *= O), (h *= O), (f *= O);
            }
          }
          (t[e] = l), (t[e + 1] = c), (t[e + 2] = h), (t[e + 3] = f);
        }
        static multiplyQuaternionsFlat(t, e, n, r, s, a) {
          const o = n[r],
            l = n[r + 1],
            c = n[r + 2],
            h = n[r + 3],
            f = s[a],
            p = s[a + 1],
            m = s[a + 2],
            v = s[a + 3];
          return (
            (t[e] = o * v + h * f + l * m - c * p),
            (t[e + 1] = l * v + h * p + c * f - o * m),
            (t[e + 2] = c * v + h * m + o * p - l * f),
            (t[e + 3] = h * v - o * f - l * p - c * m),
            t
          );
        }
        get x() {
          return this._x;
        }
        set x(t) {
          (this._x = t), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          (this._y = t), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          (this._z = t), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(t) {
          (this._w = t), this._onChangeCallback();
        }
        set(t, e, n, r) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._w = r),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(t) {
          return (
            (this._x = t.x),
            (this._y = t.y),
            (this._z = t.z),
            (this._w = t.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(t, e = !0) {
          const n = t._x,
            r = t._y,
            s = t._z,
            a = t._order,
            o = Math.cos,
            l = Math.sin,
            c = o(n / 2),
            h = o(r / 2),
            f = o(s / 2),
            p = l(n / 2),
            m = l(r / 2),
            v = l(s / 2);
          switch (a) {
            case "XYZ":
              (this._x = p * h * f + c * m * v),
                (this._y = c * m * f - p * h * v),
                (this._z = c * h * v + p * m * f),
                (this._w = c * h * f - p * m * v);
              break;
            case "YXZ":
              (this._x = p * h * f + c * m * v),
                (this._y = c * m * f - p * h * v),
                (this._z = c * h * v - p * m * f),
                (this._w = c * h * f + p * m * v);
              break;
            case "ZXY":
              (this._x = p * h * f - c * m * v),
                (this._y = c * m * f + p * h * v),
                (this._z = c * h * v + p * m * f),
                (this._w = c * h * f - p * m * v);
              break;
            case "ZYX":
              (this._x = p * h * f - c * m * v),
                (this._y = c * m * f + p * h * v),
                (this._z = c * h * v - p * m * f),
                (this._w = c * h * f + p * m * v);
              break;
            case "YZX":
              (this._x = p * h * f + c * m * v),
                (this._y = c * m * f + p * h * v),
                (this._z = c * h * v - p * m * f),
                (this._w = c * h * f - p * m * v);
              break;
            case "XZY":
              (this._x = p * h * f - c * m * v),
                (this._y = c * m * f - p * h * v),
                (this._z = c * h * v + p * m * f),
                (this._w = c * h * f + p * m * v);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  a
              );
          }
          return e === !0 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(t, e) {
          const n = e / 2,
            r = Math.sin(n);
          return (
            (this._x = t.x * r),
            (this._y = t.y * r),
            (this._z = t.z * r),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(t) {
          const e = t.elements,
            n = e[0],
            r = e[4],
            s = e[8],
            a = e[1],
            o = e[5],
            l = e[9],
            c = e[2],
            h = e[6],
            f = e[10],
            p = n + o + f;
          if (p > 0) {
            const m = 0.5 / Math.sqrt(p + 1);
            (this._w = 0.25 / m),
              (this._x = (h - l) * m),
              (this._y = (s - c) * m),
              (this._z = (a - r) * m);
          } else if (n > o && n > f) {
            const m = 2 * Math.sqrt(1 + n - o - f);
            (this._w = (h - l) / m),
              (this._x = 0.25 * m),
              (this._y = (r + a) / m),
              (this._z = (s + c) / m);
          } else if (o > f) {
            const m = 2 * Math.sqrt(1 + o - n - f);
            (this._w = (s - c) / m),
              (this._x = (r + a) / m),
              (this._y = 0.25 * m),
              (this._z = (l + h) / m);
          } else {
            const m = 2 * Math.sqrt(1 + f - n - o);
            (this._w = (a - r) / m),
              (this._x = (s + c) / m),
              (this._y = (l + h) / m),
              (this._z = 0.25 * m);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(t, e) {
          let n = t.dot(e) + 1;
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(t.x) > Math.abs(t.z)
                  ? ((this._x = -t.y),
                    (this._y = t.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -t.z),
                    (this._z = t.y),
                    (this._w = n)))
              : ((this._x = t.y * e.z - t.z * e.y),
                (this._y = t.z * e.x - t.x * e.z),
                (this._z = t.x * e.y - t.y * e.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(t) {
          return 2 * Math.acos(Math.abs(me(this.dot(t), -1, 1)));
        }
        rotateTowards(t, e) {
          const n = this.angleTo(t);
          if (n === 0) return this;
          const r = Math.min(1, e / n);
          return this.slerp(t, r), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(t) {
          return (
            this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let t = this.length();
          return (
            t === 0
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((t = 1 / t),
                (this._x = this._x * t),
                (this._y = this._y * t),
                (this._z = this._z * t),
                (this._w = this._w * t)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(t) {
          return this.multiplyQuaternions(this, t);
        }
        premultiply(t) {
          return this.multiplyQuaternions(t, this);
        }
        multiplyQuaternions(t, e) {
          const n = t._x,
            r = t._y,
            s = t._z,
            a = t._w,
            o = e._x,
            l = e._y,
            c = e._z,
            h = e._w;
          return (
            (this._x = n * h + a * o + r * c - s * l),
            (this._y = r * h + a * l + s * o - n * c),
            (this._z = s * h + a * c + n * l - r * o),
            (this._w = a * h - n * o - r * l - s * c),
            this._onChangeCallback(),
            this
          );
        }
        slerp(t, e) {
          if (e === 0) return this;
          if (e === 1) return this.copy(t);
          const n = this._x,
            r = this._y,
            s = this._z,
            a = this._w;
          let o = a * t._w + n * t._x + r * t._y + s * t._z;
          if (
            (o < 0
              ? ((this._w = -t._w),
                (this._x = -t._x),
                (this._y = -t._y),
                (this._z = -t._z),
                (o = -o))
              : this.copy(t),
            o >= 1)
          )
            return (
              (this._w = a), (this._x = n), (this._y = r), (this._z = s), this
            );
          const l = 1 - o * o;
          if (l <= Number.EPSILON) {
            const m = 1 - e;
            return (
              (this._w = m * a + e * this._w),
              (this._x = m * n + e * this._x),
              (this._y = m * r + e * this._y),
              (this._z = m * s + e * this._z),
              this.normalize(),
              this
            );
          }
          const c = Math.sqrt(l),
            h = Math.atan2(c, o),
            f = Math.sin((1 - e) * h) / c,
            p = Math.sin(e * h) / c;
          return (
            (this._w = a * f + this._w * p),
            (this._x = n * f + this._x * p),
            (this._y = r * f + this._y * p),
            (this._z = s * f + this._z * p),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(t, e, n) {
          return this.copy(t).slerp(e, n);
        }
        random() {
          const t = 2 * Math.PI * Math.random(),
            e = 2 * Math.PI * Math.random(),
            n = Math.random(),
            r = Math.sqrt(1 - n),
            s = Math.sqrt(n);
          return this.set(
            r * Math.sin(t),
            r * Math.cos(t),
            s * Math.sin(e),
            s * Math.cos(e)
          );
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._w === this._w
          );
        }
        fromArray(t, e = 0) {
          return (
            (this._x = t[e]),
            (this._y = t[e + 1]),
            (this._z = t[e + 2]),
            (this._w = t[e + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._w),
            t
          );
        }
        fromBufferAttribute(t, e) {
          return (
            (this._x = t.getX(e)),
            (this._y = t.getY(e)),
            (this._z = t.getZ(e)),
            (this._w = t.getW(e)),
            this._onChangeCallback(),
            this
          );
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class D {
        constructor(t = 0, e = 0, n = 0) {
          (D.prototype.isVector3 = !0),
            (this.x = t),
            (this.y = e),
            (this.z = n);
        }
        set(t, e, n) {
          return (
            n === void 0 && (n = this.z),
            (this.x = t),
            (this.y = e),
            (this.z = n),
            this
          );
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setZ(t) {
          return (this.z = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
        }
        add(t) {
          return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), (this.z += t), this;
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            this
          );
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
          );
        }
        sub(t) {
          return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), (this.z -= t), this;
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            this
          );
        }
        multiply(t) {
          return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), (this.z *= t), this;
        }
        multiplyVectors(t, e) {
          return (
            (this.x = t.x * e.x),
            (this.y = t.y * e.y),
            (this.z = t.z * e.z),
            this
          );
        }
        applyEuler(t) {
          return this.applyQuaternion(Ga.setFromEuler(t));
        }
        applyAxisAngle(t, e) {
          return this.applyQuaternion(Ga.setFromAxisAngle(t, e));
        }
        applyMatrix3(t) {
          const e = this.x,
            n = this.y,
            r = this.z,
            s = t.elements;
          return (
            (this.x = s[0] * e + s[3] * n + s[6] * r),
            (this.y = s[1] * e + s[4] * n + s[7] * r),
            (this.z = s[2] * e + s[5] * n + s[8] * r),
            this
          );
        }
        applyNormalMatrix(t) {
          return this.applyMatrix3(t).normalize();
        }
        applyMatrix4(t) {
          const e = this.x,
            n = this.y,
            r = this.z,
            s = t.elements,
            a = 1 / (s[3] * e + s[7] * n + s[11] * r + s[15]);
          return (
            (this.x = (s[0] * e + s[4] * n + s[8] * r + s[12]) * a),
            (this.y = (s[1] * e + s[5] * n + s[9] * r + s[13]) * a),
            (this.z = (s[2] * e + s[6] * n + s[10] * r + s[14]) * a),
            this
          );
        }
        applyQuaternion(t) {
          const e = this.x,
            n = this.y,
            r = this.z,
            s = t.x,
            a = t.y,
            o = t.z,
            l = t.w,
            c = 2 * (a * r - o * n),
            h = 2 * (o * e - s * r),
            f = 2 * (s * n - a * e);
          return (
            (this.x = e + l * c + a * f - o * h),
            (this.y = n + l * h + o * c - s * f),
            (this.z = r + l * f + s * h - a * c),
            this
          );
        }
        project(t) {
          return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
            t.projectionMatrix
          );
        }
        unproject(t) {
          return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
            t.matrixWorld
          );
        }
        transformDirection(t) {
          const e = this.x,
            n = this.y,
            r = this.z,
            s = t.elements;
          return (
            (this.x = s[0] * e + s[4] * n + s[8] * r),
            (this.y = s[1] * e + s[5] * n + s[9] * r),
            (this.z = s[2] * e + s[6] * n + s[10] * r),
            this.normalize()
          );
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            this
          );
        }
        clampLength(t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            this
          );
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            (this.z = t.z + (e.z - t.z) * n),
            this
          );
        }
        cross(t) {
          return this.crossVectors(this, t);
        }
        crossVectors(t, e) {
          const n = t.x,
            r = t.y,
            s = t.z,
            a = e.x,
            o = e.y,
            l = e.z;
          return (
            (this.x = r * l - s * o),
            (this.y = s * a - n * l),
            (this.z = n * o - r * a),
            this
          );
        }
        projectOnVector(t) {
          const e = t.lengthSq();
          if (e === 0) return this.set(0, 0, 0);
          const n = t.dot(this) / e;
          return this.copy(t).multiplyScalar(n);
        }
        projectOnPlane(t) {
          return kr.copy(this).projectOnVector(t), this.sub(kr);
        }
        reflect(t) {
          return this.sub(kr.copy(t).multiplyScalar(2 * this.dot(t)));
        }
        angleTo(t) {
          const e = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (e === 0) return Math.PI / 2;
          const n = this.dot(t) / e;
          return Math.acos(me(n, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            n = this.y - t.y,
            r = this.z - t.z;
          return e * e + n * n + r * r;
        }
        manhattanDistanceTo(t) {
          return (
            Math.abs(this.x - t.x) +
            Math.abs(this.y - t.y) +
            Math.abs(this.z - t.z)
          );
        }
        setFromSpherical(t) {
          return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
        }
        setFromSphericalCoords(t, e, n) {
          const r = Math.sin(e) * t;
          return (
            (this.x = r * Math.sin(n)),
            (this.y = Math.cos(e) * t),
            (this.z = r * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(t) {
          return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
        }
        setFromCylindricalCoords(t, e, n) {
          return (
            (this.x = t * Math.sin(e)),
            (this.y = n),
            (this.z = t * Math.cos(e)),
            this
          );
        }
        setFromMatrixPosition(t) {
          const e = t.elements;
          return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
        }
        setFromMatrixScale(t) {
          const e = this.setFromMatrixColumn(t, 0).length(),
            n = this.setFromMatrixColumn(t, 1).length(),
            r = this.setFromMatrixColumn(t, 2).length();
          return (this.x = e), (this.y = n), (this.z = r), this;
        }
        setFromMatrixColumn(t, e) {
          return this.fromArray(t.elements, e * 4);
        }
        setFromMatrix3Column(t, e) {
          return this.fromArray(t.elements, e * 3);
        }
        setFromEuler(t) {
          return (this.x = t._x), (this.y = t._y), (this.z = t._z), this;
        }
        setFromColor(t) {
          return (this.x = t.r), (this.y = t.g), (this.z = t.b), this;
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z;
        }
        fromArray(t, e = 0) {
          return (
            (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
          );
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
        }
        fromBufferAttribute(t, e) {
          return (
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
        randomDirection() {
          const t = Math.random() * Math.PI * 2,
            e = Math.random() * 2 - 1,
            n = Math.sqrt(1 - e * e);
          return (
            (this.x = n * Math.cos(t)),
            (this.y = e),
            (this.z = n * Math.sin(t)),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const kr = new D(),
        Ga = new Vn();
      class Vi {
        constructor(
          t = new D(1 / 0, 1 / 0, 1 / 0),
          e = new D(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.isBox3 = !0), (this.min = t), (this.max = e);
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        }
        setFromArray(t) {
          this.makeEmpty();
          for (let e = 0, n = t.length; e < n; e += 3)
            this.expandByPoint(Be.fromArray(t, e));
          return this;
        }
        setFromBufferAttribute(t) {
          this.makeEmpty();
          for (let e = 0, n = t.count; e < n; e++)
            this.expandByPoint(Be.fromBufferAttribute(t, e));
          return this;
        }
        setFromPoints(t) {
          this.makeEmpty();
          for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
          return this;
        }
        setFromCenterAndSize(t, e) {
          const n = Be.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
        }
        setFromObject(t, e = !1) {
          return this.makeEmpty(), this.expandByObject(t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        expandByObject(t, e = !1) {
          t.updateWorldMatrix(!1, !1);
          const n = t.geometry;
          if (n !== void 0) {
            const s = n.getAttribute("position");
            if (e === !0 && s !== void 0 && t.isInstancedMesh !== !0)
              for (let a = 0, o = s.count; a < o; a++)
                t.isMesh === !0
                  ? t.getVertexPosition(a, Be)
                  : Be.fromBufferAttribute(s, a),
                  Be.applyMatrix4(t.matrixWorld),
                  this.expandByPoint(Be);
            else
              t.boundingBox !== void 0
                ? (t.boundingBox === null && t.computeBoundingBox(),
                  Yi.copy(t.boundingBox))
                : (n.boundingBox === null && n.computeBoundingBox(),
                  Yi.copy(n.boundingBox)),
                Yi.applyMatrix4(t.matrixWorld),
                this.union(Yi);
          }
          const r = t.children;
          for (let s = 0, a = r.length; s < a; s++)
            this.expandByObject(r[s], e);
          return this;
        }
        containsPoint(t) {
          return (
            t.x >= this.min.x &&
            t.x <= this.max.x &&
            t.y >= this.min.y &&
            t.y <= this.max.y &&
            t.z >= this.min.z &&
            t.z <= this.max.z
          );
        }
        containsBox(t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y &&
            this.min.z <= t.min.z &&
            t.max.z <= this.max.z
          );
        }
        getParameter(t, e) {
          return e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(t) {
          return (
            t.max.x >= this.min.x &&
            t.min.x <= this.max.x &&
            t.max.y >= this.min.y &&
            t.min.y <= this.max.y &&
            t.max.z >= this.min.z &&
            t.min.z <= this.max.z
          );
        }
        intersectsSphere(t) {
          return (
            this.clampPoint(t.center, Be),
            Be.distanceToSquared(t.center) <= t.radius * t.radius
          );
        }
        intersectsPlane(t) {
          let e, n;
          return (
            t.normal.x > 0
              ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
              : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
            t.normal.y > 0
              ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
              : ((e += t.normal.y * this.max.y),
                (n += t.normal.y * this.min.y)),
            t.normal.z > 0
              ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
              : ((e += t.normal.z * this.max.z),
                (n += t.normal.z * this.min.z)),
            e <= -t.constant && n >= -t.constant
          );
        }
        intersectsTriangle(t) {
          if (this.isEmpty()) return !1;
          this.getCenter(Ai),
            qi.subVectors(this.max, Ai),
            qn.subVectors(t.a, Ai),
            Kn.subVectors(t.b, Ai),
            jn.subVectors(t.c, Ai),
            un.subVectors(Kn, qn),
            dn.subVectors(jn, Kn),
            Cn.subVectors(qn, jn);
          let e = [
            0,
            -un.z,
            un.y,
            0,
            -dn.z,
            dn.y,
            0,
            -Cn.z,
            Cn.y,
            un.z,
            0,
            -un.x,
            dn.z,
            0,
            -dn.x,
            Cn.z,
            0,
            -Cn.x,
            -un.y,
            un.x,
            0,
            -dn.y,
            dn.x,
            0,
            -Cn.y,
            Cn.x,
            0,
          ];
          return !Wr(e, qn, Kn, jn, qi) ||
            ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Wr(e, qn, Kn, jn, qi))
            ? !1
            : (Ki.crossVectors(un, dn),
              (e = [Ki.x, Ki.y, Ki.z]),
              Wr(e, qn, Kn, jn, qi));
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
          return this.clampPoint(t, Be).distanceTo(t);
        }
        getBoundingSphere(t) {
          return (
            this.isEmpty()
              ? t.makeEmpty()
              : (this.getCenter(t.center),
                (t.radius = this.getSize(Be).length() * 0.5)),
            t
          );
        }
        intersect(t) {
          return (
            this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        }
        applyMatrix4(t) {
          return this.isEmpty()
            ? this
            : ($e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
              $e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
              $e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
              $e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
              $e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
              $e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
              $e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
              $e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
              this.setFromPoints($e),
              this);
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        }
      }
      const $e = [
          new D(),
          new D(),
          new D(),
          new D(),
          new D(),
          new D(),
          new D(),
          new D(),
        ],
        Be = new D(),
        Yi = new Vi(),
        qn = new D(),
        Kn = new D(),
        jn = new D(),
        un = new D(),
        dn = new D(),
        Cn = new D(),
        Ai = new D(),
        qi = new D(),
        Ki = new D(),
        Pn = new D();
      function Wr(i, t, e, n, r) {
        for (let s = 0, a = i.length - 3; s <= a; s += 3) {
          Pn.fromArray(i, s);
          const o =
              r.x * Math.abs(Pn.x) +
              r.y * Math.abs(Pn.y) +
              r.z * Math.abs(Pn.z),
            l = t.dot(Pn),
            c = e.dot(Pn),
            h = n.dot(Pn);
          if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > o) return !1;
        }
        return !0;
      }
      const kc = new Vi(),
        bi = new D(),
        Xr = new D();
      class Dr {
        constructor(t = new D(), e = -1) {
          (this.isSphere = !0), (this.center = t), (this.radius = e);
        }
        set(t, e) {
          return this.center.copy(t), (this.radius = e), this;
        }
        setFromPoints(t, e) {
          const n = this.center;
          e !== void 0 ? n.copy(e) : kc.setFromPoints(t).getCenter(n);
          let r = 0;
          for (let s = 0, a = t.length; s < a; s++)
            r = Math.max(r, n.distanceToSquared(t[s]));
          return (this.radius = Math.sqrt(r)), this;
        }
        copy(t) {
          return this.center.copy(t.center), (this.radius = t.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(t) {
          return t.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(t) {
          return t.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(t) {
          const e = this.radius + t.radius;
          return t.center.distanceToSquared(this.center) <= e * e;
        }
        intersectsBox(t) {
          return t.intersectsSphere(this);
        }
        intersectsPlane(t) {
          return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(t, e) {
          const n = this.center.distanceToSquared(t);
          return (
            e.copy(t),
            n > this.radius * this.radius &&
              (e.sub(this.center).normalize(),
              e.multiplyScalar(this.radius).add(this.center)),
            e
          );
        }
        getBoundingBox(t) {
          return this.isEmpty()
            ? (t.makeEmpty(), t)
            : (t.set(this.center, this.center),
              t.expandByScalar(this.radius),
              t);
        }
        applyMatrix4(t) {
          return (
            this.center.applyMatrix4(t),
            (this.radius = this.radius * t.getMaxScaleOnAxis()),
            this
          );
        }
        translate(t) {
          return this.center.add(t), this;
        }
        expandByPoint(t) {
          if (this.isEmpty())
            return this.center.copy(t), (this.radius = 0), this;
          bi.subVectors(t, this.center);
          const e = bi.lengthSq();
          if (e > this.radius * this.radius) {
            const n = Math.sqrt(e),
              r = (n - this.radius) * 0.5;
            this.center.addScaledVector(bi, r / n), (this.radius += r);
          }
          return this;
        }
        union(t) {
          return t.isEmpty()
            ? this
            : this.isEmpty()
            ? (this.copy(t), this)
            : (this.center.equals(t.center) === !0
                ? (this.radius = Math.max(this.radius, t.radius))
                : (Xr.subVectors(t.center, this.center).setLength(t.radius),
                  this.expandByPoint(bi.copy(t.center).add(Xr)),
                  this.expandByPoint(bi.copy(t.center).sub(Xr))),
              this);
        }
        equals(t) {
          return t.center.equals(this.center) && t.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Je = new D(),
        Yr = new D(),
        ji = new D(),
        fn = new D(),
        qr = new D(),
        Zi = new D(),
        Kr = new D();
      class pa {
        constructor(t = new D(), e = new D(0, 0, -1)) {
          (this.origin = t), (this.direction = e);
        }
        set(t, e) {
          return this.origin.copy(t), this.direction.copy(e), this;
        }
        copy(t) {
          return (
            this.origin.copy(t.origin), this.direction.copy(t.direction), this
          );
        }
        at(t, e) {
          return e.copy(this.origin).addScaledVector(this.direction, t);
        }
        lookAt(t) {
          return this.direction.copy(t).sub(this.origin).normalize(), this;
        }
        recast(t) {
          return this.origin.copy(this.at(t, Je)), this;
        }
        closestPointToPoint(t, e) {
          e.subVectors(t, this.origin);
          const n = e.dot(this.direction);
          return n < 0
            ? e.copy(this.origin)
            : e.copy(this.origin).addScaledVector(this.direction, n);
        }
        distanceToPoint(t) {
          return Math.sqrt(this.distanceSqToPoint(t));
        }
        distanceSqToPoint(t) {
          const e = Je.subVectors(t, this.origin).dot(this.direction);
          return e < 0
            ? this.origin.distanceToSquared(t)
            : (Je.copy(this.origin).addScaledVector(this.direction, e),
              Je.distanceToSquared(t));
        }
        distanceSqToSegment(t, e, n, r) {
          Yr.copy(t).add(e).multiplyScalar(0.5),
            ji.copy(e).sub(t).normalize(),
            fn.copy(this.origin).sub(Yr);
          const s = t.distanceTo(e) * 0.5,
            a = -this.direction.dot(ji),
            o = fn.dot(this.direction),
            l = -fn.dot(ji),
            c = fn.lengthSq(),
            h = Math.abs(1 - a * a);
          let f, p, m, v;
          if (h > 0)
            if (((f = a * l - o), (p = a * o - l), (v = s * h), f >= 0))
              if (p >= -v)
                if (p <= v) {
                  const M = 1 / h;
                  (f *= M),
                    (p *= M),
                    (m = f * (f + a * p + 2 * o) + p * (a * f + p + 2 * l) + c);
                } else
                  (p = s),
                    (f = Math.max(0, -(a * p + o))),
                    (m = -f * f + p * (p + 2 * l) + c);
              else
                (p = -s),
                  (f = Math.max(0, -(a * p + o))),
                  (m = -f * f + p * (p + 2 * l) + c);
            else
              p <= -v
                ? ((f = Math.max(0, -(-a * s + o))),
                  (p = f > 0 ? -s : Math.min(Math.max(-s, -l), s)),
                  (m = -f * f + p * (p + 2 * l) + c))
                : p <= v
                ? ((f = 0),
                  (p = Math.min(Math.max(-s, -l), s)),
                  (m = p * (p + 2 * l) + c))
                : ((f = Math.max(0, -(a * s + o))),
                  (p = f > 0 ? s : Math.min(Math.max(-s, -l), s)),
                  (m = -f * f + p * (p + 2 * l) + c));
          else
            (p = a > 0 ? -s : s),
              (f = Math.max(0, -(a * p + o))),
              (m = -f * f + p * (p + 2 * l) + c);
          return (
            n && n.copy(this.origin).addScaledVector(this.direction, f),
            r && r.copy(Yr).addScaledVector(ji, p),
            m
          );
        }
        intersectSphere(t, e) {
          Je.subVectors(t.center, this.origin);
          const n = Je.dot(this.direction),
            r = Je.dot(Je) - n * n,
            s = t.radius * t.radius;
          if (r > s) return null;
          const a = Math.sqrt(s - r),
            o = n - a,
            l = n + a;
          return l < 0 ? null : o < 0 ? this.at(l, e) : this.at(o, e);
        }
        intersectsSphere(t) {
          return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
        }
        distanceToPlane(t) {
          const e = t.normal.dot(this.direction);
          if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
          const n = -(this.origin.dot(t.normal) + t.constant) / e;
          return n >= 0 ? n : null;
        }
        intersectPlane(t, e) {
          const n = this.distanceToPlane(t);
          return n === null ? null : this.at(n, e);
        }
        intersectsPlane(t) {
          const e = t.distanceToPoint(this.origin);
          return e === 0 || t.normal.dot(this.direction) * e < 0;
        }
        intersectBox(t, e) {
          let n, r, s, a, o, l;
          const c = 1 / this.direction.x,
            h = 1 / this.direction.y,
            f = 1 / this.direction.z,
            p = this.origin;
          return (
            c >= 0
              ? ((n = (t.min.x - p.x) * c), (r = (t.max.x - p.x) * c))
              : ((n = (t.max.x - p.x) * c), (r = (t.min.x - p.x) * c)),
            h >= 0
              ? ((s = (t.min.y - p.y) * h), (a = (t.max.y - p.y) * h))
              : ((s = (t.max.y - p.y) * h), (a = (t.min.y - p.y) * h)),
            n > a ||
            s > r ||
            ((s > n || isNaN(n)) && (n = s),
            (a < r || isNaN(r)) && (r = a),
            f >= 0
              ? ((o = (t.min.z - p.z) * f), (l = (t.max.z - p.z) * f))
              : ((o = (t.max.z - p.z) * f), (l = (t.min.z - p.z) * f)),
            n > l || o > r) ||
            ((o > n || n !== n) && (n = o),
            (l < r || r !== r) && (r = l),
            r < 0)
              ? null
              : this.at(n >= 0 ? n : r, e)
          );
        }
        intersectsBox(t) {
          return this.intersectBox(t, Je) !== null;
        }
        intersectTriangle(t, e, n, r, s) {
          qr.subVectors(e, t), Zi.subVectors(n, t), Kr.crossVectors(qr, Zi);
          let a = this.direction.dot(Kr),
            o;
          if (a > 0) {
            if (r) return null;
            o = 1;
          } else if (a < 0) (o = -1), (a = -a);
          else return null;
          fn.subVectors(this.origin, t);
          const l = o * this.direction.dot(Zi.crossVectors(fn, Zi));
          if (l < 0) return null;
          const c = o * this.direction.dot(qr.cross(fn));
          if (c < 0 || l + c > a) return null;
          const h = -o * fn.dot(Kr);
          return h < 0 ? null : this.at(h / a, s);
        }
        applyMatrix4(t) {
          return (
            this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
          );
        }
        equals(t) {
          return (
            t.origin.equals(this.origin) && t.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class ee {
        constructor(t, e, n, r, s, a, o, l, c, h, f, p, m, v, M, u) {
          (ee.prototype.isMatrix4 = !0),
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            t !== void 0 &&
              this.set(t, e, n, r, s, a, o, l, c, h, f, p, m, v, M, u);
        }
        set(t, e, n, r, s, a, o, l, c, h, f, p, m, v, M, u) {
          const d = this.elements;
          return (
            (d[0] = t),
            (d[4] = e),
            (d[8] = n),
            (d[12] = r),
            (d[1] = s),
            (d[5] = a),
            (d[9] = o),
            (d[13] = l),
            (d[2] = c),
            (d[6] = h),
            (d[10] = f),
            (d[14] = p),
            (d[3] = m),
            (d[7] = v),
            (d[11] = M),
            (d[15] = u),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new ee().fromArray(this.elements);
        }
        copy(t) {
          const e = this.elements,
            n = t.elements;
          return (
            (e[0] = n[0]),
            (e[1] = n[1]),
            (e[2] = n[2]),
            (e[3] = n[3]),
            (e[4] = n[4]),
            (e[5] = n[5]),
            (e[6] = n[6]),
            (e[7] = n[7]),
            (e[8] = n[8]),
            (e[9] = n[9]),
            (e[10] = n[10]),
            (e[11] = n[11]),
            (e[12] = n[12]),
            (e[13] = n[13]),
            (e[14] = n[14]),
            (e[15] = n[15]),
            this
          );
        }
        copyPosition(t) {
          const e = this.elements,
            n = t.elements;
          return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
        }
        setFromMatrix3(t) {
          const e = t.elements;
          return (
            this.set(
              e[0],
              e[3],
              e[6],
              0,
              e[1],
              e[4],
              e[7],
              0,
              e[2],
              e[5],
              e[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(t, e, n) {
          return (
            t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(t, e, n) {
          return (
            this.set(
              t.x,
              e.x,
              n.x,
              0,
              t.y,
              e.y,
              n.y,
              0,
              t.z,
              e.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(t) {
          const e = this.elements,
            n = t.elements,
            r = 1 / Zn.setFromMatrixColumn(t, 0).length(),
            s = 1 / Zn.setFromMatrixColumn(t, 1).length(),
            a = 1 / Zn.setFromMatrixColumn(t, 2).length();
          return (
            (e[0] = n[0] * r),
            (e[1] = n[1] * r),
            (e[2] = n[2] * r),
            (e[3] = 0),
            (e[4] = n[4] * s),
            (e[5] = n[5] * s),
            (e[6] = n[6] * s),
            (e[7] = 0),
            (e[8] = n[8] * a),
            (e[9] = n[9] * a),
            (e[10] = n[10] * a),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        }
        makeRotationFromEuler(t) {
          const e = this.elements,
            n = t.x,
            r = t.y,
            s = t.z,
            a = Math.cos(n),
            o = Math.sin(n),
            l = Math.cos(r),
            c = Math.sin(r),
            h = Math.cos(s),
            f = Math.sin(s);
          if (t.order === "XYZ") {
            const p = a * h,
              m = a * f,
              v = o * h,
              M = o * f;
            (e[0] = l * h),
              (e[4] = -l * f),
              (e[8] = c),
              (e[1] = m + v * c),
              (e[5] = p - M * c),
              (e[9] = -o * l),
              (e[2] = M - p * c),
              (e[6] = v + m * c),
              (e[10] = a * l);
          } else if (t.order === "YXZ") {
            const p = l * h,
              m = l * f,
              v = c * h,
              M = c * f;
            (e[0] = p + M * o),
              (e[4] = v * o - m),
              (e[8] = a * c),
              (e[1] = a * f),
              (e[5] = a * h),
              (e[9] = -o),
              (e[2] = m * o - v),
              (e[6] = M + p * o),
              (e[10] = a * l);
          } else if (t.order === "ZXY") {
            const p = l * h,
              m = l * f,
              v = c * h,
              M = c * f;
            (e[0] = p - M * o),
              (e[4] = -a * f),
              (e[8] = v + m * o),
              (e[1] = m + v * o),
              (e[5] = a * h),
              (e[9] = M - p * o),
              (e[2] = -a * c),
              (e[6] = o),
              (e[10] = a * l);
          } else if (t.order === "ZYX") {
            const p = a * h,
              m = a * f,
              v = o * h,
              M = o * f;
            (e[0] = l * h),
              (e[4] = v * c - m),
              (e[8] = p * c + M),
              (e[1] = l * f),
              (e[5] = M * c + p),
              (e[9] = m * c - v),
              (e[2] = -c),
              (e[6] = o * l),
              (e[10] = a * l);
          } else if (t.order === "YZX") {
            const p = a * l,
              m = a * c,
              v = o * l,
              M = o * c;
            (e[0] = l * h),
              (e[4] = M - p * f),
              (e[8] = v * f + m),
              (e[1] = f),
              (e[5] = a * h),
              (e[9] = -o * h),
              (e[2] = -c * h),
              (e[6] = m * f + v),
              (e[10] = p - M * f);
          } else if (t.order === "XZY") {
            const p = a * l,
              m = a * c,
              v = o * l,
              M = o * c;
            (e[0] = l * h),
              (e[4] = -f),
              (e[8] = c * h),
              (e[1] = p * f + M),
              (e[5] = a * h),
              (e[9] = m * f - v),
              (e[2] = v * f - m),
              (e[6] = o * h),
              (e[10] = M * f + p);
          }
          return (
            (e[3] = 0),
            (e[7] = 0),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(t) {
          return this.compose(Wc, t, Xc);
        }
        lookAt(t, e, n) {
          const r = this.elements;
          return (
            Re.subVectors(t, e),
            Re.lengthSq() === 0 && (Re.z = 1),
            Re.normalize(),
            pn.crossVectors(n, Re),
            pn.lengthSq() === 0 &&
              (Math.abs(n.z) === 1 ? (Re.x += 1e-4) : (Re.z += 1e-4),
              Re.normalize(),
              pn.crossVectors(n, Re)),
            pn.normalize(),
            $i.crossVectors(Re, pn),
            (r[0] = pn.x),
            (r[4] = $i.x),
            (r[8] = Re.x),
            (r[1] = pn.y),
            (r[5] = $i.y),
            (r[9] = Re.y),
            (r[2] = pn.z),
            (r[6] = $i.z),
            (r[10] = Re.z),
            this
          );
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const n = t.elements,
            r = e.elements,
            s = this.elements,
            a = n[0],
            o = n[4],
            l = n[8],
            c = n[12],
            h = n[1],
            f = n[5],
            p = n[9],
            m = n[13],
            v = n[2],
            M = n[6],
            u = n[10],
            d = n[14],
            T = n[3],
            E = n[7],
            A = n[11],
            O = n[15],
            P = r[0],
            b = r[4],
            F = r[8],
            tt = r[12],
            _ = r[1],
            S = r[5],
            V = r[9],
            z = r[13],
            Y = r[2],
            j = r[6],
            G = r[10],
            K = r[14],
            H = r[3],
            ot = r[7],
            lt = r[11],
            _t = r[15];
          return (
            (s[0] = a * P + o * _ + l * Y + c * H),
            (s[4] = a * b + o * S + l * j + c * ot),
            (s[8] = a * F + o * V + l * G + c * lt),
            (s[12] = a * tt + o * z + l * K + c * _t),
            (s[1] = h * P + f * _ + p * Y + m * H),
            (s[5] = h * b + f * S + p * j + m * ot),
            (s[9] = h * F + f * V + p * G + m * lt),
            (s[13] = h * tt + f * z + p * K + m * _t),
            (s[2] = v * P + M * _ + u * Y + d * H),
            (s[6] = v * b + M * S + u * j + d * ot),
            (s[10] = v * F + M * V + u * G + d * lt),
            (s[14] = v * tt + M * z + u * K + d * _t),
            (s[3] = T * P + E * _ + A * Y + O * H),
            (s[7] = T * b + E * S + A * j + O * ot),
            (s[11] = T * F + E * V + A * G + O * lt),
            (s[15] = T * tt + E * z + A * K + O * _t),
            this
          );
        }
        multiplyScalar(t) {
          const e = this.elements;
          return (
            (e[0] *= t),
            (e[4] *= t),
            (e[8] *= t),
            (e[12] *= t),
            (e[1] *= t),
            (e[5] *= t),
            (e[9] *= t),
            (e[13] *= t),
            (e[2] *= t),
            (e[6] *= t),
            (e[10] *= t),
            (e[14] *= t),
            (e[3] *= t),
            (e[7] *= t),
            (e[11] *= t),
            (e[15] *= t),
            this
          );
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            n = t[4],
            r = t[8],
            s = t[12],
            a = t[1],
            o = t[5],
            l = t[9],
            c = t[13],
            h = t[2],
            f = t[6],
            p = t[10],
            m = t[14],
            v = t[3],
            M = t[7],
            u = t[11],
            d = t[15];
          return (
            v *
              (+s * l * f -
                r * c * f -
                s * o * p +
                n * c * p +
                r * o * m -
                n * l * m) +
            M *
              (+e * l * m -
                e * c * p +
                s * a * p -
                r * a * m +
                r * c * h -
                s * l * h) +
            u *
              (+e * c * f -
                e * o * m -
                s * a * f +
                n * a * m +
                s * o * h -
                n * c * h) +
            d *
              (-r * o * h -
                e * l * f +
                e * o * p +
                r * a * f -
                n * a * p +
                n * l * h)
          );
        }
        transpose() {
          const t = this.elements;
          let e;
          return (
            (e = t[1]),
            (t[1] = t[4]),
            (t[4] = e),
            (e = t[2]),
            (t[2] = t[8]),
            (t[8] = e),
            (e = t[6]),
            (t[6] = t[9]),
            (t[9] = e),
            (e = t[3]),
            (t[3] = t[12]),
            (t[12] = e),
            (e = t[7]),
            (t[7] = t[13]),
            (t[13] = e),
            (e = t[11]),
            (t[11] = t[14]),
            (t[14] = e),
            this
          );
        }
        setPosition(t, e, n) {
          const r = this.elements;
          return (
            t.isVector3
              ? ((r[12] = t.x), (r[13] = t.y), (r[14] = t.z))
              : ((r[12] = t), (r[13] = e), (r[14] = n)),
            this
          );
        }
        invert() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            r = t[2],
            s = t[3],
            a = t[4],
            o = t[5],
            l = t[6],
            c = t[7],
            h = t[8],
            f = t[9],
            p = t[10],
            m = t[11],
            v = t[12],
            M = t[13],
            u = t[14],
            d = t[15],
            T =
              f * u * c -
              M * p * c +
              M * l * m -
              o * u * m -
              f * l * d +
              o * p * d,
            E =
              v * p * c -
              h * u * c -
              v * l * m +
              a * u * m +
              h * l * d -
              a * p * d,
            A =
              h * M * c -
              v * f * c +
              v * o * m -
              a * M * m -
              h * o * d +
              a * f * d,
            O =
              v * f * l -
              h * M * l -
              v * o * p +
              a * M * p +
              h * o * u -
              a * f * u,
            P = e * T + n * E + r * A + s * O;
          if (P === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const b = 1 / P;
          return (
            (t[0] = T * b),
            (t[1] =
              (M * p * s -
                f * u * s -
                M * r * m +
                n * u * m +
                f * r * d -
                n * p * d) *
              b),
            (t[2] =
              (o * u * s -
                M * l * s +
                M * r * c -
                n * u * c -
                o * r * d +
                n * l * d) *
              b),
            (t[3] =
              (f * l * s -
                o * p * s -
                f * r * c +
                n * p * c +
                o * r * m -
                n * l * m) *
              b),
            (t[4] = E * b),
            (t[5] =
              (h * u * s -
                v * p * s +
                v * r * m -
                e * u * m -
                h * r * d +
                e * p * d) *
              b),
            (t[6] =
              (v * l * s -
                a * u * s -
                v * r * c +
                e * u * c +
                a * r * d -
                e * l * d) *
              b),
            (t[7] =
              (a * p * s -
                h * l * s +
                h * r * c -
                e * p * c -
                a * r * m +
                e * l * m) *
              b),
            (t[8] = A * b),
            (t[9] =
              (v * f * s -
                h * M * s -
                v * n * m +
                e * M * m +
                h * n * d -
                e * f * d) *
              b),
            (t[10] =
              (a * M * s -
                v * o * s +
                v * n * c -
                e * M * c -
                a * n * d +
                e * o * d) *
              b),
            (t[11] =
              (h * o * s -
                a * f * s -
                h * n * c +
                e * f * c +
                a * n * m -
                e * o * m) *
              b),
            (t[12] = O * b),
            (t[13] =
              (h * M * r -
                v * f * r +
                v * n * p -
                e * M * p -
                h * n * u +
                e * f * u) *
              b),
            (t[14] =
              (v * o * r -
                a * M * r -
                v * n * l +
                e * M * l +
                a * n * u -
                e * o * u) *
              b),
            (t[15] =
              (a * f * r -
                h * o * r +
                h * n * l -
                e * f * l -
                a * n * p +
                e * o * p) *
              b),
            this
          );
        }
        scale(t) {
          const e = this.elements,
            n = t.x,
            r = t.y,
            s = t.z;
          return (
            (e[0] *= n),
            (e[4] *= r),
            (e[8] *= s),
            (e[1] *= n),
            (e[5] *= r),
            (e[9] *= s),
            (e[2] *= n),
            (e[6] *= r),
            (e[10] *= s),
            (e[3] *= n),
            (e[7] *= r),
            (e[11] *= s),
            this
          );
        }
        getMaxScaleOnAxis() {
          const t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
          return Math.sqrt(Math.max(e, n, r));
        }
        makeTranslation(t, e, n) {
          return (
            t.isVector3
              ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
              : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
            this
          );
        }
        makeRotationX(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(t, e) {
          const n = Math.cos(e),
            r = Math.sin(e),
            s = 1 - n,
            a = t.x,
            o = t.y,
            l = t.z,
            c = s * a,
            h = s * o;
          return (
            this.set(
              c * a + n,
              c * o - r * l,
              c * l + r * o,
              0,
              c * o + r * l,
              h * o + n,
              h * l - r * a,
              0,
              c * l - r * o,
              h * l + r * a,
              s * l * l + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(t, e, n) {
          return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(t, e, n, r, s, a) {
          return this.set(1, n, s, 0, t, 1, a, 0, e, r, 1, 0, 0, 0, 0, 1), this;
        }
        compose(t, e, n) {
          const r = this.elements,
            s = e._x,
            a = e._y,
            o = e._z,
            l = e._w,
            c = s + s,
            h = a + a,
            f = o + o,
            p = s * c,
            m = s * h,
            v = s * f,
            M = a * h,
            u = a * f,
            d = o * f,
            T = l * c,
            E = l * h,
            A = l * f,
            O = n.x,
            P = n.y,
            b = n.z;
          return (
            (r[0] = (1 - (M + d)) * O),
            (r[1] = (m + A) * O),
            (r[2] = (v - E) * O),
            (r[3] = 0),
            (r[4] = (m - A) * P),
            (r[5] = (1 - (p + d)) * P),
            (r[6] = (u + T) * P),
            (r[7] = 0),
            (r[8] = (v + E) * b),
            (r[9] = (u - T) * b),
            (r[10] = (1 - (p + M)) * b),
            (r[11] = 0),
            (r[12] = t.x),
            (r[13] = t.y),
            (r[14] = t.z),
            (r[15] = 1),
            this
          );
        }
        decompose(t, e, n) {
          const r = this.elements;
          let s = Zn.set(r[0], r[1], r[2]).length();
          const a = Zn.set(r[4], r[5], r[6]).length(),
            o = Zn.set(r[8], r[9], r[10]).length();
          this.determinant() < 0 && (s = -s),
            (t.x = r[12]),
            (t.y = r[13]),
            (t.z = r[14]),
            ze.copy(this);
          const c = 1 / s,
            h = 1 / a,
            f = 1 / o;
          return (
            (ze.elements[0] *= c),
            (ze.elements[1] *= c),
            (ze.elements[2] *= c),
            (ze.elements[4] *= h),
            (ze.elements[5] *= h),
            (ze.elements[6] *= h),
            (ze.elements[8] *= f),
            (ze.elements[9] *= f),
            (ze.elements[10] *= f),
            e.setFromRotationMatrix(ze),
            (n.x = s),
            (n.y = a),
            (n.z = o),
            this
          );
        }
        makePerspective(t, e, n, r, s, a, o = on) {
          const l = this.elements,
            c = (2 * s) / (e - t),
            h = (2 * s) / (n - r),
            f = (e + t) / (e - t),
            p = (n + r) / (n - r);
          let m, v;
          if (o === on) (m = -(a + s) / (a - s)), (v = (-2 * a * s) / (a - s));
          else if (o === br) (m = -a / (a - s)), (v = (-a * s) / (a - s));
          else
            throw new Error(
              "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o
            );
          return (
            (l[0] = c),
            (l[4] = 0),
            (l[8] = f),
            (l[12] = 0),
            (l[1] = 0),
            (l[5] = h),
            (l[9] = p),
            (l[13] = 0),
            (l[2] = 0),
            (l[6] = 0),
            (l[10] = m),
            (l[14] = v),
            (l[3] = 0),
            (l[7] = 0),
            (l[11] = -1),
            (l[15] = 0),
            this
          );
        }
        makeOrthographic(t, e, n, r, s, a, o = on) {
          const l = this.elements,
            c = 1 / (e - t),
            h = 1 / (n - r),
            f = 1 / (a - s),
            p = (e + t) * c,
            m = (n + r) * h;
          let v, M;
          if (o === on) (v = (a + s) * f), (M = -2 * f);
          else if (o === br) (v = s * f), (M = -1 * f);
          else
            throw new Error(
              "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " +
                o
            );
          return (
            (l[0] = 2 * c),
            (l[4] = 0),
            (l[8] = 0),
            (l[12] = -p),
            (l[1] = 0),
            (l[5] = 2 * h),
            (l[9] = 0),
            (l[13] = -m),
            (l[2] = 0),
            (l[6] = 0),
            (l[10] = M),
            (l[14] = -v),
            (l[3] = 0),
            (l[7] = 0),
            (l[11] = 0),
            (l[15] = 1),
            this
          );
        }
        equals(t) {
          const e = this.elements,
            n = t.elements;
          for (let r = 0; r < 16; r++) if (e[r] !== n[r]) return !1;
          return !0;
        }
        fromArray(t, e = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const n = this.elements;
          return (
            (t[e] = n[0]),
            (t[e + 1] = n[1]),
            (t[e + 2] = n[2]),
            (t[e + 3] = n[3]),
            (t[e + 4] = n[4]),
            (t[e + 5] = n[5]),
            (t[e + 6] = n[6]),
            (t[e + 7] = n[7]),
            (t[e + 8] = n[8]),
            (t[e + 9] = n[9]),
            (t[e + 10] = n[10]),
            (t[e + 11] = n[11]),
            (t[e + 12] = n[12]),
            (t[e + 13] = n[13]),
            (t[e + 14] = n[14]),
            (t[e + 15] = n[15]),
            t
          );
        }
      }
      const Zn = new D(),
        ze = new ee(),
        Wc = new D(0, 0, 0),
        Xc = new D(1, 1, 1),
        pn = new D(),
        $i = new D(),
        Re = new D(),
        Va = new ee(),
        ka = new Vn();
      class je {
        constructor(t = 0, e = 0, n = 0, r = je.DEFAULT_ORDER) {
          (this.isEuler = !0),
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._order = r);
        }
        get x() {
          return this._x;
        }
        set x(t) {
          (this._x = t), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          (this._y = t), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          (this._z = t), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(t) {
          (this._order = t), this._onChangeCallback();
        }
        set(t, e, n, r = this._order) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._order = r),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(t) {
          return (
            (this._x = t._x),
            (this._y = t._y),
            (this._z = t._z),
            (this._order = t._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(t, e = this._order, n = !0) {
          const r = t.elements,
            s = r[0],
            a = r[4],
            o = r[8],
            l = r[1],
            c = r[5],
            h = r[9],
            f = r[2],
            p = r[6],
            m = r[10];
          switch (e) {
            case "XYZ":
              (this._y = Math.asin(me(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(-h, m)),
                    (this._z = Math.atan2(-a, s)))
                  : ((this._x = Math.atan2(p, c)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-me(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(o, m)), (this._z = Math.atan2(l, c)))
                  : ((this._y = Math.atan2(-f, s)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(me(p, -1, 1))),
                Math.abs(p) < 0.9999999
                  ? ((this._y = Math.atan2(-f, m)),
                    (this._z = Math.atan2(-a, c)))
                  : ((this._y = 0), (this._z = Math.atan2(l, s)));
              break;
            case "ZYX":
              (this._y = Math.asin(-me(f, -1, 1))),
                Math.abs(f) < 0.9999999
                  ? ((this._x = Math.atan2(p, m)), (this._z = Math.atan2(l, s)))
                  : ((this._x = 0), (this._z = Math.atan2(-a, c)));
              break;
            case "YZX":
              (this._z = Math.asin(me(l, -1, 1))),
                Math.abs(l) < 0.9999999
                  ? ((this._x = Math.atan2(-h, c)),
                    (this._y = Math.atan2(-f, s)))
                  : ((this._x = 0), (this._y = Math.atan2(o, m)));
              break;
            case "XZY":
              (this._z = Math.asin(-me(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(p, c)), (this._y = Math.atan2(o, s)))
                  : ((this._x = Math.atan2(-h, m)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  e
              );
          }
          return (this._order = e), n === !0 && this._onChangeCallback(), this;
        }
        setFromQuaternion(t, e, n) {
          return (
            Va.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(Va, e, n)
          );
        }
        setFromVector3(t, e = this._order) {
          return this.set(t.x, t.y, t.z, e);
        }
        reorder(t) {
          return ka.setFromEuler(this), this.setFromQuaternion(ka, t);
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._order === this._order
          );
        }
        fromArray(t) {
          return (
            (this._x = t[0]),
            (this._y = t[1]),
            (this._z = t[2]),
            t[3] !== void 0 && (this._order = t[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._order),
            t
          );
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      }
      je.DEFAULT_ORDER = "XYZ";
      class rl {
        constructor() {
          this.mask = 1;
        }
        set(t) {
          this.mask = ((1 << t) | 0) >>> 0;
        }
        enable(t) {
          this.mask |= (1 << t) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(t) {
          this.mask ^= (1 << t) | 0;
        }
        disable(t) {
          this.mask &= ~((1 << t) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(t) {
          return (this.mask & t.mask) !== 0;
        }
        isEnabled(t) {
          return (this.mask & ((1 << t) | 0)) !== 0;
        }
      }
      let Yc = 0;
      const Wa = new D(),
        $n = new Vn(),
        Qe = new ee(),
        Ji = new D(),
        wi = new D(),
        qc = new D(),
        Kc = new Vn(),
        Xa = new D(1, 0, 0),
        Ya = new D(0, 1, 0),
        qa = new D(0, 0, 1),
        Ka = { type: "added" },
        jc = { type: "removed" },
        Jn = { type: "childadded", child: null },
        jr = { type: "childremoved", child: null };
      class ue extends kn {
        constructor() {
          super(),
            (this.isObject3D = !0),
            Object.defineProperty(this, "id", { value: Yc++ }),
            (this.uuid = Mi()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = ue.DEFAULT_UP.clone());
          const t = new D(),
            e = new je(),
            n = new Vn(),
            r = new D(1, 1, 1);
          function s() {
            n.setFromEuler(e, !1);
          }
          function a() {
            e.setFromQuaternion(n, void 0, !1);
          }
          e._onChange(s),
            n._onChange(a),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: t },
              rotation: { configurable: !0, enumerable: !0, value: e },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: r },
              modelViewMatrix: { value: new ee() },
              normalMatrix: { value: new Dt() },
            }),
            (this.matrix = new ee()),
            (this.matrixWorld = new ee()),
            (this.matrixAutoUpdate = ue.DEFAULT_MATRIX_AUTO_UPDATE),
            (this.matrixWorldAutoUpdate = ue.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new rl()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeShadow() {}
        onAfterShadow() {}
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(t) {
          return this.quaternion.premultiply(t), this;
        }
        setRotationFromAxisAngle(t, e) {
          this.quaternion.setFromAxisAngle(t, e);
        }
        setRotationFromEuler(t) {
          this.quaternion.setFromEuler(t, !0);
        }
        setRotationFromMatrix(t) {
          this.quaternion.setFromRotationMatrix(t);
        }
        setRotationFromQuaternion(t) {
          this.quaternion.copy(t);
        }
        rotateOnAxis(t, e) {
          return $n.setFromAxisAngle(t, e), this.quaternion.multiply($n), this;
        }
        rotateOnWorldAxis(t, e) {
          return (
            $n.setFromAxisAngle(t, e), this.quaternion.premultiply($n), this
          );
        }
        rotateX(t) {
          return this.rotateOnAxis(Xa, t);
        }
        rotateY(t) {
          return this.rotateOnAxis(Ya, t);
        }
        rotateZ(t) {
          return this.rotateOnAxis(qa, t);
        }
        translateOnAxis(t, e) {
          return (
            Wa.copy(t).applyQuaternion(this.quaternion),
            this.position.add(Wa.multiplyScalar(e)),
            this
          );
        }
        translateX(t) {
          return this.translateOnAxis(Xa, t);
        }
        translateY(t) {
          return this.translateOnAxis(Ya, t);
        }
        translateZ(t) {
          return this.translateOnAxis(qa, t);
        }
        localToWorld(t) {
          return (
            this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
          );
        }
        worldToLocal(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            t.applyMatrix4(Qe.copy(this.matrixWorld).invert())
          );
        }
        lookAt(t, e, n) {
          t.isVector3 ? Ji.copy(t) : Ji.set(t, e, n);
          const r = this.parent;
          this.updateWorldMatrix(!0, !1),
            wi.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? Qe.lookAt(wi, Ji, this.up)
              : Qe.lookAt(Ji, wi, this.up),
            this.quaternion.setFromRotationMatrix(Qe),
            r &&
              (Qe.extractRotation(r.matrixWorld),
              $n.setFromRotationMatrix(Qe),
              this.quaternion.premultiply($n.invert()));
        }
        add(t) {
          if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
            return this;
          }
          return t === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                t
              ),
              this)
            : (t && t.isObject3D
                ? (t.removeFromParent(),
                  (t.parent = this),
                  this.children.push(t),
                  t.dispatchEvent(Ka),
                  (Jn.child = t),
                  this.dispatchEvent(Jn),
                  (Jn.child = null))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    t
                  ),
              this);
        }
        remove(t) {
          if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
              this.remove(arguments[n]);
            return this;
          }
          const e = this.children.indexOf(t);
          return (
            e !== -1 &&
              ((t.parent = null),
              this.children.splice(e, 1),
              t.dispatchEvent(jc),
              (jr.child = t),
              this.dispatchEvent(jr),
              (jr.child = null)),
            this
          );
        }
        removeFromParent() {
          const t = this.parent;
          return t !== null && t.remove(this), this;
        }
        clear() {
          return this.remove(...this.children);
        }
        attach(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            Qe.copy(this.matrixWorld).invert(),
            t.parent !== null &&
              (t.parent.updateWorldMatrix(!0, !1),
              Qe.multiply(t.parent.matrixWorld)),
            t.applyMatrix4(Qe),
            t.removeFromParent(),
            (t.parent = this),
            this.children.push(t),
            t.updateWorldMatrix(!1, !0),
            t.dispatchEvent(Ka),
            (Jn.child = t),
            this.dispatchEvent(Jn),
            (Jn.child = null),
            this
          );
        }
        getObjectById(t) {
          return this.getObjectByProperty("id", t);
        }
        getObjectByName(t) {
          return this.getObjectByProperty("name", t);
        }
        getObjectByProperty(t, e) {
          if (this[t] === e) return this;
          for (let n = 0, r = this.children.length; n < r; n++) {
            const a = this.children[n].getObjectByProperty(t, e);
            if (a !== void 0) return a;
          }
        }
        getObjectsByProperty(t, e, n = []) {
          this[t] === e && n.push(this);
          const r = this.children;
          for (let s = 0, a = r.length; s < a; s++)
            r[s].getObjectsByProperty(t, e, n);
          return n;
        }
        getWorldPosition(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            t.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(wi, t, qc),
            t
          );
        }
        getWorldScale(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(wi, Kc, t),
            t
          );
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(!0, !1);
          const e = this.matrixWorld.elements;
          return t.set(e[8], e[9], e[10]).normalize();
        }
        raycast() {}
        traverse(t) {
          t(this);
          const e = this.children;
          for (let n = 0, r = e.length; n < r; n++) e[n].traverse(t);
        }
        traverseVisible(t) {
          if (this.visible === !1) return;
          t(this);
          const e = this.children;
          for (let n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t);
        }
        traverseAncestors(t) {
          const e = this.parent;
          e !== null && (t(e), e.traverseAncestors(t));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) &&
              (this.matrixWorldAutoUpdate === !0 &&
                (this.parent === null
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix
                    )),
              (this.matrixWorldNeedsUpdate = !1),
              (t = !0));
          const e = this.children;
          for (let n = 0, r = e.length; n < r; n++) e[n].updateMatrixWorld(t);
        }
        updateWorldMatrix(t, e) {
          const n = this.parent;
          if (
            (t === !0 && n !== null && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrixWorldAutoUpdate === !0 &&
              (this.parent === null
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  )),
            e === !0)
          ) {
            const r = this.children;
            for (let s = 0, a = r.length; s < a; s++)
              r[s].updateWorldMatrix(!1, !0);
          }
        }
        toJSON(t) {
          const e = t === void 0 || typeof t == "string",
            n = {};
          e &&
            ((t = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {},
            }),
            (n.metadata = {
              version: 4.6,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const r = {};
          (r.uuid = this.uuid),
            (r.type = this.type),
            this.name !== "" && (r.name = this.name),
            this.castShadow === !0 && (r.castShadow = !0),
            this.receiveShadow === !0 && (r.receiveShadow = !0),
            this.visible === !1 && (r.visible = !1),
            this.frustumCulled === !1 && (r.frustumCulled = !1),
            this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
            Object.keys(this.userData).length > 0 &&
              (r.userData = this.userData),
            (r.layers = this.layers.mask),
            (r.matrix = this.matrix.toArray()),
            (r.up = this.up.toArray()),
            this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((r.type = "InstancedMesh"),
              (r.count = this.count),
              (r.instanceMatrix = this.instanceMatrix.toJSON()),
              this.instanceColor !== null &&
                (r.instanceColor = this.instanceColor.toJSON())),
            this.isBatchedMesh &&
              ((r.type = "BatchedMesh"),
              (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
              (r.sortObjects = this.sortObjects),
              (r.drawRanges = this._drawRanges),
              (r.reservedRanges = this._reservedRanges),
              (r.visibility = this._visibility),
              (r.active = this._active),
              (r.bounds = this._bounds.map((o) => ({
                boxInitialized: o.boxInitialized,
                boxMin: o.box.min.toArray(),
                boxMax: o.box.max.toArray(),
                sphereInitialized: o.sphereInitialized,
                sphereRadius: o.sphere.radius,
                sphereCenter: o.sphere.center.toArray(),
              }))),
              (r.maxInstanceCount = this._maxInstanceCount),
              (r.maxVertexCount = this._maxVertexCount),
              (r.maxIndexCount = this._maxIndexCount),
              (r.geometryInitialized = this._geometryInitialized),
              (r.geometryCount = this._geometryCount),
              (r.matricesTexture = this._matricesTexture.toJSON(t)),
              this._colorsTexture !== null &&
                (r.colorsTexture = this._colorsTexture.toJSON(t)),
              this.boundingSphere !== null &&
                (r.boundingSphere = {
                  center: r.boundingSphere.center.toArray(),
                  radius: r.boundingSphere.radius,
                }),
              this.boundingBox !== null &&
                (r.boundingBox = {
                  min: r.boundingBox.min.toArray(),
                  max: r.boundingBox.max.toArray(),
                }));
          function s(o, l) {
            return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(t)), l.uuid;
          }
          if (this.isScene)
            this.background &&
              (this.background.isColor
                ? (r.background = this.background.toJSON())
                : this.background.isTexture &&
                  (r.background = this.background.toJSON(t).uuid)),
              this.environment &&
                this.environment.isTexture &&
                this.environment.isRenderTargetTexture !== !0 &&
                (r.environment = this.environment.toJSON(t).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(t.geometries, this.geometry);
            const o = this.geometry.parameters;
            if (o !== void 0 && o.shapes !== void 0) {
              const l = o.shapes;
              if (Array.isArray(l))
                for (let c = 0, h = l.length; c < h; c++) {
                  const f = l[c];
                  s(t.shapes, f);
                }
              else s(t.shapes, l);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((r.bindMode = this.bindMode),
              (r.bindMatrix = this.bindMatrix.toArray()),
              this.skeleton !== void 0 &&
                (s(t.skeletons, this.skeleton),
                (r.skeleton = this.skeleton.uuid))),
            this.material !== void 0)
          )
            if (Array.isArray(this.material)) {
              const o = [];
              for (let l = 0, c = this.material.length; l < c; l++)
                o.push(s(t.materials, this.material[l]));
              r.material = o;
            } else r.material = s(t.materials, this.material);
          if (this.children.length > 0) {
            r.children = [];
            for (let o = 0; o < this.children.length; o++)
              r.children.push(this.children[o].toJSON(t).object);
          }
          if (this.animations.length > 0) {
            r.animations = [];
            for (let o = 0; o < this.animations.length; o++) {
              const l = this.animations[o];
              r.animations.push(s(t.animations, l));
            }
          }
          if (e) {
            const o = a(t.geometries),
              l = a(t.materials),
              c = a(t.textures),
              h = a(t.images),
              f = a(t.shapes),
              p = a(t.skeletons),
              m = a(t.animations),
              v = a(t.nodes);
            o.length > 0 && (n.geometries = o),
              l.length > 0 && (n.materials = l),
              c.length > 0 && (n.textures = c),
              h.length > 0 && (n.images = h),
              f.length > 0 && (n.shapes = f),
              p.length > 0 && (n.skeletons = p),
              m.length > 0 && (n.animations = m),
              v.length > 0 && (n.nodes = v);
          }
          return (n.object = r), n;
          function a(o) {
            const l = [];
            for (const c in o) {
              const h = o[c];
              delete h.metadata, l.push(h);
            }
            return l;
          }
        }
        clone(t) {
          return new this.constructor().copy(this, t);
        }
        copy(t, e = !0) {
          if (
            ((this.name = t.name),
            this.up.copy(t.up),
            this.position.copy(t.position),
            (this.rotation.order = t.rotation.order),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
            (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
            (this.layers.mask = t.layers.mask),
            (this.visible = t.visible),
            (this.castShadow = t.castShadow),
            (this.receiveShadow = t.receiveShadow),
            (this.frustumCulled = t.frustumCulled),
            (this.renderOrder = t.renderOrder),
            (this.animations = t.animations.slice()),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            e === !0)
          )
            for (let n = 0; n < t.children.length; n++) {
              const r = t.children[n];
              this.add(r.clone());
            }
          return this;
        }
      }
      ue.DEFAULT_UP = new D(0, 1, 0);
      ue.DEFAULT_MATRIX_AUTO_UPDATE = !0;
      ue.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
      const He = new D(),
        tn = new D(),
        Zr = new D(),
        en = new D(),
        Qn = new D(),
        ti = new D(),
        ja = new D(),
        $r = new D(),
        Jr = new D(),
        Qr = new D(),
        ts = new Zt(),
        es = new Zt(),
        ns = new Zt();
      class We {
        constructor(t = new D(), e = new D(), n = new D()) {
          (this.a = t), (this.b = e), (this.c = n);
        }
        static getNormal(t, e, n, r) {
          r.subVectors(n, e), He.subVectors(t, e), r.cross(He);
          const s = r.lengthSq();
          return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
        }
        static getBarycoord(t, e, n, r, s) {
          He.subVectors(r, e), tn.subVectors(n, e), Zr.subVectors(t, e);
          const a = He.dot(He),
            o = He.dot(tn),
            l = He.dot(Zr),
            c = tn.dot(tn),
            h = tn.dot(Zr),
            f = a * c - o * o;
          if (f === 0) return s.set(0, 0, 0), null;
          const p = 1 / f,
            m = (c * l - o * h) * p,
            v = (a * h - o * l) * p;
          return s.set(1 - m - v, v, m);
        }
        static containsPoint(t, e, n, r) {
          return this.getBarycoord(t, e, n, r, en) === null
            ? !1
            : en.x >= 0 && en.y >= 0 && en.x + en.y <= 1;
        }
        static getInterpolation(t, e, n, r, s, a, o, l) {
          return this.getBarycoord(t, e, n, r, en) === null
            ? ((l.x = 0),
              (l.y = 0),
              "z" in l && (l.z = 0),
              "w" in l && (l.w = 0),
              null)
            : (l.setScalar(0),
              l.addScaledVector(s, en.x),
              l.addScaledVector(a, en.y),
              l.addScaledVector(o, en.z),
              l);
        }
        static getInterpolatedAttribute(t, e, n, r, s, a) {
          return (
            ts.setScalar(0),
            es.setScalar(0),
            ns.setScalar(0),
            ts.fromBufferAttribute(t, e),
            es.fromBufferAttribute(t, n),
            ns.fromBufferAttribute(t, r),
            a.setScalar(0),
            a.addScaledVector(ts, s.x),
            a.addScaledVector(es, s.y),
            a.addScaledVector(ns, s.z),
            a
          );
        }
        static isFrontFacing(t, e, n, r) {
          return (
            He.subVectors(n, e), tn.subVectors(t, e), He.cross(tn).dot(r) < 0
          );
        }
        set(t, e, n) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
        }
        setFromPointsAndIndices(t, e, n, r) {
          return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this;
        }
        setFromAttributeAndIndices(t, e, n, r) {
          return (
            this.a.fromBufferAttribute(t, e),
            this.b.fromBufferAttribute(t, n),
            this.c.fromBufferAttribute(t, r),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        }
        getArea() {
          return (
            He.subVectors(this.c, this.b),
            tn.subVectors(this.a, this.b),
            He.cross(tn).length() * 0.5
          );
        }
        getMidpoint(t) {
          return t
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(t) {
          return We.getNormal(this.a, this.b, this.c, t);
        }
        getPlane(t) {
          return t.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(t, e) {
          return We.getBarycoord(t, this.a, this.b, this.c, e);
        }
        getInterpolation(t, e, n, r, s) {
          return We.getInterpolation(t, this.a, this.b, this.c, e, n, r, s);
        }
        containsPoint(t) {
          return We.containsPoint(t, this.a, this.b, this.c);
        }
        isFrontFacing(t) {
          return We.isFrontFacing(this.a, this.b, this.c, t);
        }
        intersectsBox(t) {
          return t.intersectsTriangle(this);
        }
        closestPointToPoint(t, e) {
          const n = this.a,
            r = this.b,
            s = this.c;
          let a, o;
          Qn.subVectors(r, n), ti.subVectors(s, n), $r.subVectors(t, n);
          const l = Qn.dot($r),
            c = ti.dot($r);
          if (l <= 0 && c <= 0) return e.copy(n);
          Jr.subVectors(t, r);
          const h = Qn.dot(Jr),
            f = ti.dot(Jr);
          if (h >= 0 && f <= h) return e.copy(r);
          const p = l * f - h * c;
          if (p <= 0 && l >= 0 && h <= 0)
            return (a = l / (l - h)), e.copy(n).addScaledVector(Qn, a);
          Qr.subVectors(t, s);
          const m = Qn.dot(Qr),
            v = ti.dot(Qr);
          if (v >= 0 && m <= v) return e.copy(s);
          const M = m * c - l * v;
          if (M <= 0 && c >= 0 && v <= 0)
            return (o = c / (c - v)), e.copy(n).addScaledVector(ti, o);
          const u = h * v - m * f;
          if (u <= 0 && f - h >= 0 && m - v >= 0)
            return (
              ja.subVectors(s, r),
              (o = (f - h) / (f - h + (m - v))),
              e.copy(r).addScaledVector(ja, o)
            );
          const d = 1 / (u + M + p);
          return (
            (a = M * d),
            (o = p * d),
            e.copy(n).addScaledVector(Qn, a).addScaledVector(ti, o)
          );
        }
        equals(t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        }
      }
      const sl = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        mn = { h: 0, s: 0, l: 0 },
        Qi = { h: 0, s: 0, l: 0 };
      function is(i, t, e) {
        return (
          e < 0 && (e += 1),
          e > 1 && (e -= 1),
          e < 1 / 6
            ? i + (t - i) * 6 * e
            : e < 1 / 2
            ? t
            : e < 2 / 3
            ? i + (t - i) * 6 * (2 / 3 - e)
            : i
        );
      }
      class Bt {
        constructor(t, e, n) {
          return (
            (this.isColor = !0),
            (this.r = 1),
            (this.g = 1),
            (this.b = 1),
            this.set(t, e, n)
          );
        }
        set(t, e, n) {
          if (e === void 0 && n === void 0) {
            const r = t;
            r && r.isColor
              ? this.copy(r)
              : typeof r == "number"
              ? this.setHex(r)
              : typeof r == "string" && this.setStyle(r);
          } else this.setRGB(t, e, n);
          return this;
        }
        setScalar(t) {
          return (this.r = t), (this.g = t), (this.b = t), this;
        }
        setHex(t, e = pe) {
          return (
            (t = Math.floor(t)),
            (this.r = ((t >> 16) & 255) / 255),
            (this.g = ((t >> 8) & 255) / 255),
            (this.b = (t & 255) / 255),
            Xt.toWorkingColorSpace(this, e),
            this
          );
        }
        setRGB(t, e, n, r = Xt.workingColorSpace) {
          return (
            (this.r = t),
            (this.g = e),
            (this.b = n),
            Xt.toWorkingColorSpace(this, r),
            this
          );
        }
        setHSL(t, e, n, r = Xt.workingColorSpace) {
          if (((t = fa(t, 1)), (e = me(e, 0, 1)), (n = me(n, 0, 1)), e === 0))
            this.r = this.g = this.b = n;
          else {
            const s = n <= 0.5 ? n * (1 + e) : n + e - n * e,
              a = 2 * n - s;
            (this.r = is(a, s, t + 1 / 3)),
              (this.g = is(a, s, t)),
              (this.b = is(a, s, t - 1 / 3));
          }
          return Xt.toWorkingColorSpace(this, r), this;
        }
        setStyle(t, e = pe) {
          function n(s) {
            s !== void 0 &&
              parseFloat(s) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + t + " will be ignored."
              );
          }
          let r;
          if ((r = /^(\w+)\(([^\)]*)\)/.exec(t))) {
            let s;
            const a = r[1],
              o = r[2];
            switch (a) {
              case "rgb":
              case "rgba":
                if (
                  (s =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                )
                  return (
                    n(s[4]),
                    this.setRGB(
                      Math.min(255, parseInt(s[1], 10)) / 255,
                      Math.min(255, parseInt(s[2], 10)) / 255,
                      Math.min(255, parseInt(s[3], 10)) / 255,
                      e
                    )
                  );
                if (
                  (s =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                )
                  return (
                    n(s[4]),
                    this.setRGB(
                      Math.min(100, parseInt(s[1], 10)) / 100,
                      Math.min(100, parseInt(s[2], 10)) / 100,
                      Math.min(100, parseInt(s[3], 10)) / 100,
                      e
                    )
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (s =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                )
                  return (
                    n(s[4]),
                    this.setHSL(
                      parseFloat(s[1]) / 360,
                      parseFloat(s[2]) / 100,
                      parseFloat(s[3]) / 100,
                      e
                    )
                  );
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + t);
            }
          } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(t))) {
            const s = r[1],
              a = s.length;
            if (a === 3)
              return this.setRGB(
                parseInt(s.charAt(0), 16) / 15,
                parseInt(s.charAt(1), 16) / 15,
                parseInt(s.charAt(2), 16) / 15,
                e
              );
            if (a === 6) return this.setHex(parseInt(s, 16), e);
            console.warn("THREE.Color: Invalid hex color " + t);
          } else if (t && t.length > 0) return this.setColorName(t, e);
          return this;
        }
        setColorName(t, e = pe) {
          const n = sl[t.toLowerCase()];
          return (
            n !== void 0
              ? this.setHex(n, e)
              : console.warn("THREE.Color: Unknown color " + t),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(t) {
          return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
        }
        copySRGBToLinear(t) {
          return (
            (this.r = ui(t.r)), (this.g = ui(t.g)), (this.b = ui(t.b)), this
          );
        }
        copyLinearToSRGB(t) {
          return (
            (this.r = Gr(t.r)), (this.g = Gr(t.g)), (this.b = Gr(t.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(t = pe) {
          return (
            Xt.fromWorkingColorSpace(fe.copy(this), t),
            Math.round(me(fe.r * 255, 0, 255)) * 65536 +
              Math.round(me(fe.g * 255, 0, 255)) * 256 +
              Math.round(me(fe.b * 255, 0, 255))
          );
        }
        getHexString(t = pe) {
          return ("000000" + this.getHex(t).toString(16)).slice(-6);
        }
        getHSL(t, e = Xt.workingColorSpace) {
          Xt.fromWorkingColorSpace(fe.copy(this), e);
          const n = fe.r,
            r = fe.g,
            s = fe.b,
            a = Math.max(n, r, s),
            o = Math.min(n, r, s);
          let l, c;
          const h = (o + a) / 2;
          if (o === a) (l = 0), (c = 0);
          else {
            const f = a - o;
            switch (((c = h <= 0.5 ? f / (a + o) : f / (2 - a - o)), a)) {
              case n:
                l = (r - s) / f + (r < s ? 6 : 0);
                break;
              case r:
                l = (s - n) / f + 2;
                break;
              case s:
                l = (n - r) / f + 4;
                break;
            }
            l /= 6;
          }
          return (t.h = l), (t.s = c), (t.l = h), t;
        }
        getRGB(t, e = Xt.workingColorSpace) {
          return (
            Xt.fromWorkingColorSpace(fe.copy(this), e),
            (t.r = fe.r),
            (t.g = fe.g),
            (t.b = fe.b),
            t
          );
        }
        getStyle(t = pe) {
          Xt.fromWorkingColorSpace(fe.copy(this), t);
          const e = fe.r,
            n = fe.g,
            r = fe.b;
          return t !== pe
            ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})`
            : `rgb(${Math.round(e * 255)},${Math.round(n * 255)},${Math.round(
                r * 255
              )})`;
        }
        offsetHSL(t, e, n) {
          return this.getHSL(mn), this.setHSL(mn.h + t, mn.s + e, mn.l + n);
        }
        add(t) {
          return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
        }
        addColors(t, e) {
          return (
            (this.r = t.r + e.r),
            (this.g = t.g + e.g),
            (this.b = t.b + e.b),
            this
          );
        }
        addScalar(t) {
          return (this.r += t), (this.g += t), (this.b += t), this;
        }
        sub(t) {
          return (
            (this.r = Math.max(0, this.r - t.r)),
            (this.g = Math.max(0, this.g - t.g)),
            (this.b = Math.max(0, this.b - t.b)),
            this
          );
        }
        multiply(t) {
          return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
        }
        multiplyScalar(t) {
          return (this.r *= t), (this.g *= t), (this.b *= t), this;
        }
        lerp(t, e) {
          return (
            (this.r += (t.r - this.r) * e),
            (this.g += (t.g - this.g) * e),
            (this.b += (t.b - this.b) * e),
            this
          );
        }
        lerpColors(t, e, n) {
          return (
            (this.r = t.r + (e.r - t.r) * n),
            (this.g = t.g + (e.g - t.g) * n),
            (this.b = t.b + (e.b - t.b) * n),
            this
          );
        }
        lerpHSL(t, e) {
          this.getHSL(mn), t.getHSL(Qi);
          const n = Ni(mn.h, Qi.h, e),
            r = Ni(mn.s, Qi.s, e),
            s = Ni(mn.l, Qi.l, e);
          return this.setHSL(n, r, s), this;
        }
        setFromVector3(t) {
          return (this.r = t.x), (this.g = t.y), (this.b = t.z), this;
        }
        applyMatrix3(t) {
          const e = this.r,
            n = this.g,
            r = this.b,
            s = t.elements;
          return (
            (this.r = s[0] * e + s[3] * n + s[6] * r),
            (this.g = s[1] * e + s[4] * n + s[7] * r),
            (this.b = s[2] * e + s[5] * n + s[8] * r),
            this
          );
        }
        equals(t) {
          return t.r === this.r && t.g === this.g && t.b === this.b;
        }
        fromArray(t, e = 0) {
          return (
            (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
          );
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
        }
        fromBufferAttribute(t, e) {
          return (
            (this.r = t.getX(e)),
            (this.g = t.getY(e)),
            (this.b = t.getZ(e)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      const fe = new Bt();
      Bt.NAMES = sl;
      let Zc = 0;
      class Si extends kn {
        constructor() {
          super(),
            (this.isMaterial = !0),
            Object.defineProperty(this, "id", { value: Zc++ }),
            (this.uuid = Mi()),
            (this.name = ""),
            (this.type = "Material"),
            (this.blending = ci),
            (this.side = Tn),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.alphaHash = !1),
            (this.blendSrc = vs),
            (this.blendDst = xs),
            (this.blendEquation = Fn),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.blendColor = new Bt(0, 0, 0)),
            (this.blendAlpha = 0),
            (this.depthFunc = pi),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = Ia),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = Xn),
            (this.stencilZFail = Xn),
            (this.stencilZPass = Xn),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.forceSinglePass = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(t) {
          this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
        }
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(t) {
          if (t !== void 0)
            for (const e in t) {
              const n = t[e];
              if (n === void 0) {
                console.warn(
                  `THREE.Material: parameter '${e}' has value of undefined.`
                );
                continue;
              }
              const r = this[e];
              if (r === void 0) {
                console.warn(
                  `THREE.Material: '${e}' is not a property of THREE.${this.type}.`
                );
                continue;
              }
              r && r.isColor
                ? r.set(n)
                : r && r.isVector3 && n && n.isVector3
                ? r.copy(n)
                : (this[e] = n);
            }
        }
        toJSON(t) {
          const e = t === void 0 || typeof t == "string";
          e && (t = { textures: {}, images: {} });
          const n = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          (n.uuid = this.uuid),
            (n.type = this.type),
            this.name !== "" && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            this.roughness !== void 0 && (n.roughness = this.roughness),
            this.metalness !== void 0 && (n.metalness = this.metalness),
            this.sheen !== void 0 && (n.sheen = this.sheen),
            this.sheenColor &&
              this.sheenColor.isColor &&
              (n.sheenColor = this.sheenColor.getHex()),
            this.sheenRoughness !== void 0 &&
              (n.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity !== void 0 &&
              this.emissiveIntensity !== 1 &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            this.specularIntensity !== void 0 &&
              (n.specularIntensity = this.specularIntensity),
            this.specularColor &&
              this.specularColor.isColor &&
              (n.specularColor = this.specularColor.getHex()),
            this.shininess !== void 0 && (n.shininess = this.shininess),
            this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
            this.clearcoatRoughness !== void 0 &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(t).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.dispersion !== void 0 && (n.dispersion = this.dispersion),
            this.iridescence !== void 0 && (n.iridescence = this.iridescence),
            this.iridescenceIOR !== void 0 &&
              (n.iridescenceIOR = this.iridescenceIOR),
            this.iridescenceThicknessRange !== void 0 &&
              (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
            this.iridescenceMap &&
              this.iridescenceMap.isTexture &&
              (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
            this.iridescenceThicknessMap &&
              this.iridescenceThicknessMap.isTexture &&
              (n.iridescenceThicknessMap =
                this.iridescenceThicknessMap.toJSON(t).uuid),
            this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
            this.anisotropyRotation !== void 0 &&
              (n.anisotropyRotation = this.anisotropyRotation),
            this.anisotropyMap &&
              this.anisotropyMap.isTexture &&
              (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(t).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(t).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(t).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(t).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(t).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (n.specularIntensityMap =
                this.specularIntensityMap.toJSON(t).uuid),
            this.specularColorMap &&
              this.specularColorMap.isTexture &&
              (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(t).uuid),
              this.combine !== void 0 && (n.combine = this.combine)),
            this.envMapRotation !== void 0 &&
              (n.envMapRotation = this.envMapRotation.toArray()),
            this.envMapIntensity !== void 0 &&
              (n.envMapIntensity = this.envMapIntensity),
            this.reflectivity !== void 0 &&
              (n.reflectivity = this.reflectivity),
            this.refractionRatio !== void 0 &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(t).uuid),
            this.transmission !== void 0 &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
            this.thickness !== void 0 && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
            this.attenuationDistance !== void 0 &&
              this.attenuationDistance !== 1 / 0 &&
              (n.attenuationDistance = this.attenuationDistance),
            this.attenuationColor !== void 0 &&
              (n.attenuationColor = this.attenuationColor.getHex()),
            this.size !== void 0 && (n.size = this.size),
            this.shadowSide !== null && (n.shadowSide = this.shadowSide),
            this.sizeAttenuation !== void 0 &&
              (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== ci && (n.blending = this.blending),
            this.side !== Tn && (n.side = this.side),
            this.vertexColors === !0 && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            this.transparent === !0 && (n.transparent = !0),
            this.blendSrc !== vs && (n.blendSrc = this.blendSrc),
            this.blendDst !== xs && (n.blendDst = this.blendDst),
            this.blendEquation !== Fn && (n.blendEquation = this.blendEquation),
            this.blendSrcAlpha !== null &&
              (n.blendSrcAlpha = this.blendSrcAlpha),
            this.blendDstAlpha !== null &&
              (n.blendDstAlpha = this.blendDstAlpha),
            this.blendEquationAlpha !== null &&
              (n.blendEquationAlpha = this.blendEquationAlpha),
            this.blendColor &&
              this.blendColor.isColor &&
              (n.blendColor = this.blendColor.getHex()),
            this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
            this.depthFunc !== pi && (n.depthFunc = this.depthFunc),
            this.depthTest === !1 && (n.depthTest = this.depthTest),
            this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
            this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
            this.stencilWriteMask !== 255 &&
              (n.stencilWriteMask = this.stencilWriteMask),
            this.stencilFunc !== Ia && (n.stencilFunc = this.stencilFunc),
            this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
            this.stencilFuncMask !== 255 &&
              (n.stencilFuncMask = this.stencilFuncMask),
            this.stencilFail !== Xn && (n.stencilFail = this.stencilFail),
            this.stencilZFail !== Xn && (n.stencilZFail = this.stencilZFail),
            this.stencilZPass !== Xn && (n.stencilZPass = this.stencilZPass),
            this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
            this.rotation !== void 0 &&
              this.rotation !== 0 &&
              (n.rotation = this.rotation),
            this.polygonOffset === !0 && (n.polygonOffset = !0),
            this.polygonOffsetFactor !== 0 &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            this.polygonOffsetUnits !== 0 &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth !== void 0 &&
              this.linewidth !== 1 &&
              (n.linewidth = this.linewidth),
            this.dashSize !== void 0 && (n.dashSize = this.dashSize),
            this.gapSize !== void 0 && (n.gapSize = this.gapSize),
            this.scale !== void 0 && (n.scale = this.scale),
            this.dithering === !0 && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            this.alphaHash === !0 && (n.alphaHash = !0),
            this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
            this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
            this.forceSinglePass === !0 && (n.forceSinglePass = !0),
            this.wireframe === !0 && (n.wireframe = !0),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            this.wireframeLinecap !== "round" &&
              (n.wireframeLinecap = this.wireframeLinecap),
            this.wireframeLinejoin !== "round" &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            this.flatShading === !0 && (n.flatShading = !0),
            this.visible === !1 && (n.visible = !1),
            this.toneMapped === !1 && (n.toneMapped = !1),
            this.fog === !1 && (n.fog = !1),
            Object.keys(this.userData).length > 0 &&
              (n.userData = this.userData);
          function r(s) {
            const a = [];
            for (const o in s) {
              const l = s[o];
              delete l.metadata, a.push(l);
            }
            return a;
          }
          if (e) {
            const s = r(t.textures),
              a = r(t.images);
            s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a);
          }
          return n;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.name = t.name),
            (this.blending = t.blending),
            (this.side = t.side),
            (this.vertexColors = t.vertexColors),
            (this.opacity = t.opacity),
            (this.transparent = t.transparent),
            (this.blendSrc = t.blendSrc),
            (this.blendDst = t.blendDst),
            (this.blendEquation = t.blendEquation),
            (this.blendSrcAlpha = t.blendSrcAlpha),
            (this.blendDstAlpha = t.blendDstAlpha),
            (this.blendEquationAlpha = t.blendEquationAlpha),
            this.blendColor.copy(t.blendColor),
            (this.blendAlpha = t.blendAlpha),
            (this.depthFunc = t.depthFunc),
            (this.depthTest = t.depthTest),
            (this.depthWrite = t.depthWrite),
            (this.stencilWriteMask = t.stencilWriteMask),
            (this.stencilFunc = t.stencilFunc),
            (this.stencilRef = t.stencilRef),
            (this.stencilFuncMask = t.stencilFuncMask),
            (this.stencilFail = t.stencilFail),
            (this.stencilZFail = t.stencilZFail),
            (this.stencilZPass = t.stencilZPass),
            (this.stencilWrite = t.stencilWrite);
          const e = t.clippingPlanes;
          let n = null;
          if (e !== null) {
            const r = e.length;
            n = new Array(r);
            for (let s = 0; s !== r; ++s) n[s] = e[s].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = t.clipIntersection),
            (this.clipShadows = t.clipShadows),
            (this.shadowSide = t.shadowSide),
            (this.colorWrite = t.colorWrite),
            (this.precision = t.precision),
            (this.polygonOffset = t.polygonOffset),
            (this.polygonOffsetFactor = t.polygonOffsetFactor),
            (this.polygonOffsetUnits = t.polygonOffsetUnits),
            (this.dithering = t.dithering),
            (this.alphaTest = t.alphaTest),
            (this.alphaHash = t.alphaHash),
            (this.alphaToCoverage = t.alphaToCoverage),
            (this.premultipliedAlpha = t.premultipliedAlpha),
            (this.forceSinglePass = t.forceSinglePass),
            (this.visible = t.visible),
            (this.toneMapped = t.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(t) {
          t === !0 && this.version++;
        }
        onBuild() {
          console.warn("Material: onBuild() has been removed.");
        }
      }
      class al extends Si {
        constructor(t) {
          super(),
            (this.isMeshBasicMaterial = !0),
            (this.type = "MeshBasicMaterial"),
            (this.color = new Bt(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new je()),
            (this.combine = Go),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            this.envMapRotation.copy(t.envMapRotation),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.fog = t.fog),
            this
          );
        }
      }
      const se = new D(),
        tr = new Pt();
      class Ke {
        constructor(t, e, n = !1) {
          if (Array.isArray(t))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.isBufferAttribute = !0),
            (this.name = ""),
            (this.array = t),
            (this.itemSize = e),
            (this.count = t !== void 0 ? t.length / e : 0),
            (this.normalized = n),
            (this.usage = Na),
            (this.updateRanges = []),
            (this.gpuType = an),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          t === !0 && this.version++;
        }
        setUsage(t) {
          return (this.usage = t), this;
        }
        addUpdateRange(t, e) {
          this.updateRanges.push({ start: t, count: e });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.array = new t.array.constructor(t.array)),
            (this.itemSize = t.itemSize),
            (this.count = t.count),
            (this.normalized = t.normalized),
            (this.usage = t.usage),
            (this.gpuType = t.gpuType),
            this
          );
        }
        copyAt(t, e, n) {
          (t *= this.itemSize), (n *= e.itemSize);
          for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[t + r] = e.array[n + r];
          return this;
        }
        copyArray(t) {
          return this.array.set(t), this;
        }
        applyMatrix3(t) {
          if (this.itemSize === 2)
            for (let e = 0, n = this.count; e < n; e++)
              tr.fromBufferAttribute(this, e),
                tr.applyMatrix3(t),
                this.setXY(e, tr.x, tr.y);
          else if (this.itemSize === 3)
            for (let e = 0, n = this.count; e < n; e++)
              se.fromBufferAttribute(this, e),
                se.applyMatrix3(t),
                this.setXYZ(e, se.x, se.y, se.z);
          return this;
        }
        applyMatrix4(t) {
          for (let e = 0, n = this.count; e < n; e++)
            se.fromBufferAttribute(this, e),
              se.applyMatrix4(t),
              this.setXYZ(e, se.x, se.y, se.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, n = this.count; e < n; e++)
            se.fromBufferAttribute(this, e),
              se.applyNormalMatrix(t),
              this.setXYZ(e, se.x, se.y, se.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, n = this.count; e < n; e++)
            se.fromBufferAttribute(this, e),
              se.transformDirection(t),
              this.setXYZ(e, se.x, se.y, se.z);
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        getComponent(t, e) {
          let n = this.array[t * this.itemSize + e];
          return this.normalized && (n = si(n, this.array)), n;
        }
        setComponent(t, e, n) {
          return (
            this.normalized && (n = _e(n, this.array)),
            (this.array[t * this.itemSize + e] = n),
            this
          );
        }
        getX(t) {
          let e = this.array[t * this.itemSize];
          return this.normalized && (e = si(e, this.array)), e;
        }
        setX(t, e) {
          return (
            this.normalized && (e = _e(e, this.array)),
            (this.array[t * this.itemSize] = e),
            this
          );
        }
        getY(t) {
          let e = this.array[t * this.itemSize + 1];
          return this.normalized && (e = si(e, this.array)), e;
        }
        setY(t, e) {
          return (
            this.normalized && (e = _e(e, this.array)),
            (this.array[t * this.itemSize + 1] = e),
            this
          );
        }
        getZ(t) {
          let e = this.array[t * this.itemSize + 2];
          return this.normalized && (e = si(e, this.array)), e;
        }
        setZ(t, e) {
          return (
            this.normalized && (e = _e(e, this.array)),
            (this.array[t * this.itemSize + 2] = e),
            this
          );
        }
        getW(t) {
          let e = this.array[t * this.itemSize + 3];
          return this.normalized && (e = si(e, this.array)), e;
        }
        setW(t, e) {
          return (
            this.normalized && (e = _e(e, this.array)),
            (this.array[t * this.itemSize + 3] = e),
            this
          );
        }
        setXY(t, e, n) {
          return (
            (t *= this.itemSize),
            this.normalized &&
              ((e = _e(e, this.array)), (n = _e(n, this.array))),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            this
          );
        }
        setXYZ(t, e, n, r) {
          return (
            (t *= this.itemSize),
            this.normalized &&
              ((e = _e(e, this.array)),
              (n = _e(n, this.array)),
              (r = _e(r, this.array))),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = r),
            this
          );
        }
        setXYZW(t, e, n, r, s) {
          return (
            (t *= this.itemSize),
            this.normalized &&
              ((e = _e(e, this.array)),
              (n = _e(n, this.array)),
              (r = _e(r, this.array)),
              (s = _e(s, this.array))),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = r),
            (this.array[t + 3] = s),
            this
          );
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized,
          };
          return (
            this.name !== "" && (t.name = this.name),
            this.usage !== Na && (t.usage = this.usage),
            t
          );
        }
      }
      class ol extends Ke {
        constructor(t, e, n) {
          super(new Uint16Array(t), e, n);
        }
      }
      class ll extends Ke {
        constructor(t, e, n) {
          super(new Uint32Array(t), e, n);
        }
      }
      class Ye extends Ke {
        constructor(t, e, n) {
          super(new Float32Array(t), e, n);
        }
      }
      let $c = 0;
      const Ie = new ee(),
        rs = new ue(),
        ei = new D(),
        Ce = new Vi(),
        Ri = new Vi(),
        ce = new D();
      class cn extends kn {
        constructor() {
          super(),
            (this.isBufferGeometry = !0),
            Object.defineProperty(this, "id", { value: $c++ }),
            (this.uuid = Mi()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(t) {
          return (
            Array.isArray(t)
              ? (this.index = new (el(t) ? ll : ol)(t, 1))
              : (this.index = t),
            this
          );
        }
        getAttribute(t) {
          return this.attributes[t];
        }
        setAttribute(t, e) {
          return (this.attributes[t] = e), this;
        }
        deleteAttribute(t) {
          return delete this.attributes[t], this;
        }
        hasAttribute(t) {
          return this.attributes[t] !== void 0;
        }
        addGroup(t, e, n = 0) {
          this.groups.push({ start: t, count: e, materialIndex: n });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(t, e) {
          (this.drawRange.start = t), (this.drawRange.count = e);
        }
        applyMatrix4(t) {
          const e = this.attributes.position;
          e !== void 0 && (e.applyMatrix4(t), (e.needsUpdate = !0));
          const n = this.attributes.normal;
          if (n !== void 0) {
            const s = new Dt().getNormalMatrix(t);
            n.applyNormalMatrix(s), (n.needsUpdate = !0);
          }
          const r = this.attributes.tangent;
          return (
            r !== void 0 && (r.transformDirection(t), (r.needsUpdate = !0)),
            this.boundingBox !== null && this.computeBoundingBox(),
            this.boundingSphere !== null && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(t) {
          return Ie.makeRotationFromQuaternion(t), this.applyMatrix4(Ie), this;
        }
        rotateX(t) {
          return Ie.makeRotationX(t), this.applyMatrix4(Ie), this;
        }
        rotateY(t) {
          return Ie.makeRotationY(t), this.applyMatrix4(Ie), this;
        }
        rotateZ(t) {
          return Ie.makeRotationZ(t), this.applyMatrix4(Ie), this;
        }
        translate(t, e, n) {
          return Ie.makeTranslation(t, e, n), this.applyMatrix4(Ie), this;
        }
        scale(t, e, n) {
          return Ie.makeScale(t, e, n), this.applyMatrix4(Ie), this;
        }
        lookAt(t) {
          return (
            rs.lookAt(t), rs.updateMatrix(), this.applyMatrix4(rs.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(ei).negate(),
            this.translate(ei.x, ei.y, ei.z),
            this
          );
        }
        setFromPoints(t) {
          const e = [];
          for (let n = 0, r = t.length; n < r; n++) {
            const s = t[n];
            e.push(s.x, s.y, s.z || 0);
          }
          return this.setAttribute("position", new Ye(e, 3)), this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new Vi());
          const t = this.attributes.position,
            e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute) {
            console.error(
              "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
              this
            ),
              this.boundingBox.set(
                new D(-1 / 0, -1 / 0, -1 / 0),
                new D(1 / 0, 1 / 0, 1 / 0)
              );
            return;
          }
          if (t !== void 0) {
            if ((this.boundingBox.setFromBufferAttribute(t), e))
              for (let n = 0, r = e.length; n < r; n++) {
                const s = e[n];
                Ce.setFromBufferAttribute(s),
                  this.morphTargetsRelative
                    ? (ce.addVectors(this.boundingBox.min, Ce.min),
                      this.boundingBox.expandByPoint(ce),
                      ce.addVectors(this.boundingBox.max, Ce.max),
                      this.boundingBox.expandByPoint(ce))
                    : (this.boundingBox.expandByPoint(Ce.min),
                      this.boundingBox.expandByPoint(Ce.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new Dr());
          const t = this.attributes.position,
            e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute) {
            console.error(
              "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
              this
            ),
              this.boundingSphere.set(new D(), 1 / 0);
            return;
          }
          if (t) {
            const n = this.boundingSphere.center;
            if ((Ce.setFromBufferAttribute(t), e))
              for (let s = 0, a = e.length; s < a; s++) {
                const o = e[s];
                Ri.setFromBufferAttribute(o),
                  this.morphTargetsRelative
                    ? (ce.addVectors(Ce.min, Ri.min),
                      Ce.expandByPoint(ce),
                      ce.addVectors(Ce.max, Ri.max),
                      Ce.expandByPoint(ce))
                    : (Ce.expandByPoint(Ri.min), Ce.expandByPoint(Ri.max));
              }
            Ce.getCenter(n);
            let r = 0;
            for (let s = 0, a = t.count; s < a; s++)
              ce.fromBufferAttribute(t, s),
                (r = Math.max(r, n.distanceToSquared(ce)));
            if (e)
              for (let s = 0, a = e.length; s < a; s++) {
                const o = e[s],
                  l = this.morphTargetsRelative;
                for (let c = 0, h = o.count; c < h; c++)
                  ce.fromBufferAttribute(o, c),
                    l && (ei.fromBufferAttribute(t, c), ce.add(ei)),
                    (r = Math.max(r, n.distanceToSquared(ce)));
              }
            (this.boundingSphere.radius = Math.sqrt(r)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeTangents() {
          const t = this.index,
            e = this.attributes;
          if (
            t === null ||
            e.position === void 0 ||
            e.normal === void 0 ||
            e.uv === void 0
          ) {
            console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
            return;
          }
          const n = e.position,
            r = e.normal,
            s = e.uv;
          this.hasAttribute("tangent") === !1 &&
            this.setAttribute(
              "tangent",
              new Ke(new Float32Array(4 * n.count), 4)
            );
          const a = this.getAttribute("tangent"),
            o = [],
            l = [];
          for (let F = 0; F < n.count; F++) (o[F] = new D()), (l[F] = new D());
          const c = new D(),
            h = new D(),
            f = new D(),
            p = new Pt(),
            m = new Pt(),
            v = new Pt(),
            M = new D(),
            u = new D();
          function d(F, tt, _) {
            c.fromBufferAttribute(n, F),
              h.fromBufferAttribute(n, tt),
              f.fromBufferAttribute(n, _),
              p.fromBufferAttribute(s, F),
              m.fromBufferAttribute(s, tt),
              v.fromBufferAttribute(s, _),
              h.sub(c),
              f.sub(c),
              m.sub(p),
              v.sub(p);
            const S = 1 / (m.x * v.y - v.x * m.y);
            isFinite(S) &&
              (M.copy(h)
                .multiplyScalar(v.y)
                .addScaledVector(f, -m.y)
                .multiplyScalar(S),
              u
                .copy(f)
                .multiplyScalar(m.x)
                .addScaledVector(h, -v.x)
                .multiplyScalar(S),
              o[F].add(M),
              o[tt].add(M),
              o[_].add(M),
              l[F].add(u),
              l[tt].add(u),
              l[_].add(u));
          }
          let T = this.groups;
          T.length === 0 && (T = [{ start: 0, count: t.count }]);
          for (let F = 0, tt = T.length; F < tt; ++F) {
            const _ = T[F],
              S = _.start,
              V = _.count;
            for (let z = S, Y = S + V; z < Y; z += 3)
              d(t.getX(z + 0), t.getX(z + 1), t.getX(z + 2));
          }
          const E = new D(),
            A = new D(),
            O = new D(),
            P = new D();
          function b(F) {
            O.fromBufferAttribute(r, F), P.copy(O);
            const tt = o[F];
            E.copy(tt),
              E.sub(O.multiplyScalar(O.dot(tt))).normalize(),
              A.crossVectors(P, tt);
            const S = A.dot(l[F]) < 0 ? -1 : 1;
            a.setXYZW(F, E.x, E.y, E.z, S);
          }
          for (let F = 0, tt = T.length; F < tt; ++F) {
            const _ = T[F],
              S = _.start,
              V = _.count;
            for (let z = S, Y = S + V; z < Y; z += 3)
              b(t.getX(z + 0)), b(t.getX(z + 1)), b(t.getX(z + 2));
          }
        }
        computeVertexNormals() {
          const t = this.index,
            e = this.getAttribute("position");
          if (e !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
              (n = new Ke(new Float32Array(e.count * 3), 3)),
                this.setAttribute("normal", n);
            else for (let p = 0, m = n.count; p < m; p++) n.setXYZ(p, 0, 0, 0);
            const r = new D(),
              s = new D(),
              a = new D(),
              o = new D(),
              l = new D(),
              c = new D(),
              h = new D(),
              f = new D();
            if (t)
              for (let p = 0, m = t.count; p < m; p += 3) {
                const v = t.getX(p + 0),
                  M = t.getX(p + 1),
                  u = t.getX(p + 2);
                r.fromBufferAttribute(e, v),
                  s.fromBufferAttribute(e, M),
                  a.fromBufferAttribute(e, u),
                  h.subVectors(a, s),
                  f.subVectors(r, s),
                  h.cross(f),
                  o.fromBufferAttribute(n, v),
                  l.fromBufferAttribute(n, M),
                  c.fromBufferAttribute(n, u),
                  o.add(h),
                  l.add(h),
                  c.add(h),
                  n.setXYZ(v, o.x, o.y, o.z),
                  n.setXYZ(M, l.x, l.y, l.z),
                  n.setXYZ(u, c.x, c.y, c.z);
              }
            else
              for (let p = 0, m = e.count; p < m; p += 3)
                r.fromBufferAttribute(e, p + 0),
                  s.fromBufferAttribute(e, p + 1),
                  a.fromBufferAttribute(e, p + 2),
                  h.subVectors(a, s),
                  f.subVectors(r, s),
                  h.cross(f),
                  n.setXYZ(p + 0, h.x, h.y, h.z),
                  n.setXYZ(p + 1, h.x, h.y, h.z),
                  n.setXYZ(p + 2, h.x, h.y, h.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        }
        normalizeNormals() {
          const t = this.attributes.normal;
          for (let e = 0, n = t.count; e < n; e++)
            ce.fromBufferAttribute(t, e),
              ce.normalize(),
              t.setXYZ(e, ce.x, ce.y, ce.z);
        }
        toNonIndexed() {
          function t(o, l) {
            const c = o.array,
              h = o.itemSize,
              f = o.normalized,
              p = new c.constructor(l.length * h);
            let m = 0,
              v = 0;
            for (let M = 0, u = l.length; M < u; M++) {
              o.isInterleavedBufferAttribute
                ? (m = l[M] * o.data.stride + o.offset)
                : (m = l[M] * h);
              for (let d = 0; d < h; d++) p[v++] = c[m++];
            }
            return new Ke(p, h, f);
          }
          if (this.index === null)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const e = new cn(),
            n = this.index.array,
            r = this.attributes;
          for (const o in r) {
            const l = r[o],
              c = t(l, n);
            e.setAttribute(o, c);
          }
          const s = this.morphAttributes;
          for (const o in s) {
            const l = [],
              c = s[o];
            for (let h = 0, f = c.length; h < f; h++) {
              const p = c[h],
                m = t(p, n);
              l.push(m);
            }
            e.morphAttributes[o] = l;
          }
          e.morphTargetsRelative = this.morphTargetsRelative;
          const a = this.groups;
          for (let o = 0, l = a.length; o < l; o++) {
            const c = a[o];
            e.addGroup(c.start, c.count, c.materialIndex);
          }
          return e;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((t.uuid = this.uuid),
            (t.type = this.type),
            this.name !== "" && (t.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (t.userData = this.userData),
            this.parameters !== void 0)
          ) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (t[c] = l[c]);
            return t;
          }
          t.data = { attributes: {} };
          const e = this.index;
          e !== null &&
            (t.data.index = {
              type: e.array.constructor.name,
              array: Array.prototype.slice.call(e.array),
            });
          const n = this.attributes;
          for (const l in n) {
            const c = n[l];
            t.data.attributes[l] = c.toJSON(t.data);
          }
          const r = {};
          let s = !1;
          for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l],
              h = [];
            for (let f = 0, p = c.length; f < p; f++) {
              const m = c[f];
              h.push(m.toJSON(t.data));
            }
            h.length > 0 && ((r[l] = h), (s = !0));
          }
          s &&
            ((t.data.morphAttributes = r),
            (t.data.morphTargetsRelative = this.morphTargetsRelative));
          const a = this.groups;
          a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)));
          const o = this.boundingSphere;
          return (
            o !== null &&
              (t.data.boundingSphere = {
                center: o.center.toArray(),
                radius: o.radius,
              }),
            t
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const e = {};
          this.name = t.name;
          const n = t.index;
          n !== null && this.setIndex(n.clone(e));
          const r = t.attributes;
          for (const c in r) {
            const h = r[c];
            this.setAttribute(c, h.clone(e));
          }
          const s = t.morphAttributes;
          for (const c in s) {
            const h = [],
              f = s[c];
            for (let p = 0, m = f.length; p < m; p++) h.push(f[p].clone(e));
            this.morphAttributes[c] = h;
          }
          this.morphTargetsRelative = t.morphTargetsRelative;
          const a = t.groups;
          for (let c = 0, h = a.length; c < h; c++) {
            const f = a[c];
            this.addGroup(f.start, f.count, f.materialIndex);
          }
          const o = t.boundingBox;
          o !== null && (this.boundingBox = o.clone());
          const l = t.boundingSphere;
          return (
            l !== null && (this.boundingSphere = l.clone()),
            (this.drawRange.start = t.drawRange.start),
            (this.drawRange.count = t.drawRange.count),
            (this.userData = t.userData),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      const Za = new ee(),
        Ln = new pa(),
        er = new Dr(),
        $a = new D(),
        nr = new D(),
        ir = new D(),
        rr = new D(),
        ss = new D(),
        sr = new D(),
        Ja = new D(),
        ar = new D();
      class Fe extends ue {
        constructor(t = new cn(), e = new al()) {
          super(),
            (this.isMesh = !0),
            (this.type = "Mesh"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            t.morphTargetInfluences !== void 0 &&
              (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            t.morphTargetDictionary !== void 0 &&
              (this.morphTargetDictionary = Object.assign(
                {},
                t.morphTargetDictionary
              )),
            (this.material = Array.isArray(t.material)
              ? t.material.slice()
              : t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes,
            n = Object.keys(e);
          if (n.length > 0) {
            const r = e[n[0]];
            if (r !== void 0) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let s = 0, a = r.length; s < a; s++) {
                const o = r[s].name || String(s);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[o] = s);
              }
            }
          }
        }
        getVertexPosition(t, e) {
          const n = this.geometry,
            r = n.attributes.position,
            s = n.morphAttributes.position,
            a = n.morphTargetsRelative;
          e.fromBufferAttribute(r, t);
          const o = this.morphTargetInfluences;
          if (s && o) {
            sr.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
              const h = o[l],
                f = s[l];
              h !== 0 &&
                (ss.fromBufferAttribute(f, t),
                a
                  ? sr.addScaledVector(ss, h)
                  : sr.addScaledVector(ss.sub(e), h));
            }
            e.add(sr);
          }
          return e;
        }
        raycast(t, e) {
          const n = this.geometry,
            r = this.material,
            s = this.matrixWorld;
          r !== void 0 &&
            (n.boundingSphere === null && n.computeBoundingSphere(),
            er.copy(n.boundingSphere),
            er.applyMatrix4(s),
            Ln.copy(t.ray).recast(t.near),
            !(
              er.containsPoint(Ln.origin) === !1 &&
              (Ln.intersectSphere(er, $a) === null ||
                Ln.origin.distanceToSquared($a) > (t.far - t.near) ** 2)
            ) &&
              (Za.copy(s).invert(),
              Ln.copy(t.ray).applyMatrix4(Za),
              !(
                n.boundingBox !== null && Ln.intersectsBox(n.boundingBox) === !1
              ) && this._computeIntersections(t, e, Ln)));
        }
        _computeIntersections(t, e, n) {
          let r;
          const s = this.geometry,
            a = this.material,
            o = s.index,
            l = s.attributes.position,
            c = s.attributes.uv,
            h = s.attributes.uv1,
            f = s.attributes.normal,
            p = s.groups,
            m = s.drawRange;
          if (o !== null)
            if (Array.isArray(a))
              for (let v = 0, M = p.length; v < M; v++) {
                const u = p[v],
                  d = a[u.materialIndex],
                  T = Math.max(u.start, m.start),
                  E = Math.min(
                    o.count,
                    Math.min(u.start + u.count, m.start + m.count)
                  );
                for (let A = T, O = E; A < O; A += 3) {
                  const P = o.getX(A),
                    b = o.getX(A + 1),
                    F = o.getX(A + 2);
                  (r = or(this, d, t, n, c, h, f, P, b, F)),
                    r &&
                      ((r.faceIndex = Math.floor(A / 3)),
                      (r.face.materialIndex = u.materialIndex),
                      e.push(r));
                }
              }
            else {
              const v = Math.max(0, m.start),
                M = Math.min(o.count, m.start + m.count);
              for (let u = v, d = M; u < d; u += 3) {
                const T = o.getX(u),
                  E = o.getX(u + 1),
                  A = o.getX(u + 2);
                (r = or(this, a, t, n, c, h, f, T, E, A)),
                  r && ((r.faceIndex = Math.floor(u / 3)), e.push(r));
              }
            }
          else if (l !== void 0)
            if (Array.isArray(a))
              for (let v = 0, M = p.length; v < M; v++) {
                const u = p[v],
                  d = a[u.materialIndex],
                  T = Math.max(u.start, m.start),
                  E = Math.min(
                    l.count,
                    Math.min(u.start + u.count, m.start + m.count)
                  );
                for (let A = T, O = E; A < O; A += 3) {
                  const P = A,
                    b = A + 1,
                    F = A + 2;
                  (r = or(this, d, t, n, c, h, f, P, b, F)),
                    r &&
                      ((r.faceIndex = Math.floor(A / 3)),
                      (r.face.materialIndex = u.materialIndex),
                      e.push(r));
                }
              }
            else {
              const v = Math.max(0, m.start),
                M = Math.min(l.count, m.start + m.count);
              for (let u = v, d = M; u < d; u += 3) {
                const T = u,
                  E = u + 1,
                  A = u + 2;
                (r = or(this, a, t, n, c, h, f, T, E, A)),
                  r && ((r.faceIndex = Math.floor(u / 3)), e.push(r));
              }
            }
        }
      }
      function Jc(i, t, e, n, r, s, a, o) {
        let l;
        if (
          (t.side === ye
            ? (l = n.intersectTriangle(a, s, r, !0, o))
            : (l = n.intersectTriangle(r, s, a, t.side === Tn, o)),
          l === null)
        )
          return null;
        ar.copy(o), ar.applyMatrix4(i.matrixWorld);
        const c = e.ray.origin.distanceTo(ar);
        return c < e.near || c > e.far
          ? null
          : { distance: c, point: ar.clone(), object: i };
      }
      function or(i, t, e, n, r, s, a, o, l, c) {
        i.getVertexPosition(o, nr),
          i.getVertexPosition(l, ir),
          i.getVertexPosition(c, rr);
        const h = Jc(i, t, e, n, nr, ir, rr, Ja);
        if (h) {
          const f = new D();
          We.getBarycoord(Ja, nr, ir, rr, f),
            r && (h.uv = We.getInterpolatedAttribute(r, o, l, c, f, new Pt())),
            s && (h.uv1 = We.getInterpolatedAttribute(s, o, l, c, f, new Pt())),
            a &&
              ((h.normal = We.getInterpolatedAttribute(a, o, l, c, f, new D())),
              h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
          const p = { a: o, b: l, c, normal: new D(), materialIndex: 0 };
          We.getNormal(nr, ir, rr, p.normal), (h.face = p), (h.barycoord = f);
        }
        return h;
      }
      class wn extends cn {
        constructor(t = 1, e = 1, n = 1, r = 1, s = 1, a = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              depth: n,
              widthSegments: r,
              heightSegments: s,
              depthSegments: a,
            });
          const o = this;
          (r = Math.floor(r)), (s = Math.floor(s)), (a = Math.floor(a));
          const l = [],
            c = [],
            h = [],
            f = [];
          let p = 0,
            m = 0;
          v("z", "y", "x", -1, -1, n, e, t, a, s, 0),
            v("z", "y", "x", 1, -1, n, e, -t, a, s, 1),
            v("x", "z", "y", 1, 1, t, n, e, r, a, 2),
            v("x", "z", "y", 1, -1, t, n, -e, r, a, 3),
            v("x", "y", "z", 1, -1, t, e, n, r, s, 4),
            v("x", "y", "z", -1, -1, t, e, -n, r, s, 5),
            this.setIndex(l),
            this.setAttribute("position", new Ye(c, 3)),
            this.setAttribute("normal", new Ye(h, 3)),
            this.setAttribute("uv", new Ye(f, 2));
          function v(M, u, d, T, E, A, O, P, b, F, tt) {
            const _ = A / b,
              S = O / F,
              V = A / 2,
              z = O / 2,
              Y = P / 2,
              j = b + 1,
              G = F + 1;
            let K = 0,
              H = 0;
            const ot = new D();
            for (let lt = 0; lt < G; lt++) {
              const _t = lt * S - z;
              for (let Gt = 0; Gt < j; Gt++) {
                const Yt = Gt * _ - V;
                (ot[M] = Yt * T),
                  (ot[u] = _t * E),
                  (ot[d] = Y),
                  c.push(ot.x, ot.y, ot.z),
                  (ot[M] = 0),
                  (ot[u] = 0),
                  (ot[d] = P > 0 ? 1 : -1),
                  h.push(ot.x, ot.y, ot.z),
                  f.push(Gt / b),
                  f.push(1 - lt / F),
                  (K += 1);
              }
            }
            for (let lt = 0; lt < F; lt++)
              for (let _t = 0; _t < b; _t++) {
                const Gt = p + _t + j * lt,
                  Yt = p + _t + j * (lt + 1),
                  k = p + (_t + 1) + j * (lt + 1),
                  $ = p + (_t + 1) + j * lt;
                l.push(Gt, Yt, $), l.push(Yt, k, $), (H += 6);
              }
            o.addGroup(m, H, tt), (m += H), (p += K);
          }
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new wn(
            t.width,
            t.height,
            t.depth,
            t.widthSegments,
            t.heightSegments,
            t.depthSegments
          );
        }
      }
      function xi(i) {
        const t = {};
        for (const e in i) {
          t[e] = {};
          for (const n in i[e]) {
            const r = i[e][n];
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture ||
              r.isQuaternion)
              ? r.isRenderTargetTexture
                ? (console.warn(
                    "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
                  ),
                  (t[e][n] = null))
                : (t[e][n] = r.clone())
              : Array.isArray(r)
              ? (t[e][n] = r.slice())
              : (t[e][n] = r);
          }
        }
        return t;
      }
      function ge(i) {
        const t = {};
        for (let e = 0; e < i.length; e++) {
          const n = xi(i[e]);
          for (const r in n) t[r] = n[r];
        }
        return t;
      }
      function Qc(i) {
        const t = [];
        for (let e = 0; e < i.length; e++) t.push(i[e].clone());
        return t;
      }
      function cl(i) {
        const t = i.getRenderTarget();
        return t === null
          ? i.outputColorSpace
          : t.isXRRenderTarget === !0
          ? t.texture.colorSpace
          : Xt.workingColorSpace;
      }
      const th = { clone: xi, merge: ge };
      var eh = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        nh = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class An extends Si {
        constructor(t) {
          super(),
            (this.isShaderMaterial = !0),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.uniformsGroups = []),
            (this.vertexShader = eh),
            (this.fragmentShader = nh),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.forceSinglePass = !0),
            (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv1: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            t !== void 0 && this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.fragmentShader = t.fragmentShader),
            (this.vertexShader = t.vertexShader),
            (this.uniforms = xi(t.uniforms)),
            (this.uniformsGroups = Qc(t.uniformsGroups)),
            (this.defines = Object.assign({}, t.defines)),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.fog = t.fog),
            (this.lights = t.lights),
            (this.clipping = t.clipping),
            (this.extensions = Object.assign({}, t.extensions)),
            (this.glslVersion = t.glslVersion),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          (e.glslVersion = this.glslVersion), (e.uniforms = {});
          for (const r in this.uniforms) {
            const a = this.uniforms[r].value;
            a && a.isTexture
              ? (e.uniforms[r] = { type: "t", value: a.toJSON(t).uuid })
              : a && a.isColor
              ? (e.uniforms[r] = { type: "c", value: a.getHex() })
              : a && a.isVector2
              ? (e.uniforms[r] = { type: "v2", value: a.toArray() })
              : a && a.isVector3
              ? (e.uniforms[r] = { type: "v3", value: a.toArray() })
              : a && a.isVector4
              ? (e.uniforms[r] = { type: "v4", value: a.toArray() })
              : a && a.isMatrix3
              ? (e.uniforms[r] = { type: "m3", value: a.toArray() })
              : a && a.isMatrix4
              ? (e.uniforms[r] = { type: "m4", value: a.toArray() })
              : (e.uniforms[r] = { value: a });
          }
          Object.keys(this.defines).length > 0 && (e.defines = this.defines),
            (e.vertexShader = this.vertexShader),
            (e.fragmentShader = this.fragmentShader),
            (e.lights = this.lights),
            (e.clipping = this.clipping);
          const n = {};
          for (const r in this.extensions)
            this.extensions[r] === !0 && (n[r] = !0);
          return Object.keys(n).length > 0 && (e.extensions = n), e;
        }
      }
      class hl extends ue {
        constructor() {
          super(),
            (this.isCamera = !0),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new ee()),
            (this.projectionMatrix = new ee()),
            (this.projectionMatrixInverse = new ee()),
            (this.coordinateSystem = on);
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            (this.coordinateSystem = t.coordinateSystem),
            this
          );
        }
        getWorldDirection(t) {
          return super.getWorldDirection(t).negate();
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(t, e) {
          super.updateWorldMatrix(t, e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const _n = new D(),
        Qa = new Pt(),
        to = new Pt();
      class Pe extends hl {
        constructor(t = 50, e = 1, n = 0.1, r = 2e3) {
          super(),
            (this.isPerspectiveCamera = !0),
            (this.type = "PerspectiveCamera"),
            (this.fov = t),
            (this.zoom = 1),
            (this.near = n),
            (this.far = r),
            (this.focus = 10),
            (this.aspect = e),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.fov = t.fov),
            (this.zoom = t.zoom),
            (this.near = t.near),
            (this.far = t.far),
            (this.focus = t.focus),
            (this.aspect = t.aspect),
            (this.view = t.view === null ? null : Object.assign({}, t.view)),
            (this.filmGauge = t.filmGauge),
            (this.filmOffset = t.filmOffset),
            this
          );
        }
        setFocalLength(t) {
          const e = (0.5 * this.getFilmHeight()) / t;
          (this.fov = Bi * 2 * Math.atan(e)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const t = Math.tan(Ii * 0.5 * this.fov);
          return (0.5 * this.getFilmHeight()) / t;
        }
        getEffectiveFOV() {
          return Bi * 2 * Math.atan(Math.tan(Ii * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(t, e, n) {
          _n.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            e.set(_n.x, _n.y).multiplyScalar(-t / _n.z),
            _n.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            n.set(_n.x, _n.y).multiplyScalar(-t / _n.z);
        }
        getViewSize(t, e) {
          return this.getViewBounds(t, Qa, to), e.subVectors(to, Qa);
        }
        setViewOffset(t, e, n, r, s, a) {
          (this.aspect = t / e),
            this.view === null &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = r),
            (this.view.width = s),
            (this.view.height = a),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = this.near;
          let e = (t * Math.tan(Ii * 0.5 * this.fov)) / this.zoom,
            n = 2 * e,
            r = this.aspect * n,
            s = -0.5 * r;
          const a = this.view;
          if (this.view !== null && this.view.enabled) {
            const l = a.fullWidth,
              c = a.fullHeight;
            (s += (a.offsetX * r) / l),
              (e -= (a.offsetY * n) / c),
              (r *= a.width / l),
              (n *= a.height / c);
          }
          const o = this.filmOffset;
          o !== 0 && (s += (t * o) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              s,
              s + r,
              e,
              e - n,
              t,
              this.far,
              this.coordinateSystem
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.fov = this.fov),
            (e.object.zoom = this.zoom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            (e.object.focus = this.focus),
            (e.object.aspect = this.aspect),
            this.view !== null &&
              (e.object.view = Object.assign({}, this.view)),
            (e.object.filmGauge = this.filmGauge),
            (e.object.filmOffset = this.filmOffset),
            e
          );
        }
      }
      const ni = -90,
        ii = 1;
      class ih extends ue {
        constructor(t, e, n) {
          super(),
            (this.type = "CubeCamera"),
            (this.renderTarget = n),
            (this.coordinateSystem = null),
            (this.activeMipmapLevel = 0);
          const r = new Pe(ni, ii, t, e);
          (r.layers = this.layers), this.add(r);
          const s = new Pe(ni, ii, t, e);
          (s.layers = this.layers), this.add(s);
          const a = new Pe(ni, ii, t, e);
          (a.layers = this.layers), this.add(a);
          const o = new Pe(ni, ii, t, e);
          (o.layers = this.layers), this.add(o);
          const l = new Pe(ni, ii, t, e);
          (l.layers = this.layers), this.add(l);
          const c = new Pe(ni, ii, t, e);
          (c.layers = this.layers), this.add(c);
        }
        updateCoordinateSystem() {
          const t = this.coordinateSystem,
            e = this.children.concat(),
            [n, r, s, a, o, l] = e;
          for (const c of e) this.remove(c);
          if (t === on)
            n.up.set(0, 1, 0),
              n.lookAt(1, 0, 0),
              r.up.set(0, 1, 0),
              r.lookAt(-1, 0, 0),
              s.up.set(0, 0, -1),
              s.lookAt(0, 1, 0),
              a.up.set(0, 0, 1),
              a.lookAt(0, -1, 0),
              o.up.set(0, 1, 0),
              o.lookAt(0, 0, 1),
              l.up.set(0, 1, 0),
              l.lookAt(0, 0, -1);
          else if (t === br)
            n.up.set(0, -1, 0),
              n.lookAt(-1, 0, 0),
              r.up.set(0, -1, 0),
              r.lookAt(1, 0, 0),
              s.up.set(0, 0, 1),
              s.lookAt(0, 1, 0),
              a.up.set(0, 0, -1),
              a.lookAt(0, -1, 0),
              o.up.set(0, -1, 0),
              o.lookAt(0, 0, 1),
              l.up.set(0, -1, 0),
              l.lookAt(0, 0, -1);
          else
            throw new Error(
              "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
                t
            );
          for (const c of e) this.add(c), c.updateMatrixWorld();
        }
        update(t, e) {
          this.parent === null && this.updateMatrixWorld();
          const { renderTarget: n, activeMipmapLevel: r } = this;
          this.coordinateSystem !== t.coordinateSystem &&
            ((this.coordinateSystem = t.coordinateSystem),
            this.updateCoordinateSystem());
          const [s, a, o, l, c, h] = this.children,
            f = t.getRenderTarget(),
            p = t.getActiveCubeFace(),
            m = t.getActiveMipmapLevel(),
            v = t.xr.enabled;
          t.xr.enabled = !1;
          const M = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            t.setRenderTarget(n, 0, r),
            t.render(e, s),
            t.setRenderTarget(n, 1, r),
            t.render(e, a),
            t.setRenderTarget(n, 2, r),
            t.render(e, o),
            t.setRenderTarget(n, 3, r),
            t.render(e, l),
            t.setRenderTarget(n, 4, r),
            t.render(e, c),
            (n.texture.generateMipmaps = M),
            t.setRenderTarget(n, 5, r),
            t.render(e, h),
            t.setRenderTarget(f, p, m),
            (t.xr.enabled = v),
            (n.texture.needsPMREMUpdate = !0);
        }
      }
      class ul extends xe {
        constructor(t, e, n, r, s, a, o, l, c, h) {
          (t = t !== void 0 ? t : []),
            (e = e !== void 0 ? e : mi),
            super(t, e, n, r, s, a, o, l, c, h),
            (this.isCubeTexture = !0),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(t) {
          this.image = t;
        }
      }
      class rh extends Gn {
        constructor(t = 1, e = {}) {
          super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
          const n = { width: t, height: t, depth: 1 },
            r = [n, n, n, n, n, n];
          (this.texture = new ul(
            r,
            e.mapping,
            e.wrapS,
            e.wrapT,
            e.magFilter,
            e.minFilter,
            e.format,
            e.type,
            e.anisotropy,
            e.colorSpace
          )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              e.generateMipmaps !== void 0 ? e.generateMipmaps : !1),
            (this.texture.minFilter =
              e.minFilter !== void 0 ? e.minFilter : ke);
        }
        fromEquirectangularTexture(t, e) {
          (this.texture.type = e.type),
            (this.texture.colorSpace = e.colorSpace),
            (this.texture.generateMipmaps = e.generateMipmaps),
            (this.texture.minFilter = e.minFilter),
            (this.texture.magFilter = e.magFilter);
          const n = {
              uniforms: { tEquirect: { value: null } },
              vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
              fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
            },
            r = new wn(5, 5, 5),
            s = new An({
              name: "CubemapFromEquirect",
              uniforms: xi(n.uniforms),
              vertexShader: n.vertexShader,
              fragmentShader: n.fragmentShader,
              side: ye,
              blending: En,
            });
          s.uniforms.tEquirect.value = e;
          const a = new Fe(r, s),
            o = e.minFilter;
          return (
            e.minFilter === zn && (e.minFilter = ke),
            new ih(1, 10, this).update(t, a),
            (e.minFilter = o),
            a.geometry.dispose(),
            a.material.dispose(),
            this
          );
        }
        clear(t, e, n, r) {
          const s = t.getRenderTarget();
          for (let a = 0; a < 6; a++)
            t.setRenderTarget(this, a), t.clear(e, n, r);
          t.setRenderTarget(s);
        }
      }
      const as = new D(),
        sh = new D(),
        ah = new Dt();
      class gn {
        constructor(t = new D(1, 0, 0), e = 0) {
          (this.isPlane = !0), (this.normal = t), (this.constant = e);
        }
        set(t, e) {
          return this.normal.copy(t), (this.constant = e), this;
        }
        setComponents(t, e, n, r) {
          return this.normal.set(t, e, n), (this.constant = r), this;
        }
        setFromNormalAndCoplanarPoint(t, e) {
          return (
            this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(t, e, n) {
          const r = as.subVectors(n, e).cross(sh.subVectors(t, e)).normalize();
          return this.setFromNormalAndCoplanarPoint(r, t), this;
        }
        copy(t) {
          return this.normal.copy(t.normal), (this.constant = t.constant), this;
        }
        normalize() {
          const t = 1 / this.normal.length();
          return this.normal.multiplyScalar(t), (this.constant *= t), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(t) {
          return this.normal.dot(t) + this.constant;
        }
        distanceToSphere(t) {
          return this.distanceToPoint(t.center) - t.radius;
        }
        projectPoint(t, e) {
          return e
            .copy(t)
            .addScaledVector(this.normal, -this.distanceToPoint(t));
        }
        intersectLine(t, e) {
          const n = t.delta(as),
            r = this.normal.dot(n);
          if (r === 0)
            return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
          const s = -(t.start.dot(this.normal) + this.constant) / r;
          return s < 0 || s > 1 ? null : e.copy(t.start).addScaledVector(n, s);
        }
        intersectsLine(t) {
          const e = this.distanceToPoint(t.start),
            n = this.distanceToPoint(t.end);
          return (e < 0 && n > 0) || (n < 0 && e > 0);
        }
        intersectsBox(t) {
          return t.intersectsPlane(this);
        }
        intersectsSphere(t) {
          return t.intersectsPlane(this);
        }
        coplanarPoint(t) {
          return t.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(t, e) {
          const n = e || ah.getNormalMatrix(t),
            r = this.coplanarPoint(as).applyMatrix4(t),
            s = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -r.dot(s)), this;
        }
        translate(t) {
          return (this.constant -= t.dot(this.normal)), this;
        }
        equals(t) {
          return t.normal.equals(this.normal) && t.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Dn = new Dr(),
        lr = new D();
      class ma {
        constructor(
          t = new gn(),
          e = new gn(),
          n = new gn(),
          r = new gn(),
          s = new gn(),
          a = new gn()
        ) {
          this.planes = [t, e, n, r, s, a];
        }
        set(t, e, n, r, s, a) {
          const o = this.planes;
          return (
            o[0].copy(t),
            o[1].copy(e),
            o[2].copy(n),
            o[3].copy(r),
            o[4].copy(s),
            o[5].copy(a),
            this
          );
        }
        copy(t) {
          const e = this.planes;
          for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
          return this;
        }
        setFromProjectionMatrix(t, e = on) {
          const n = this.planes,
            r = t.elements,
            s = r[0],
            a = r[1],
            o = r[2],
            l = r[3],
            c = r[4],
            h = r[5],
            f = r[6],
            p = r[7],
            m = r[8],
            v = r[9],
            M = r[10],
            u = r[11],
            d = r[12],
            T = r[13],
            E = r[14],
            A = r[15];
          if (
            (n[0].setComponents(l - s, p - c, u - m, A - d).normalize(),
            n[1].setComponents(l + s, p + c, u + m, A + d).normalize(),
            n[2].setComponents(l + a, p + h, u + v, A + T).normalize(),
            n[3].setComponents(l - a, p - h, u - v, A - T).normalize(),
            n[4].setComponents(l - o, p - f, u - M, A - E).normalize(),
            e === on)
          )
            n[5].setComponents(l + o, p + f, u + M, A + E).normalize();
          else if (e === br) n[5].setComponents(o, f, M, E).normalize();
          else
            throw new Error(
              "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
                e
            );
          return this;
        }
        intersectsObject(t) {
          if (t.boundingSphere !== void 0)
            t.boundingSphere === null && t.computeBoundingSphere(),
              Dn.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
          else {
            const e = t.geometry;
            e.boundingSphere === null && e.computeBoundingSphere(),
              Dn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
          }
          return this.intersectsSphere(Dn);
        }
        intersectsSprite(t) {
          return (
            Dn.center.set(0, 0, 0),
            (Dn.radius = 0.7071067811865476),
            Dn.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(Dn)
          );
        }
        intersectsSphere(t) {
          const e = this.planes,
            n = t.center,
            r = -t.radius;
          for (let s = 0; s < 6; s++)
            if (e[s].distanceToPoint(n) < r) return !1;
          return !0;
        }
        intersectsBox(t) {
          const e = this.planes;
          for (let n = 0; n < 6; n++) {
            const r = e[n];
            if (
              ((lr.x = r.normal.x > 0 ? t.max.x : t.min.x),
              (lr.y = r.normal.y > 0 ? t.max.y : t.min.y),
              (lr.z = r.normal.z > 0 ? t.max.z : t.min.z),
              r.distanceToPoint(lr) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(t) {
          const e = this.planes;
          for (let n = 0; n < 6; n++)
            if (e[n].distanceToPoint(t) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function dl() {
        let i = null,
          t = !1,
          e = null,
          n = null;
        function r(s, a) {
          e(s, a), (n = i.requestAnimationFrame(r));
        }
        return {
          start: function () {
            t !== !0 &&
              e !== null &&
              ((n = i.requestAnimationFrame(r)), (t = !0));
          },
          stop: function () {
            i.cancelAnimationFrame(n), (t = !1);
          },
          setAnimationLoop: function (s) {
            e = s;
          },
          setContext: function (s) {
            i = s;
          },
        };
      }
      function oh(i) {
        const t = new WeakMap();
        function e(o, l) {
          const c = o.array,
            h = o.usage,
            f = c.byteLength,
            p = i.createBuffer();
          i.bindBuffer(l, p), i.bufferData(l, c, h), o.onUploadCallback();
          let m;
          if (c instanceof Float32Array) m = i.FLOAT;
          else if (c instanceof Uint16Array)
            o.isFloat16BufferAttribute
              ? (m = i.HALF_FLOAT)
              : (m = i.UNSIGNED_SHORT);
          else if (c instanceof Int16Array) m = i.SHORT;
          else if (c instanceof Uint32Array) m = i.UNSIGNED_INT;
          else if (c instanceof Int32Array) m = i.INT;
          else if (c instanceof Int8Array) m = i.BYTE;
          else if (c instanceof Uint8Array) m = i.UNSIGNED_BYTE;
          else if (c instanceof Uint8ClampedArray) m = i.UNSIGNED_BYTE;
          else
            throw new Error(
              "THREE.WebGLAttributes: Unsupported buffer data format: " + c
            );
          return {
            buffer: p,
            type: m,
            bytesPerElement: c.BYTES_PER_ELEMENT,
            version: o.version,
            size: f,
          };
        }
        function n(o, l, c) {
          const h = l.array,
            f = l.updateRanges;
          if ((i.bindBuffer(c, o), f.length === 0)) i.bufferSubData(c, 0, h);
          else {
            f.sort((m, v) => m.start - v.start);
            let p = 0;
            for (let m = 1; m < f.length; m++) {
              const v = f[p],
                M = f[m];
              M.start <= v.start + v.count + 1
                ? (v.count = Math.max(v.count, M.start + M.count - v.start))
                : (++p, (f[p] = M));
            }
            f.length = p + 1;
            for (let m = 0, v = f.length; m < v; m++) {
              const M = f[m];
              i.bufferSubData(
                c,
                M.start * h.BYTES_PER_ELEMENT,
                h,
                M.start,
                M.count
              );
            }
            l.clearUpdateRanges();
          }
          l.onUploadCallback();
        }
        function r(o) {
          return o.isInterleavedBufferAttribute && (o = o.data), t.get(o);
        }
        function s(o) {
          o.isInterleavedBufferAttribute && (o = o.data);
          const l = t.get(o);
          l && (i.deleteBuffer(l.buffer), t.delete(o));
        }
        function a(o, l) {
          if (
            (o.isInterleavedBufferAttribute && (o = o.data),
            o.isGLBufferAttribute)
          ) {
            const h = t.get(o);
            (!h || h.version < o.version) &&
              t.set(o, {
                buffer: o.buffer,
                type: o.type,
                bytesPerElement: o.elementSize,
                version: o.version,
              });
            return;
          }
          const c = t.get(o);
          if (c === void 0) t.set(o, e(o, l));
          else if (c.version < o.version) {
            if (c.size !== o.array.byteLength)
              throw new Error(
                "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
              );
            n(c.buffer, o, l), (c.version = o.version);
          }
        }
        return { get: r, remove: s, update: a };
      }
      class Ur extends cn {
        constructor(t = 1, e = 1, n = 1, r = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              widthSegments: n,
              heightSegments: r,
            });
          const s = t / 2,
            a = e / 2,
            o = Math.floor(n),
            l = Math.floor(r),
            c = o + 1,
            h = l + 1,
            f = t / o,
            p = e / l,
            m = [],
            v = [],
            M = [],
            u = [];
          for (let d = 0; d < h; d++) {
            const T = d * p - a;
            for (let E = 0; E < c; E++) {
              const A = E * f - s;
              v.push(A, -T, 0),
                M.push(0, 0, 1),
                u.push(E / o),
                u.push(1 - d / l);
            }
          }
          for (let d = 0; d < l; d++)
            for (let T = 0; T < o; T++) {
              const E = T + c * d,
                A = T + c * (d + 1),
                O = T + 1 + c * (d + 1),
                P = T + 1 + c * d;
              m.push(E, A, P), m.push(A, O, P);
            }
          this.setIndex(m),
            this.setAttribute("position", new Ye(v, 3)),
            this.setAttribute("normal", new Ye(M, 3)),
            this.setAttribute("uv", new Ye(u, 2));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new Ur(t.width, t.height, t.widthSegments, t.heightSegments);
        }
      }
      var lh = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
        ch = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
        hh = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
        uh = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        dh = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
        fh = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
        ph = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
        mh = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
        _h = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
        gh = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
        vh = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
        xh = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
        Mh = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
        Sh = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
        Eh = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
        yh = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
        Th = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
        Ah = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
        bh = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
        wh = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
        Rh = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
        Ch = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
        Ph = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
        Lh = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
        Dh = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
        Uh = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
        Ih = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
        Nh = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
        Fh = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
        Oh = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
        Bh = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        zh = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
        Hh = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
        Gh = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
        Vh = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
        kh = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
        Wh = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
        Xh = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
        Yh = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
        qh = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
        Kh = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
        jh = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
        Zh = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
        $h = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
        Jh = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
        Qh = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
        tu = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
        eu = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
        nu = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
        iu = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
        ru = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
        su = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
        au = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
        ou = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
        lu = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
        cu = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
        hu = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
        uu = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        du = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        fu = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
        pu = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
        mu = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
        _u = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
        gu = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        vu = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
        xu = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
        Mu = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
        Su = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
        Eu = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
        yu = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
        Tu = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
        Au = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
        bu = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
        wu = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        Ru = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        Cu = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
        Pu = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
        Lu = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
        Du = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
        Uu = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
        Iu = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
        Nu = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
        Fu = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
        Ou = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
        Bu = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
        zu = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
        Hu = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
        Gu = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
        Vu = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
        ku = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
        Wu = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
        Xu = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
        Yu = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
        qu = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
        Ku = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
        ju = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
        Zu = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
        $u = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
        Ju = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
        Qu = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
        td = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
        ed = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
        nd = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
        id = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
        rd = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
        sd = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
        ad = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
      const od = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
        ld = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
        cd = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
        hd = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
        ud = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
        dd = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
        fd = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
        pd = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
        md = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
        _d = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
        gd = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
        vd = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
        xd = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
        Md = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        Sd = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
        Ed = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        yd = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        Td = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Ad = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
        bd = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        wd = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
        Rd = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
        Cd = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        Pd = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Ld = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
        Dd = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Ud = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        Id = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Nd = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
        Fd = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        Od = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        Bd = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
        zd = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
        Hd = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
        Lt = {
          alphahash_fragment: lh,
          alphahash_pars_fragment: ch,
          alphamap_fragment: hh,
          alphamap_pars_fragment: uh,
          alphatest_fragment: dh,
          alphatest_pars_fragment: fh,
          aomap_fragment: ph,
          aomap_pars_fragment: mh,
          batching_pars_vertex: _h,
          batching_vertex: gh,
          begin_vertex: vh,
          beginnormal_vertex: xh,
          bsdfs: Mh,
          iridescence_fragment: Sh,
          bumpmap_pars_fragment: Eh,
          clipping_planes_fragment: yh,
          clipping_planes_pars_fragment: Th,
          clipping_planes_pars_vertex: Ah,
          clipping_planes_vertex: bh,
          color_fragment: wh,
          color_pars_fragment: Rh,
          color_pars_vertex: Ch,
          color_vertex: Ph,
          common: Lh,
          cube_uv_reflection_fragment: Dh,
          defaultnormal_vertex: Uh,
          displacementmap_pars_vertex: Ih,
          displacementmap_vertex: Nh,
          emissivemap_fragment: Fh,
          emissivemap_pars_fragment: Oh,
          colorspace_fragment: Bh,
          colorspace_pars_fragment: zh,
          envmap_fragment: Hh,
          envmap_common_pars_fragment: Gh,
          envmap_pars_fragment: Vh,
          envmap_pars_vertex: kh,
          envmap_physical_pars_fragment: tu,
          envmap_vertex: Wh,
          fog_vertex: Xh,
          fog_pars_vertex: Yh,
          fog_fragment: qh,
          fog_pars_fragment: Kh,
          gradientmap_pars_fragment: jh,
          lightmap_pars_fragment: Zh,
          lights_lambert_fragment: $h,
          lights_lambert_pars_fragment: Jh,
          lights_pars_begin: Qh,
          lights_toon_fragment: eu,
          lights_toon_pars_fragment: nu,
          lights_phong_fragment: iu,
          lights_phong_pars_fragment: ru,
          lights_physical_fragment: su,
          lights_physical_pars_fragment: au,
          lights_fragment_begin: ou,
          lights_fragment_maps: lu,
          lights_fragment_end: cu,
          logdepthbuf_fragment: hu,
          logdepthbuf_pars_fragment: uu,
          logdepthbuf_pars_vertex: du,
          logdepthbuf_vertex: fu,
          map_fragment: pu,
          map_pars_fragment: mu,
          map_particle_fragment: _u,
          map_particle_pars_fragment: gu,
          metalnessmap_fragment: vu,
          metalnessmap_pars_fragment: xu,
          morphinstance_vertex: Mu,
          morphcolor_vertex: Su,
          morphnormal_vertex: Eu,
          morphtarget_pars_vertex: yu,
          morphtarget_vertex: Tu,
          normal_fragment_begin: Au,
          normal_fragment_maps: bu,
          normal_pars_fragment: wu,
          normal_pars_vertex: Ru,
          normal_vertex: Cu,
          normalmap_pars_fragment: Pu,
          clearcoat_normal_fragment_begin: Lu,
          clearcoat_normal_fragment_maps: Du,
          clearcoat_pars_fragment: Uu,
          iridescence_pars_fragment: Iu,
          opaque_fragment: Nu,
          packing: Fu,
          premultiplied_alpha_fragment: Ou,
          project_vertex: Bu,
          dithering_fragment: zu,
          dithering_pars_fragment: Hu,
          roughnessmap_fragment: Gu,
          roughnessmap_pars_fragment: Vu,
          shadowmap_pars_fragment: ku,
          shadowmap_pars_vertex: Wu,
          shadowmap_vertex: Xu,
          shadowmask_pars_fragment: Yu,
          skinbase_vertex: qu,
          skinning_pars_vertex: Ku,
          skinning_vertex: ju,
          skinnormal_vertex: Zu,
          specularmap_fragment: $u,
          specularmap_pars_fragment: Ju,
          tonemapping_fragment: Qu,
          tonemapping_pars_fragment: td,
          transmission_fragment: ed,
          transmission_pars_fragment: nd,
          uv_pars_fragment: id,
          uv_pars_vertex: rd,
          uv_vertex: sd,
          worldpos_vertex: ad,
          background_vert: od,
          background_frag: ld,
          backgroundCube_vert: cd,
          backgroundCube_frag: hd,
          cube_vert: ud,
          cube_frag: dd,
          depth_vert: fd,
          depth_frag: pd,
          distanceRGBA_vert: md,
          distanceRGBA_frag: _d,
          equirect_vert: gd,
          equirect_frag: vd,
          linedashed_vert: xd,
          linedashed_frag: Md,
          meshbasic_vert: Sd,
          meshbasic_frag: Ed,
          meshlambert_vert: yd,
          meshlambert_frag: Td,
          meshmatcap_vert: Ad,
          meshmatcap_frag: bd,
          meshnormal_vert: wd,
          meshnormal_frag: Rd,
          meshphong_vert: Cd,
          meshphong_frag: Pd,
          meshphysical_vert: Ld,
          meshphysical_frag: Dd,
          meshtoon_vert: Ud,
          meshtoon_frag: Id,
          points_vert: Nd,
          points_frag: Fd,
          shadow_vert: Od,
          shadow_frag: Bd,
          sprite_vert: zd,
          sprite_frag: Hd,
        },
        et = {
          common: {
            diffuse: { value: new Bt(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            mapTransform: { value: new Dt() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Dt() },
            alphaTest: { value: 0 },
          },
          specularmap: {
            specularMap: { value: null },
            specularMapTransform: { value: new Dt() },
          },
          envmap: {
            envMap: { value: null },
            envMapRotation: { value: new Dt() },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: {
            aoMap: { value: null },
            aoMapIntensity: { value: 1 },
            aoMapTransform: { value: new Dt() },
          },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
            lightMapTransform: { value: new Dt() },
          },
          bumpmap: {
            bumpMap: { value: null },
            bumpMapTransform: { value: new Dt() },
            bumpScale: { value: 1 },
          },
          normalmap: {
            normalMap: { value: null },
            normalMapTransform: { value: new Dt() },
            normalScale: { value: new Pt(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementMapTransform: { value: new Dt() },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          emissivemap: {
            emissiveMap: { value: null },
            emissiveMapTransform: { value: new Dt() },
          },
          metalnessmap: {
            metalnessMap: { value: null },
            metalnessMapTransform: { value: new Dt() },
          },
          roughnessmap: {
            roughnessMap: { value: null },
            roughnessMapTransform: { value: new Dt() },
          },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new Bt(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotLightMap: { value: [] },
            spotShadowMap: { value: [] },
            spotLightMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new Bt(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Dt() },
            alphaTest: { value: 0 },
            uvTransform: { value: new Dt() },
          },
          sprite: {
            diffuse: { value: new Bt(16777215) },
            opacity: { value: 1 },
            center: { value: new Pt(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            mapTransform: { value: new Dt() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Dt() },
            alphaTest: { value: 0 },
          },
        },
        qe = {
          basic: {
            uniforms: ge([
              et.common,
              et.specularmap,
              et.envmap,
              et.aomap,
              et.lightmap,
              et.fog,
            ]),
            vertexShader: Lt.meshbasic_vert,
            fragmentShader: Lt.meshbasic_frag,
          },
          lambert: {
            uniforms: ge([
              et.common,
              et.specularmap,
              et.envmap,
              et.aomap,
              et.lightmap,
              et.emissivemap,
              et.bumpmap,
              et.normalmap,
              et.displacementmap,
              et.fog,
              et.lights,
              { emissive: { value: new Bt(0) } },
            ]),
            vertexShader: Lt.meshlambert_vert,
            fragmentShader: Lt.meshlambert_frag,
          },
          phong: {
            uniforms: ge([
              et.common,
              et.specularmap,
              et.envmap,
              et.aomap,
              et.lightmap,
              et.emissivemap,
              et.bumpmap,
              et.normalmap,
              et.displacementmap,
              et.fog,
              et.lights,
              {
                emissive: { value: new Bt(0) },
                specular: { value: new Bt(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: Lt.meshphong_vert,
            fragmentShader: Lt.meshphong_frag,
          },
          standard: {
            uniforms: ge([
              et.common,
              et.envmap,
              et.aomap,
              et.lightmap,
              et.emissivemap,
              et.bumpmap,
              et.normalmap,
              et.displacementmap,
              et.roughnessmap,
              et.metalnessmap,
              et.fog,
              et.lights,
              {
                emissive: { value: new Bt(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: Lt.meshphysical_vert,
            fragmentShader: Lt.meshphysical_frag,
          },
          toon: {
            uniforms: ge([
              et.common,
              et.aomap,
              et.lightmap,
              et.emissivemap,
              et.bumpmap,
              et.normalmap,
              et.displacementmap,
              et.gradientmap,
              et.fog,
              et.lights,
              { emissive: { value: new Bt(0) } },
            ]),
            vertexShader: Lt.meshtoon_vert,
            fragmentShader: Lt.meshtoon_frag,
          },
          matcap: {
            uniforms: ge([
              et.common,
              et.bumpmap,
              et.normalmap,
              et.displacementmap,
              et.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: Lt.meshmatcap_vert,
            fragmentShader: Lt.meshmatcap_frag,
          },
          points: {
            uniforms: ge([et.points, et.fog]),
            vertexShader: Lt.points_vert,
            fragmentShader: Lt.points_frag,
          },
          dashed: {
            uniforms: ge([
              et.common,
              et.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: Lt.linedashed_vert,
            fragmentShader: Lt.linedashed_frag,
          },
          depth: {
            uniforms: ge([et.common, et.displacementmap]),
            vertexShader: Lt.depth_vert,
            fragmentShader: Lt.depth_frag,
          },
          normal: {
            uniforms: ge([
              et.common,
              et.bumpmap,
              et.normalmap,
              et.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: Lt.meshnormal_vert,
            fragmentShader: Lt.meshnormal_frag,
          },
          sprite: {
            uniforms: ge([et.sprite, et.fog]),
            vertexShader: Lt.sprite_vert,
            fragmentShader: Lt.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new Dt() },
              t2D: { value: null },
              backgroundIntensity: { value: 1 },
            },
            vertexShader: Lt.background_vert,
            fragmentShader: Lt.background_frag,
          },
          backgroundCube: {
            uniforms: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              backgroundBlurriness: { value: 0 },
              backgroundIntensity: { value: 1 },
              backgroundRotation: { value: new Dt() },
            },
            vertexShader: Lt.backgroundCube_vert,
            fragmentShader: Lt.backgroundCube_frag,
          },
          cube: {
            uniforms: {
              tCube: { value: null },
              tFlip: { value: -1 },
              opacity: { value: 1 },
            },
            vertexShader: Lt.cube_vert,
            fragmentShader: Lt.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Lt.equirect_vert,
            fragmentShader: Lt.equirect_frag,
          },
          distanceRGBA: {
            uniforms: ge([
              et.common,
              et.displacementmap,
              {
                referencePosition: { value: new D() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: Lt.distanceRGBA_vert,
            fragmentShader: Lt.distanceRGBA_frag,
          },
          shadow: {
            uniforms: ge([
              et.lights,
              et.fog,
              { color: { value: new Bt(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: Lt.shadow_vert,
            fragmentShader: Lt.shadow_frag,
          },
        };
      qe.physical = {
        uniforms: ge([
          qe.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatMapTransform: { value: new Dt() },
            clearcoatNormalMap: { value: null },
            clearcoatNormalMapTransform: { value: new Dt() },
            clearcoatNormalScale: { value: new Pt(1, 1) },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatRoughnessMapTransform: { value: new Dt() },
            dispersion: { value: 0 },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceMapTransform: { value: new Dt() },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            iridescenceThicknessMapTransform: { value: new Dt() },
            sheen: { value: 0 },
            sheenColor: { value: new Bt(0) },
            sheenColorMap: { value: null },
            sheenColorMapTransform: { value: new Dt() },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            sheenRoughnessMapTransform: { value: new Dt() },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionMapTransform: { value: new Dt() },
            transmissionSamplerSize: { value: new Pt() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            thicknessMapTransform: { value: new Dt() },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new Bt(0) },
            specularColor: { value: new Bt(1, 1, 1) },
            specularColorMap: { value: null },
            specularColorMapTransform: { value: new Dt() },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularIntensityMapTransform: { value: new Dt() },
            anisotropyVector: { value: new Pt() },
            anisotropyMap: { value: null },
            anisotropyMapTransform: { value: new Dt() },
          },
        ]),
        vertexShader: Lt.meshphysical_vert,
        fragmentShader: Lt.meshphysical_frag,
      };
      const cr = { r: 0, b: 0, g: 0 },
        Un = new je(),
        Gd = new ee();
      function Vd(i, t, e, n, r, s, a) {
        const o = new Bt(0);
        let l = s === !0 ? 0 : 1,
          c,
          h,
          f = null,
          p = 0,
          m = null;
        function v(T) {
          let E = T.isScene === !0 ? T.background : null;
          return (
            E &&
              E.isTexture &&
              (E = (T.backgroundBlurriness > 0 ? e : t).get(E)),
            E
          );
        }
        function M(T) {
          let E = !1;
          const A = v(T);
          A === null ? d(o, l) : A && A.isColor && (d(A, 1), (E = !0));
          const O = i.xr.getEnvironmentBlendMode();
          O === "additive"
            ? n.buffers.color.setClear(0, 0, 0, 1, a)
            : O === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a),
            (i.autoClear || E) &&
              (n.buffers.depth.setTest(!0),
              n.buffers.depth.setMask(!0),
              n.buffers.color.setMask(!0),
              i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil));
        }
        function u(T, E) {
          const A = v(E);
          A && (A.isCubeTexture || A.mapping === Pr)
            ? (h === void 0 &&
                ((h = new Fe(
                  new wn(1, 1, 1),
                  new An({
                    name: "BackgroundCubeMaterial",
                    uniforms: xi(qe.backgroundCube.uniforms),
                    vertexShader: qe.backgroundCube.vertexShader,
                    fragmentShader: qe.backgroundCube.fragmentShader,
                    side: ye,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  })
                )),
                h.geometry.deleteAttribute("normal"),
                h.geometry.deleteAttribute("uv"),
                (h.onBeforeRender = function (O, P, b) {
                  this.matrixWorld.copyPosition(b.matrixWorld);
                }),
                Object.defineProperty(h.material, "envMap", {
                  get: function () {
                    return this.uniforms.envMap.value;
                  },
                }),
                r.update(h)),
              Un.copy(E.backgroundRotation),
              (Un.x *= -1),
              (Un.y *= -1),
              (Un.z *= -1),
              A.isCubeTexture &&
                A.isRenderTargetTexture === !1 &&
                ((Un.y *= -1), (Un.z *= -1)),
              (h.material.uniforms.envMap.value = A),
              (h.material.uniforms.flipEnvMap.value =
                A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1),
              (h.material.uniforms.backgroundBlurriness.value =
                E.backgroundBlurriness),
              (h.material.uniforms.backgroundIntensity.value =
                E.backgroundIntensity),
              h.material.uniforms.backgroundRotation.value.setFromMatrix4(
                Gd.makeRotationFromEuler(Un)
              ),
              (h.material.toneMapped = Xt.getTransfer(A.colorSpace) !== te),
              (f !== A || p !== A.version || m !== i.toneMapping) &&
                ((h.material.needsUpdate = !0),
                (f = A),
                (p = A.version),
                (m = i.toneMapping)),
              h.layers.enableAll(),
              T.unshift(h, h.geometry, h.material, 0, 0, null))
            : A &&
              A.isTexture &&
              (c === void 0 &&
                ((c = new Fe(
                  new Ur(2, 2),
                  new An({
                    name: "BackgroundMaterial",
                    uniforms: xi(qe.background.uniforms),
                    vertexShader: qe.background.vertexShader,
                    fragmentShader: qe.background.fragmentShader,
                    side: Tn,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  })
                )),
                c.geometry.deleteAttribute("normal"),
                Object.defineProperty(c.material, "map", {
                  get: function () {
                    return this.uniforms.t2D.value;
                  },
                }),
                r.update(c)),
              (c.material.uniforms.t2D.value = A),
              (c.material.uniforms.backgroundIntensity.value =
                E.backgroundIntensity),
              (c.material.toneMapped = Xt.getTransfer(A.colorSpace) !== te),
              A.matrixAutoUpdate === !0 && A.updateMatrix(),
              c.material.uniforms.uvTransform.value.copy(A.matrix),
              (f !== A || p !== A.version || m !== i.toneMapping) &&
                ((c.material.needsUpdate = !0),
                (f = A),
                (p = A.version),
                (m = i.toneMapping)),
              c.layers.enableAll(),
              T.unshift(c, c.geometry, c.material, 0, 0, null));
        }
        function d(T, E) {
          T.getRGB(cr, cl(i)), n.buffers.color.setClear(cr.r, cr.g, cr.b, E, a);
        }
        return {
          getClearColor: function () {
            return o;
          },
          setClearColor: function (T, E = 1) {
            o.set(T), (l = E), d(o, l);
          },
          getClearAlpha: function () {
            return l;
          },
          setClearAlpha: function (T) {
            (l = T), d(o, l);
          },
          render: M,
          addToRenderList: u,
        };
      }
      function kd(i, t) {
        const e = i.getParameter(i.MAX_VERTEX_ATTRIBS),
          n = {},
          r = p(null);
        let s = r,
          a = !1;
        function o(_, S, V, z, Y) {
          let j = !1;
          const G = f(z, V, S);
          s !== G && ((s = G), c(s.object)),
            (j = m(_, z, V, Y)),
            j && v(_, z, V, Y),
            Y !== null && t.update(Y, i.ELEMENT_ARRAY_BUFFER),
            (j || a) &&
              ((a = !1),
              A(_, S, V, z),
              Y !== null &&
                i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, t.get(Y).buffer));
        }
        function l() {
          return i.createVertexArray();
        }
        function c(_) {
          return i.bindVertexArray(_);
        }
        function h(_) {
          return i.deleteVertexArray(_);
        }
        function f(_, S, V) {
          const z = V.wireframe === !0;
          let Y = n[_.id];
          Y === void 0 && ((Y = {}), (n[_.id] = Y));
          let j = Y[S.id];
          j === void 0 && ((j = {}), (Y[S.id] = j));
          let G = j[z];
          return G === void 0 && ((G = p(l())), (j[z] = G)), G;
        }
        function p(_) {
          const S = [],
            V = [],
            z = [];
          for (let Y = 0; Y < e; Y++) (S[Y] = 0), (V[Y] = 0), (z[Y] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: S,
            enabledAttributes: V,
            attributeDivisors: z,
            object: _,
            attributes: {},
            index: null,
          };
        }
        function m(_, S, V, z) {
          const Y = s.attributes,
            j = S.attributes;
          let G = 0;
          const K = V.getAttributes();
          for (const H in K)
            if (K[H].location >= 0) {
              const lt = Y[H];
              let _t = j[H];
              if (
                (_t === void 0 &&
                  (H === "instanceMatrix" &&
                    _.instanceMatrix &&
                    (_t = _.instanceMatrix),
                  H === "instanceColor" &&
                    _.instanceColor &&
                    (_t = _.instanceColor)),
                lt === void 0 ||
                  lt.attribute !== _t ||
                  (_t && lt.data !== _t.data))
              )
                return !0;
              G++;
            }
          return s.attributesNum !== G || s.index !== z;
        }
        function v(_, S, V, z) {
          const Y = {},
            j = S.attributes;
          let G = 0;
          const K = V.getAttributes();
          for (const H in K)
            if (K[H].location >= 0) {
              let lt = j[H];
              lt === void 0 &&
                (H === "instanceMatrix" &&
                  _.instanceMatrix &&
                  (lt = _.instanceMatrix),
                H === "instanceColor" &&
                  _.instanceColor &&
                  (lt = _.instanceColor));
              const _t = {};
              (_t.attribute = lt),
                lt && lt.data && (_t.data = lt.data),
                (Y[H] = _t),
                G++;
            }
          (s.attributes = Y), (s.attributesNum = G), (s.index = z);
        }
        function M() {
          const _ = s.newAttributes;
          for (let S = 0, V = _.length; S < V; S++) _[S] = 0;
        }
        function u(_) {
          d(_, 0);
        }
        function d(_, S) {
          const V = s.newAttributes,
            z = s.enabledAttributes,
            Y = s.attributeDivisors;
          (V[_] = 1),
            z[_] === 0 && (i.enableVertexAttribArray(_), (z[_] = 1)),
            Y[_] !== S && (i.vertexAttribDivisor(_, S), (Y[_] = S));
        }
        function T() {
          const _ = s.newAttributes,
            S = s.enabledAttributes;
          for (let V = 0, z = S.length; V < z; V++)
            S[V] !== _[V] && (i.disableVertexAttribArray(V), (S[V] = 0));
        }
        function E(_, S, V, z, Y, j, G) {
          G === !0
            ? i.vertexAttribIPointer(_, S, V, Y, j)
            : i.vertexAttribPointer(_, S, V, z, Y, j);
        }
        function A(_, S, V, z) {
          M();
          const Y = z.attributes,
            j = V.getAttributes(),
            G = S.defaultAttributeValues;
          for (const K in j) {
            const H = j[K];
            if (H.location >= 0) {
              let ot = Y[K];
              if (
                (ot === void 0 &&
                  (K === "instanceMatrix" &&
                    _.instanceMatrix &&
                    (ot = _.instanceMatrix),
                  K === "instanceColor" &&
                    _.instanceColor &&
                    (ot = _.instanceColor)),
                ot !== void 0)
              ) {
                const lt = ot.normalized,
                  _t = ot.itemSize,
                  Gt = t.get(ot);
                if (Gt === void 0) continue;
                const Yt = Gt.buffer,
                  k = Gt.type,
                  $ = Gt.bytesPerElement,
                  pt = k === i.INT || k === i.UNSIGNED_INT || ot.gpuType === aa;
                if (ot.isInterleavedBufferAttribute) {
                  const ct = ot.data,
                    Rt = ct.stride,
                    Et = ot.offset;
                  if (ct.isInstancedInterleavedBuffer) {
                    for (let Nt = 0; Nt < H.locationSize; Nt++)
                      d(H.location + Nt, ct.meshPerAttribute);
                    _.isInstancedMesh !== !0 &&
                      z._maxInstanceCount === void 0 &&
                      (z._maxInstanceCount = ct.meshPerAttribute * ct.count);
                  } else
                    for (let Nt = 0; Nt < H.locationSize; Nt++)
                      u(H.location + Nt);
                  i.bindBuffer(i.ARRAY_BUFFER, Yt);
                  for (let Nt = 0; Nt < H.locationSize; Nt++)
                    E(
                      H.location + Nt,
                      _t / H.locationSize,
                      k,
                      lt,
                      Rt * $,
                      (Et + (_t / H.locationSize) * Nt) * $,
                      pt
                    );
                } else {
                  if (ot.isInstancedBufferAttribute) {
                    for (let ct = 0; ct < H.locationSize; ct++)
                      d(H.location + ct, ot.meshPerAttribute);
                    _.isInstancedMesh !== !0 &&
                      z._maxInstanceCount === void 0 &&
                      (z._maxInstanceCount = ot.meshPerAttribute * ot.count);
                  } else
                    for (let ct = 0; ct < H.locationSize; ct++)
                      u(H.location + ct);
                  i.bindBuffer(i.ARRAY_BUFFER, Yt);
                  for (let ct = 0; ct < H.locationSize; ct++)
                    E(
                      H.location + ct,
                      _t / H.locationSize,
                      k,
                      lt,
                      _t * $,
                      (_t / H.locationSize) * ct * $,
                      pt
                    );
                }
              } else if (G !== void 0) {
                const lt = G[K];
                if (lt !== void 0)
                  switch (lt.length) {
                    case 2:
                      i.vertexAttrib2fv(H.location, lt);
                      break;
                    case 3:
                      i.vertexAttrib3fv(H.location, lt);
                      break;
                    case 4:
                      i.vertexAttrib4fv(H.location, lt);
                      break;
                    default:
                      i.vertexAttrib1fv(H.location, lt);
                  }
              }
            }
          }
          T();
        }
        function O() {
          F();
          for (const _ in n) {
            const S = n[_];
            for (const V in S) {
              const z = S[V];
              for (const Y in z) h(z[Y].object), delete z[Y];
              delete S[V];
            }
            delete n[_];
          }
        }
        function P(_) {
          if (n[_.id] === void 0) return;
          const S = n[_.id];
          for (const V in S) {
            const z = S[V];
            for (const Y in z) h(z[Y].object), delete z[Y];
            delete S[V];
          }
          delete n[_.id];
        }
        function b(_) {
          for (const S in n) {
            const V = n[S];
            if (V[_.id] === void 0) continue;
            const z = V[_.id];
            for (const Y in z) h(z[Y].object), delete z[Y];
            delete V[_.id];
          }
        }
        function F() {
          tt(), (a = !0), s !== r && ((s = r), c(s.object));
        }
        function tt() {
          (r.geometry = null), (r.program = null), (r.wireframe = !1);
        }
        return {
          setup: o,
          reset: F,
          resetDefaultState: tt,
          dispose: O,
          releaseStatesOfGeometry: P,
          releaseStatesOfProgram: b,
          initAttributes: M,
          enableAttribute: u,
          disableUnusedAttributes: T,
        };
      }
      function Wd(i, t, e) {
        let n;
        function r(c) {
          n = c;
        }
        function s(c, h) {
          i.drawArrays(n, c, h), e.update(h, n, 1);
        }
        function a(c, h, f) {
          f !== 0 && (i.drawArraysInstanced(n, c, h, f), e.update(h, n, f));
        }
        function o(c, h, f) {
          if (f === 0) return;
          t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, h, 0, f);
          let m = 0;
          for (let v = 0; v < f; v++) m += h[v];
          e.update(m, n, 1);
        }
        function l(c, h, f, p) {
          if (f === 0) return;
          const m = t.get("WEBGL_multi_draw");
          if (m === null)
            for (let v = 0; v < c.length; v++) a(c[v], h[v], p[v]);
          else {
            m.multiDrawArraysInstancedWEBGL(n, c, 0, h, 0, p, 0, f);
            let v = 0;
            for (let M = 0; M < f; M++) v += h[M];
            for (let M = 0; M < p.length; M++) e.update(v, n, p[M]);
          }
        }
        (this.setMode = r),
          (this.render = s),
          (this.renderInstances = a),
          (this.renderMultiDraw = o),
          (this.renderMultiDrawInstances = l);
      }
      function Xd(i, t, e, n) {
        let r;
        function s() {
          if (r !== void 0) return r;
          if (t.has("EXT_texture_filter_anisotropic") === !0) {
            const b = t.get("EXT_texture_filter_anisotropic");
            r = i.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else r = 0;
          return r;
        }
        function a(b) {
          return !(
            b !== Xe &&
            n.convert(b) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT)
          );
        }
        function o(b) {
          const F =
            b === Gi &&
            (t.has("EXT_color_buffer_half_float") ||
              t.has("EXT_color_buffer_float"));
          return !(
            b !== ln &&
            n.convert(b) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) &&
            b !== an &&
            !F
          );
        }
        function l(b) {
          if (b === "highp") {
            if (
              i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT)
                .precision > 0 &&
              i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT)
                .precision > 0
            )
              return "highp";
            b = "mediump";
          }
          return b === "mediump" &&
            i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT)
              .precision > 0 &&
            i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT)
              .precision > 0
            ? "mediump"
            : "lowp";
        }
        let c = e.precision !== void 0 ? e.precision : "highp";
        const h = l(c);
        h !== c &&
          (console.warn(
            "THREE.WebGLRenderer:",
            c,
            "not supported, using",
            h,
            "instead."
          ),
          (c = h));
        const f = e.logarithmicDepthBuffer === !0,
          p = e.reverseDepthBuffer === !0 && t.has("EXT_clip_control");
        if (p === !0) {
          const b = t.get("EXT_clip_control");
          b.clipControlEXT(b.LOWER_LEFT_EXT, b.ZERO_TO_ONE_EXT);
        }
        const m = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),
          v = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
          M = i.getParameter(i.MAX_TEXTURE_SIZE),
          u = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE),
          d = i.getParameter(i.MAX_VERTEX_ATTRIBS),
          T = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS),
          E = i.getParameter(i.MAX_VARYING_VECTORS),
          A = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS),
          O = v > 0,
          P = i.getParameter(i.MAX_SAMPLES);
        return {
          isWebGL2: !0,
          getMaxAnisotropy: s,
          getMaxPrecision: l,
          textureFormatReadable: a,
          textureTypeReadable: o,
          precision: c,
          logarithmicDepthBuffer: f,
          reverseDepthBuffer: p,
          maxTextures: m,
          maxVertexTextures: v,
          maxTextureSize: M,
          maxCubemapSize: u,
          maxAttributes: d,
          maxVertexUniforms: T,
          maxVaryings: E,
          maxFragmentUniforms: A,
          vertexTextures: O,
          maxSamples: P,
        };
      }
      function Yd(i) {
        const t = this;
        let e = null,
          n = 0,
          r = !1,
          s = !1;
        const a = new gn(),
          o = new Dt(),
          l = { value: null, needsUpdate: !1 };
        (this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (f, p) {
            const m = f.length !== 0 || p || n !== 0 || r;
            return (r = p), (n = f.length), m;
          }),
          (this.beginShadows = function () {
            (s = !0), h(null);
          }),
          (this.endShadows = function () {
            s = !1;
          }),
          (this.setGlobalState = function (f, p) {
            e = h(f, p, 0);
          }),
          (this.setState = function (f, p, m) {
            const v = f.clippingPlanes,
              M = f.clipIntersection,
              u = f.clipShadows,
              d = i.get(f);
            if (!r || v === null || v.length === 0 || (s && !u))
              s ? h(null) : c();
            else {
              const T = s ? 0 : n,
                E = T * 4;
              let A = d.clippingState || null;
              (l.value = A), (A = h(v, p, E, m));
              for (let O = 0; O !== E; ++O) A[O] = e[O];
              (d.clippingState = A),
                (this.numIntersection = M ? this.numPlanes : 0),
                (this.numPlanes += T);
            }
          });
        function c() {
          l.value !== e && ((l.value = e), (l.needsUpdate = n > 0)),
            (t.numPlanes = n),
            (t.numIntersection = 0);
        }
        function h(f, p, m, v) {
          const M = f !== null ? f.length : 0;
          let u = null;
          if (M !== 0) {
            if (((u = l.value), v !== !0 || u === null)) {
              const d = m + M * 4,
                T = p.matrixWorldInverse;
              o.getNormalMatrix(T),
                (u === null || u.length < d) && (u = new Float32Array(d));
              for (let E = 0, A = m; E !== M; ++E, A += 4)
                a.copy(f[E]).applyMatrix4(T, o),
                  a.normal.toArray(u, A),
                  (u[A + 3] = a.constant);
            }
            (l.value = u), (l.needsUpdate = !0);
          }
          return (t.numPlanes = M), (t.numIntersection = 0), u;
        }
      }
      function qd(i) {
        let t = new WeakMap();
        function e(a, o) {
          return o === ws ? (a.mapping = mi) : o === Rs && (a.mapping = _i), a;
        }
        function n(a) {
          if (a && a.isTexture) {
            const o = a.mapping;
            if (o === ws || o === Rs)
              if (t.has(a)) {
                const l = t.get(a).texture;
                return e(l, a.mapping);
              } else {
                const l = a.image;
                if (l && l.height > 0) {
                  const c = new rh(l.height);
                  return (
                    c.fromEquirectangularTexture(i, a),
                    t.set(a, c),
                    a.addEventListener("dispose", r),
                    e(c.texture, a.mapping)
                  );
                } else return null;
              }
          }
          return a;
        }
        function r(a) {
          const o = a.target;
          o.removeEventListener("dispose", r);
          const l = t.get(o);
          l !== void 0 && (t.delete(o), l.dispose());
        }
        function s() {
          t = new WeakMap();
        }
        return { get: n, dispose: s };
      }
      class Kd extends hl {
        constructor(t = -1, e = 1, n = 1, r = -1, s = 0.1, a = 2e3) {
          super(),
            (this.isOrthographicCamera = !0),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = t),
            (this.right = e),
            (this.top = n),
            (this.bottom = r),
            (this.near = s),
            (this.far = a),
            this.updateProjectionMatrix();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.left = t.left),
            (this.right = t.right),
            (this.top = t.top),
            (this.bottom = t.bottom),
            (this.near = t.near),
            (this.far = t.far),
            (this.zoom = t.zoom),
            (this.view = t.view === null ? null : Object.assign({}, t.view)),
            this
          );
        }
        setViewOffset(t, e, n, r, s, a) {
          this.view === null &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = r),
            (this.view.width = s),
            (this.view.height = a),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            r = (this.top + this.bottom) / 2;
          let s = n - t,
            a = n + t,
            o = r + e,
            l = r - e;
          if (this.view !== null && this.view.enabled) {
            const c =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (s += c * this.view.offsetX),
              (a = s + c * this.view.width),
              (o -= h * this.view.offsetY),
              (l = o - h * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            s,
            a,
            o,
            l,
            this.near,
            this.far,
            this.coordinateSystem
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.zoom = this.zoom),
            (e.object.left = this.left),
            (e.object.right = this.right),
            (e.object.top = this.top),
            (e.object.bottom = this.bottom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            this.view !== null &&
              (e.object.view = Object.assign({}, this.view)),
            e
          );
        }
      }
      const oi = 4,
        eo = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        On = 20,
        os = new Kd(),
        no = new Bt();
      let ls = null,
        cs = 0,
        hs = 0,
        us = !1;
      const Nn = (1 + Math.sqrt(5)) / 2,
        ri = 1 / Nn,
        io = [
          new D(-Nn, ri, 0),
          new D(Nn, ri, 0),
          new D(-ri, 0, Nn),
          new D(ri, 0, Nn),
          new D(0, Nn, -ri),
          new D(0, Nn, ri),
          new D(-1, 1, -1),
          new D(1, 1, -1),
          new D(-1, 1, 1),
          new D(1, 1, 1),
        ];
      class ro {
        constructor(t) {
          (this._renderer = t),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(t, e = 0, n = 0.1, r = 100) {
          (ls = this._renderer.getRenderTarget()),
            (cs = this._renderer.getActiveCubeFace()),
            (hs = this._renderer.getActiveMipmapLevel()),
            (us = this._renderer.xr.enabled),
            (this._renderer.xr.enabled = !1),
            this._setSize(256);
          const s = this._allocateTargets();
          return (
            (s.depthBuffer = !0),
            this._sceneToCubeUV(t, n, r, s),
            e > 0 && this._blur(s, 0, 0, e),
            this._applyPMREM(s),
            this._cleanup(s),
            s
          );
        }
        fromEquirectangular(t, e = null) {
          return this._fromTexture(t, e);
        }
        fromCubemap(t, e = null) {
          return this._fromTexture(t, e);
        }
        compileCubemapShader() {
          this._cubemapMaterial === null &&
            ((this._cubemapMaterial = oo()),
            this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          this._equirectMaterial === null &&
            ((this._equirectMaterial = ao()),
            this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(),
            this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
            this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(t) {
          (this._lodMax = Math.floor(Math.log2(t))),
            (this._cubeSize = Math.pow(2, this._lodMax));
        }
        _dispose() {
          this._blurMaterial !== null && this._blurMaterial.dispose(),
            this._pingPongRenderTarget !== null &&
              this._pingPongRenderTarget.dispose();
          for (let t = 0; t < this._lodPlanes.length; t++)
            this._lodPlanes[t].dispose();
        }
        _cleanup(t) {
          this._renderer.setRenderTarget(ls, cs, hs),
            (this._renderer.xr.enabled = us),
            (t.scissorTest = !1),
            hr(t, 0, 0, t.width, t.height);
        }
        _fromTexture(t, e) {
          t.mapping === mi || t.mapping === _i
            ? this._setSize(
                t.image.length === 0
                  ? 16
                  : t.image[0].width || t.image[0].image.width
              )
            : this._setSize(t.image.width / 4),
            (ls = this._renderer.getRenderTarget()),
            (cs = this._renderer.getActiveCubeFace()),
            (hs = this._renderer.getActiveMipmapLevel()),
            (us = this._renderer.xr.enabled),
            (this._renderer.xr.enabled = !1);
          const n = e || this._allocateTargets();
          return (
            this._textureToCubeUV(t, n),
            this._applyPMREM(n),
            this._cleanup(n),
            n
          );
        }
        _allocateTargets() {
          const t = 3 * Math.max(this._cubeSize, 112),
            e = 4 * this._cubeSize,
            n = {
              magFilter: ke,
              minFilter: ke,
              generateMipmaps: !1,
              type: Gi,
              format: Xe,
              colorSpace: bn,
              depthBuffer: !1,
            },
            r = so(t, e, n);
          if (
            this._pingPongRenderTarget === null ||
            this._pingPongRenderTarget.width !== t ||
            this._pingPongRenderTarget.height !== e
          ) {
            this._pingPongRenderTarget !== null && this._dispose(),
              (this._pingPongRenderTarget = so(t, e, n));
            const { _lodMax: s } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas,
            } = jd(s)),
              (this._blurMaterial = Zd(s, t, e));
          }
          return r;
        }
        _compileMaterial(t) {
          const e = new Fe(this._lodPlanes[0], t);
          this._renderer.compile(e, os);
        }
        _sceneToCubeUV(t, e, n, r) {
          const o = new Pe(90, 1, e, n),
            l = [1, -1, 1, 1, 1, 1],
            c = [1, 1, 1, -1, -1, -1],
            h = this._renderer,
            f = h.autoClear,
            p = h.toneMapping;
          h.getClearColor(no), (h.toneMapping = yn), (h.autoClear = !1);
          const m = new al({
              name: "PMREM.Background",
              side: ye,
              depthWrite: !1,
              depthTest: !1,
            }),
            v = new Fe(new wn(), m);
          let M = !1;
          const u = t.background;
          u
            ? u.isColor && (m.color.copy(u), (t.background = null), (M = !0))
            : (m.color.copy(no), (M = !0));
          for (let d = 0; d < 6; d++) {
            const T = d % 3;
            T === 0
              ? (o.up.set(0, l[d], 0), o.lookAt(c[d], 0, 0))
              : T === 1
              ? (o.up.set(0, 0, l[d]), o.lookAt(0, c[d], 0))
              : (o.up.set(0, l[d], 0), o.lookAt(0, 0, c[d]));
            const E = this._cubeSize;
            hr(r, T * E, d > 2 ? E : 0, E, E),
              h.setRenderTarget(r),
              M && h.render(v, o),
              h.render(t, o);
          }
          v.geometry.dispose(),
            v.material.dispose(),
            (h.toneMapping = p),
            (h.autoClear = f),
            (t.background = u);
        }
        _textureToCubeUV(t, e) {
          const n = this._renderer,
            r = t.mapping === mi || t.mapping === _i;
          r
            ? (this._cubemapMaterial === null && (this._cubemapMaterial = oo()),
              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                t.isRenderTargetTexture === !1 ? -1 : 1))
            : this._equirectMaterial === null &&
              (this._equirectMaterial = ao());
          const s = r ? this._cubemapMaterial : this._equirectMaterial,
            a = new Fe(this._lodPlanes[0], s),
            o = s.uniforms;
          o.envMap.value = t;
          const l = this._cubeSize;
          hr(e, 0, 0, 3 * l, 2 * l), n.setRenderTarget(e), n.render(a, os);
        }
        _applyPMREM(t) {
          const e = this._renderer,
            n = e.autoClear;
          e.autoClear = !1;
          const r = this._lodPlanes.length;
          for (let s = 1; s < r; s++) {
            const a = Math.sqrt(
                this._sigmas[s] * this._sigmas[s] -
                  this._sigmas[s - 1] * this._sigmas[s - 1]
              ),
              o = io[(r - s - 1) % io.length];
            this._blur(t, s - 1, s, a, o);
          }
          e.autoClear = n;
        }
        _blur(t, e, n, r, s) {
          const a = this._pingPongRenderTarget;
          this._halfBlur(t, a, e, n, r, "latitudinal", s),
            this._halfBlur(a, t, n, n, r, "longitudinal", s);
        }
        _halfBlur(t, e, n, r, s, a, o) {
          const l = this._renderer,
            c = this._blurMaterial;
          a !== "latitudinal" &&
            a !== "longitudinal" &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          const h = 3,
            f = new Fe(this._lodPlanes[r], c),
            p = c.uniforms,
            m = this._sizeLods[n] - 1,
            v = isFinite(s) ? Math.PI / (2 * m) : (2 * Math.PI) / (2 * On - 1),
            M = s / v,
            u = isFinite(s) ? 1 + Math.floor(h * M) : On;
          u > On &&
            console.warn(
              `sigmaRadians, ${s}, is too large and will clip, as it requested ${u} samples when the maximum is set to ${On}`
            );
          const d = [];
          let T = 0;
          for (let b = 0; b < On; ++b) {
            const F = b / M,
              tt = Math.exp((-F * F) / 2);
            d.push(tt), b === 0 ? (T += tt) : b < u && (T += 2 * tt);
          }
          for (let b = 0; b < d.length; b++) d[b] = d[b] / T;
          (p.envMap.value = t.texture),
            (p.samples.value = u),
            (p.weights.value = d),
            (p.latitudinal.value = a === "latitudinal"),
            o && (p.poleAxis.value = o);
          const { _lodMax: E } = this;
          (p.dTheta.value = v), (p.mipInt.value = E - n);
          const A = this._sizeLods[r],
            O = 3 * A * (r > E - oi ? r - E + oi : 0),
            P = 4 * (this._cubeSize - A);
          hr(e, O, P, 3 * A, 2 * A), l.setRenderTarget(e), l.render(f, os);
        }
      }
      function jd(i) {
        const t = [],
          e = [],
          n = [];
        let r = i;
        const s = i - oi + 1 + eo.length;
        for (let a = 0; a < s; a++) {
          const o = Math.pow(2, r);
          e.push(o);
          let l = 1 / o;
          a > i - oi ? (l = eo[a - i + oi - 1]) : a === 0 && (l = 0), n.push(l);
          const c = 1 / (o - 2),
            h = -c,
            f = 1 + c,
            p = [h, h, f, h, f, f, h, h, f, f, h, f],
            m = 6,
            v = 6,
            M = 3,
            u = 2,
            d = 1,
            T = new Float32Array(M * v * m),
            E = new Float32Array(u * v * m),
            A = new Float32Array(d * v * m);
          for (let P = 0; P < m; P++) {
            const b = ((P % 3) * 2) / 3 - 1,
              F = P > 2 ? 0 : -1,
              tt = [
                b,
                F,
                0,
                b + 2 / 3,
                F,
                0,
                b + 2 / 3,
                F + 1,
                0,
                b,
                F,
                0,
                b + 2 / 3,
                F + 1,
                0,
                b,
                F + 1,
                0,
              ];
            T.set(tt, M * v * P), E.set(p, u * v * P);
            const _ = [P, P, P, P, P, P];
            A.set(_, d * v * P);
          }
          const O = new cn();
          O.setAttribute("position", new Ke(T, M)),
            O.setAttribute("uv", new Ke(E, u)),
            O.setAttribute("faceIndex", new Ke(A, d)),
            t.push(O),
            r > oi && r--;
        }
        return { lodPlanes: t, sizeLods: e, sigmas: n };
      }
      function so(i, t, e) {
        const n = new Gn(i, t, e);
        return (
          (n.texture.mapping = Pr),
          (n.texture.name = "PMREM.cubeUv"),
          (n.scissorTest = !0),
          n
        );
      }
      function hr(i, t, e, n, r) {
        i.viewport.set(t, e, n, r), i.scissor.set(t, e, n, r);
      }
      function Zd(i, t, e) {
        const n = new Float32Array(On),
          r = new D(0, 1, 0);
        return new An({
          name: "SphericalGaussianBlur",
          defines: {
            n: On,
            CUBEUV_TEXEL_WIDTH: 1 / t,
            CUBEUV_TEXEL_HEIGHT: 1 / e,
            CUBEUV_MAX_MIP: `${i}.0`,
          },
          uniforms: {
            envMap: { value: null },
            samples: { value: 1 },
            weights: { value: n },
            latitudinal: { value: !1 },
            dTheta: { value: 0 },
            mipInt: { value: 0 },
            poleAxis: { value: r },
          },
          vertexShader: _a(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
          blending: En,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function ao() {
        return new An({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null } },
          vertexShader: _a(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
          blending: En,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function oo() {
        return new An({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader: _a(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: En,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function _a() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function $d(i) {
        let t = new WeakMap(),
          e = null;
        function n(o) {
          if (o && o.isTexture) {
            const l = o.mapping,
              c = l === ws || l === Rs,
              h = l === mi || l === _i;
            if (c || h) {
              let f = t.get(o);
              const p = f !== void 0 ? f.texture.pmremVersion : 0;
              if (o.isRenderTargetTexture && o.pmremVersion !== p)
                return (
                  e === null && (e = new ro(i)),
                  (f = c ? e.fromEquirectangular(o, f) : e.fromCubemap(o, f)),
                  (f.texture.pmremVersion = o.pmremVersion),
                  t.set(o, f),
                  f.texture
                );
              if (f !== void 0) return f.texture;
              {
                const m = o.image;
                return (c && m && m.height > 0) || (h && m && r(m))
                  ? (e === null && (e = new ro(i)),
                    (f = c ? e.fromEquirectangular(o) : e.fromCubemap(o)),
                    (f.texture.pmremVersion = o.pmremVersion),
                    t.set(o, f),
                    o.addEventListener("dispose", s),
                    f.texture)
                  : null;
              }
            }
          }
          return o;
        }
        function r(o) {
          let l = 0;
          const c = 6;
          for (let h = 0; h < c; h++) o[h] !== void 0 && l++;
          return l === c;
        }
        function s(o) {
          const l = o.target;
          l.removeEventListener("dispose", s);
          const c = t.get(l);
          c !== void 0 && (t.delete(l), c.dispose());
        }
        function a() {
          (t = new WeakMap()), e !== null && (e.dispose(), (e = null));
        }
        return { get: n, dispose: a };
      }
      function Jd(i) {
        const t = {};
        function e(n) {
          if (t[n] !== void 0) return t[n];
          let r;
          switch (n) {
            case "WEBGL_depth_texture":
              r =
                i.getExtension("WEBGL_depth_texture") ||
                i.getExtension("MOZ_WEBGL_depth_texture") ||
                i.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              r =
                i.getExtension("EXT_texture_filter_anisotropic") ||
                i.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              r =
                i.getExtension("WEBGL_compressed_texture_s3tc") ||
                i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              r =
                i.getExtension("WEBGL_compressed_texture_pvrtc") ||
                i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              r = i.getExtension(n);
          }
          return (t[n] = r), r;
        }
        return {
          has: function (n) {
            return e(n) !== null;
          },
          init: function () {
            e("EXT_color_buffer_float"),
              e("WEBGL_clip_cull_distance"),
              e("OES_texture_float_linear"),
              e("EXT_color_buffer_half_float"),
              e("WEBGL_multisampled_render_to_texture"),
              e("WEBGL_render_shared_exponent");
          },
          get: function (n) {
            const r = e(n);
            return (
              r === null &&
                Sr("THREE.WebGLRenderer: " + n + " extension not supported."),
              r
            );
          },
        };
      }
      function Qd(i, t, e, n) {
        const r = {},
          s = new WeakMap();
        function a(f) {
          const p = f.target;
          p.index !== null && t.remove(p.index);
          for (const v in p.attributes) t.remove(p.attributes[v]);
          for (const v in p.morphAttributes) {
            const M = p.morphAttributes[v];
            for (let u = 0, d = M.length; u < d; u++) t.remove(M[u]);
          }
          p.removeEventListener("dispose", a), delete r[p.id];
          const m = s.get(p);
          m && (t.remove(m), s.delete(p)),
            n.releaseStatesOfGeometry(p),
            p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
            e.memory.geometries--;
        }
        function o(f, p) {
          return (
            r[p.id] === !0 ||
              (p.addEventListener("dispose", a),
              (r[p.id] = !0),
              e.memory.geometries++),
            p
          );
        }
        function l(f) {
          const p = f.attributes;
          for (const v in p) t.update(p[v], i.ARRAY_BUFFER);
          const m = f.morphAttributes;
          for (const v in m) {
            const M = m[v];
            for (let u = 0, d = M.length; u < d; u++)
              t.update(M[u], i.ARRAY_BUFFER);
          }
        }
        function c(f) {
          const p = [],
            m = f.index,
            v = f.attributes.position;
          let M = 0;
          if (m !== null) {
            const T = m.array;
            M = m.version;
            for (let E = 0, A = T.length; E < A; E += 3) {
              const O = T[E + 0],
                P = T[E + 1],
                b = T[E + 2];
              p.push(O, P, P, b, b, O);
            }
          } else if (v !== void 0) {
            const T = v.array;
            M = v.version;
            for (let E = 0, A = T.length / 3 - 1; E < A; E += 3) {
              const O = E + 0,
                P = E + 1,
                b = E + 2;
              p.push(O, P, P, b, b, O);
            }
          } else return;
          const u = new (el(p) ? ll : ol)(p, 1);
          u.version = M;
          const d = s.get(f);
          d && t.remove(d), s.set(f, u);
        }
        function h(f) {
          const p = s.get(f);
          if (p) {
            const m = f.index;
            m !== null && p.version < m.version && c(f);
          } else c(f);
          return s.get(f);
        }
        return { get: o, update: l, getWireframeAttribute: h };
      }
      function tf(i, t, e) {
        let n;
        function r(p) {
          n = p;
        }
        let s, a;
        function o(p) {
          (s = p.type), (a = p.bytesPerElement);
        }
        function l(p, m) {
          i.drawElements(n, m, s, p * a), e.update(m, n, 1);
        }
        function c(p, m, v) {
          v !== 0 &&
            (i.drawElementsInstanced(n, m, s, p * a, v), e.update(m, n, v));
        }
        function h(p, m, v) {
          if (v === 0) return;
          t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, m, 0, s, p, 0, v);
          let u = 0;
          for (let d = 0; d < v; d++) u += m[d];
          e.update(u, n, 1);
        }
        function f(p, m, v, M) {
          if (v === 0) return;
          const u = t.get("WEBGL_multi_draw");
          if (u === null)
            for (let d = 0; d < p.length; d++) c(p[d] / a, m[d], M[d]);
          else {
            u.multiDrawElementsInstancedWEBGL(n, m, 0, s, p, 0, M, 0, v);
            let d = 0;
            for (let T = 0; T < v; T++) d += m[T];
            for (let T = 0; T < M.length; T++) e.update(d, n, M[T]);
          }
        }
        (this.setMode = r),
          (this.setIndex = o),
          (this.render = l),
          (this.renderInstances = c),
          (this.renderMultiDraw = h),
          (this.renderMultiDrawInstances = f);
      }
      function ef(i) {
        const t = { geometries: 0, textures: 0 },
          e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        function n(s, a, o) {
          switch ((e.calls++, a)) {
            case i.TRIANGLES:
              e.triangles += o * (s / 3);
              break;
            case i.LINES:
              e.lines += o * (s / 2);
              break;
            case i.LINE_STRIP:
              e.lines += o * (s - 1);
              break;
            case i.LINE_LOOP:
              e.lines += o * s;
              break;
            case i.POINTS:
              e.points += o * s;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", a);
              break;
          }
        }
        function r() {
          (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
        }
        return {
          memory: t,
          render: e,
          programs: null,
          autoReset: !0,
          reset: r,
          update: n,
        };
      }
      function nf(i, t, e) {
        const n = new WeakMap(),
          r = new Zt();
        function s(a, o, l) {
          const c = a.morphTargetInfluences,
            h =
              o.morphAttributes.position ||
              o.morphAttributes.normal ||
              o.morphAttributes.color,
            f = h !== void 0 ? h.length : 0;
          let p = n.get(o);
          if (p === void 0 || p.count !== f) {
            let _ = function () {
              F.dispose(), n.delete(o), o.removeEventListener("dispose", _);
            };
            var m = _;
            p !== void 0 && p.texture.dispose();
            const v = o.morphAttributes.position !== void 0,
              M = o.morphAttributes.normal !== void 0,
              u = o.morphAttributes.color !== void 0,
              d = o.morphAttributes.position || [],
              T = o.morphAttributes.normal || [],
              E = o.morphAttributes.color || [];
            let A = 0;
            v === !0 && (A = 1), M === !0 && (A = 2), u === !0 && (A = 3);
            let O = o.attributes.position.count * A,
              P = 1;
            O > t.maxTextureSize &&
              ((P = Math.ceil(O / t.maxTextureSize)), (O = t.maxTextureSize));
            const b = new Float32Array(O * P * 4 * f),
              F = new il(b, O, P, f);
            (F.type = an), (F.needsUpdate = !0);
            const tt = A * 4;
            for (let S = 0; S < f; S++) {
              const V = d[S],
                z = T[S],
                Y = E[S],
                j = O * P * 4 * S;
              for (let G = 0; G < V.count; G++) {
                const K = G * tt;
                v === !0 &&
                  (r.fromBufferAttribute(V, G),
                  (b[j + K + 0] = r.x),
                  (b[j + K + 1] = r.y),
                  (b[j + K + 2] = r.z),
                  (b[j + K + 3] = 0)),
                  M === !0 &&
                    (r.fromBufferAttribute(z, G),
                    (b[j + K + 4] = r.x),
                    (b[j + K + 5] = r.y),
                    (b[j + K + 6] = r.z),
                    (b[j + K + 7] = 0)),
                  u === !0 &&
                    (r.fromBufferAttribute(Y, G),
                    (b[j + K + 8] = r.x),
                    (b[j + K + 9] = r.y),
                    (b[j + K + 10] = r.z),
                    (b[j + K + 11] = Y.itemSize === 4 ? r.w : 1));
              }
            }
            (p = { count: f, texture: F, size: new Pt(O, P) }),
              n.set(o, p),
              o.addEventListener("dispose", _);
          }
          if (a.isInstancedMesh === !0 && a.morphTexture !== null)
            l.getUniforms().setValue(i, "morphTexture", a.morphTexture, e);
          else {
            let v = 0;
            for (let u = 0; u < c.length; u++) v += c[u];
            const M = o.morphTargetsRelative ? 1 : 1 - v;
            l.getUniforms().setValue(i, "morphTargetBaseInfluence", M),
              l.getUniforms().setValue(i, "morphTargetInfluences", c);
          }
          l.getUniforms().setValue(i, "morphTargetsTexture", p.texture, e),
            l.getUniforms().setValue(i, "morphTargetsTextureSize", p.size);
        }
        return { update: s };
      }
      function rf(i, t, e, n) {
        let r = new WeakMap();
        function s(l) {
          const c = n.render.frame,
            h = l.geometry,
            f = t.get(l, h);
          if (
            (r.get(f) !== c && (t.update(f), r.set(f, c)),
            l.isInstancedMesh &&
              (l.hasEventListener("dispose", o) === !1 &&
                l.addEventListener("dispose", o),
              r.get(l) !== c &&
                (e.update(l.instanceMatrix, i.ARRAY_BUFFER),
                l.instanceColor !== null &&
                  e.update(l.instanceColor, i.ARRAY_BUFFER),
                r.set(l, c))),
            l.isSkinnedMesh)
          ) {
            const p = l.skeleton;
            r.get(p) !== c && (p.update(), r.set(p, c));
          }
          return f;
        }
        function a() {
          r = new WeakMap();
        }
        function o(l) {
          const c = l.target;
          c.removeEventListener("dispose", o),
            e.remove(c.instanceMatrix),
            c.instanceColor !== null && e.remove(c.instanceColor);
        }
        return { update: s, dispose: a };
      }
      class fl extends xe {
        constructor(t, e, n, r, s, a, o, l, c, h = hi) {
          if (h !== hi && h !== vi)
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          n === void 0 && h === hi && (n = Hn),
            n === void 0 && h === vi && (n = gi),
            super(null, r, s, a, o, l, h, n, c),
            (this.isDepthTexture = !0),
            (this.image = { width: t, height: e }),
            (this.magFilter = o !== void 0 ? o : Ne),
            (this.minFilter = l !== void 0 ? l : Ne),
            (this.flipY = !1),
            (this.generateMipmaps = !1),
            (this.compareFunction = null);
        }
        copy(t) {
          return (
            super.copy(t), (this.compareFunction = t.compareFunction), this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            this.compareFunction !== null &&
              (e.compareFunction = this.compareFunction),
            e
          );
        }
      }
      const pl = new xe(),
        lo = new fl(1, 1),
        ml = new il(),
        _l = new Vc(),
        gl = new ul(),
        co = [],
        ho = [],
        uo = new Float32Array(16),
        fo = new Float32Array(9),
        po = new Float32Array(4);
      function Ei(i, t, e) {
        const n = i[0];
        if (n <= 0 || n > 0) return i;
        const r = t * e;
        let s = co[r];
        if (
          (s === void 0 && ((s = new Float32Array(r)), (co[r] = s)), t !== 0)
        ) {
          n.toArray(s, 0);
          for (let a = 1, o = 0; a !== t; ++a) (o += e), i[a].toArray(s, o);
        }
        return s;
      }
      function oe(i, t) {
        if (i.length !== t.length) return !1;
        for (let e = 0, n = i.length; e < n; e++) if (i[e] !== t[e]) return !1;
        return !0;
      }
      function le(i, t) {
        for (let e = 0, n = t.length; e < n; e++) i[e] = t[e];
      }
      function Ir(i, t) {
        let e = ho[t];
        e === void 0 && ((e = new Int32Array(t)), (ho[t] = e));
        for (let n = 0; n !== t; ++n) e[n] = i.allocateTextureUnit();
        return e;
      }
      function sf(i, t) {
        const e = this.cache;
        e[0] !== t && (i.uniform1f(this.addr, t), (e[0] = t));
      }
      function af(i, t) {
        const e = this.cache;
        if (t.x !== void 0)
          (e[0] !== t.x || e[1] !== t.y) &&
            (i.uniform2f(this.addr, t.x, t.y), (e[0] = t.x), (e[1] = t.y));
        else {
          if (oe(e, t)) return;
          i.uniform2fv(this.addr, t), le(e, t);
        }
      }
      function of(i, t) {
        const e = this.cache;
        if (t.x !== void 0)
          (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) &&
            (i.uniform3f(this.addr, t.x, t.y, t.z),
            (e[0] = t.x),
            (e[1] = t.y),
            (e[2] = t.z));
        else if (t.r !== void 0)
          (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) &&
            (i.uniform3f(this.addr, t.r, t.g, t.b),
            (e[0] = t.r),
            (e[1] = t.g),
            (e[2] = t.b));
        else {
          if (oe(e, t)) return;
          i.uniform3fv(this.addr, t), le(e, t);
        }
      }
      function lf(i, t) {
        const e = this.cache;
        if (t.x !== void 0)
          (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) &&
            (i.uniform4f(this.addr, t.x, t.y, t.z, t.w),
            (e[0] = t.x),
            (e[1] = t.y),
            (e[2] = t.z),
            (e[3] = t.w));
        else {
          if (oe(e, t)) return;
          i.uniform4fv(this.addr, t), le(e, t);
        }
      }
      function cf(i, t) {
        const e = this.cache,
          n = t.elements;
        if (n === void 0) {
          if (oe(e, t)) return;
          i.uniformMatrix2fv(this.addr, !1, t), le(e, t);
        } else {
          if (oe(e, n)) return;
          po.set(n), i.uniformMatrix2fv(this.addr, !1, po), le(e, n);
        }
      }
      function hf(i, t) {
        const e = this.cache,
          n = t.elements;
        if (n === void 0) {
          if (oe(e, t)) return;
          i.uniformMatrix3fv(this.addr, !1, t), le(e, t);
        } else {
          if (oe(e, n)) return;
          fo.set(n), i.uniformMatrix3fv(this.addr, !1, fo), le(e, n);
        }
      }
      function uf(i, t) {
        const e = this.cache,
          n = t.elements;
        if (n === void 0) {
          if (oe(e, t)) return;
          i.uniformMatrix4fv(this.addr, !1, t), le(e, t);
        } else {
          if (oe(e, n)) return;
          uo.set(n), i.uniformMatrix4fv(this.addr, !1, uo), le(e, n);
        }
      }
      function df(i, t) {
        const e = this.cache;
        e[0] !== t && (i.uniform1i(this.addr, t), (e[0] = t));
      }
      function ff(i, t) {
        const e = this.cache;
        if (t.x !== void 0)
          (e[0] !== t.x || e[1] !== t.y) &&
            (i.uniform2i(this.addr, t.x, t.y), (e[0] = t.x), (e[1] = t.y));
        else {
          if (oe(e, t)) return;
          i.uniform2iv(this.addr, t), le(e, t);
        }
      }
      function pf(i, t) {
        const e = this.cache;
        if (t.x !== void 0)
          (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) &&
            (i.uniform3i(this.addr, t.x, t.y, t.z),
            (e[0] = t.x),
            (e[1] = t.y),
            (e[2] = t.z));
        else {
          if (oe(e, t)) return;
          i.uniform3iv(this.addr, t), le(e, t);
        }
      }
      function mf(i, t) {
        const e = this.cache;
        if (t.x !== void 0)
          (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) &&
            (i.uniform4i(this.addr, t.x, t.y, t.z, t.w),
            (e[0] = t.x),
            (e[1] = t.y),
            (e[2] = t.z),
            (e[3] = t.w));
        else {
          if (oe(e, t)) return;
          i.uniform4iv(this.addr, t), le(e, t);
        }
      }
      function _f(i, t) {
        const e = this.cache;
        e[0] !== t && (i.uniform1ui(this.addr, t), (e[0] = t));
      }
      function gf(i, t) {
        const e = this.cache;
        if (t.x !== void 0)
          (e[0] !== t.x || e[1] !== t.y) &&
            (i.uniform2ui(this.addr, t.x, t.y), (e[0] = t.x), (e[1] = t.y));
        else {
          if (oe(e, t)) return;
          i.uniform2uiv(this.addr, t), le(e, t);
        }
      }
      function vf(i, t) {
        const e = this.cache;
        if (t.x !== void 0)
          (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) &&
            (i.uniform3ui(this.addr, t.x, t.y, t.z),
            (e[0] = t.x),
            (e[1] = t.y),
            (e[2] = t.z));
        else {
          if (oe(e, t)) return;
          i.uniform3uiv(this.addr, t), le(e, t);
        }
      }
      function xf(i, t) {
        const e = this.cache;
        if (t.x !== void 0)
          (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) &&
            (i.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
            (e[0] = t.x),
            (e[1] = t.y),
            (e[2] = t.z),
            (e[3] = t.w));
        else {
          if (oe(e, t)) return;
          i.uniform4uiv(this.addr, t), le(e, t);
        }
      }
      function Mf(i, t, e) {
        const n = this.cache,
          r = e.allocateTextureUnit();
        n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r));
        let s;
        this.type === i.SAMPLER_2D_SHADOW
          ? ((lo.compareFunction = tl), (s = lo))
          : (s = pl),
          e.setTexture2D(t || s, r);
      }
      function Sf(i, t, e) {
        const n = this.cache,
          r = e.allocateTextureUnit();
        n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r)),
          e.setTexture3D(t || _l, r);
      }
      function Ef(i, t, e) {
        const n = this.cache,
          r = e.allocateTextureUnit();
        n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r)),
          e.setTextureCube(t || gl, r);
      }
      function yf(i, t, e) {
        const n = this.cache,
          r = e.allocateTextureUnit();
        n[0] !== r && (i.uniform1i(this.addr, r), (n[0] = r)),
          e.setTexture2DArray(t || ml, r);
      }
      function Tf(i) {
        switch (i) {
          case 5126:
            return sf;
          case 35664:
            return af;
          case 35665:
            return of;
          case 35666:
            return lf;
          case 35674:
            return cf;
          case 35675:
            return hf;
          case 35676:
            return uf;
          case 5124:
          case 35670:
            return df;
          case 35667:
          case 35671:
            return ff;
          case 35668:
          case 35672:
            return pf;
          case 35669:
          case 35673:
            return mf;
          case 5125:
            return _f;
          case 36294:
            return gf;
          case 36295:
            return vf;
          case 36296:
            return xf;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return Mf;
          case 35679:
          case 36299:
          case 36307:
            return Sf;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Ef;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return yf;
        }
      }
      function Af(i, t) {
        i.uniform1fv(this.addr, t);
      }
      function bf(i, t) {
        const e = Ei(t, this.size, 2);
        i.uniform2fv(this.addr, e);
      }
      function wf(i, t) {
        const e = Ei(t, this.size, 3);
        i.uniform3fv(this.addr, e);
      }
      function Rf(i, t) {
        const e = Ei(t, this.size, 4);
        i.uniform4fv(this.addr, e);
      }
      function Cf(i, t) {
        const e = Ei(t, this.size, 4);
        i.uniformMatrix2fv(this.addr, !1, e);
      }
      function Pf(i, t) {
        const e = Ei(t, this.size, 9);
        i.uniformMatrix3fv(this.addr, !1, e);
      }
      function Lf(i, t) {
        const e = Ei(t, this.size, 16);
        i.uniformMatrix4fv(this.addr, !1, e);
      }
      function Df(i, t) {
        i.uniform1iv(this.addr, t);
      }
      function Uf(i, t) {
        i.uniform2iv(this.addr, t);
      }
      function If(i, t) {
        i.uniform3iv(this.addr, t);
      }
      function Nf(i, t) {
        i.uniform4iv(this.addr, t);
      }
      function Ff(i, t) {
        i.uniform1uiv(this.addr, t);
      }
      function Of(i, t) {
        i.uniform2uiv(this.addr, t);
      }
      function Bf(i, t) {
        i.uniform3uiv(this.addr, t);
      }
      function zf(i, t) {
        i.uniform4uiv(this.addr, t);
      }
      function Hf(i, t, e) {
        const n = this.cache,
          r = t.length,
          s = Ir(e, r);
        oe(n, s) || (i.uniform1iv(this.addr, s), le(n, s));
        for (let a = 0; a !== r; ++a) e.setTexture2D(t[a] || pl, s[a]);
      }
      function Gf(i, t, e) {
        const n = this.cache,
          r = t.length,
          s = Ir(e, r);
        oe(n, s) || (i.uniform1iv(this.addr, s), le(n, s));
        for (let a = 0; a !== r; ++a) e.setTexture3D(t[a] || _l, s[a]);
      }
      function Vf(i, t, e) {
        const n = this.cache,
          r = t.length,
          s = Ir(e, r);
        oe(n, s) || (i.uniform1iv(this.addr, s), le(n, s));
        for (let a = 0; a !== r; ++a) e.setTextureCube(t[a] || gl, s[a]);
      }
      function kf(i, t, e) {
        const n = this.cache,
          r = t.length,
          s = Ir(e, r);
        oe(n, s) || (i.uniform1iv(this.addr, s), le(n, s));
        for (let a = 0; a !== r; ++a) e.setTexture2DArray(t[a] || ml, s[a]);
      }
      function Wf(i) {
        switch (i) {
          case 5126:
            return Af;
          case 35664:
            return bf;
          case 35665:
            return wf;
          case 35666:
            return Rf;
          case 35674:
            return Cf;
          case 35675:
            return Pf;
          case 35676:
            return Lf;
          case 5124:
          case 35670:
            return Df;
          case 35667:
          case 35671:
            return Uf;
          case 35668:
          case 35672:
            return If;
          case 35669:
          case 35673:
            return Nf;
          case 5125:
            return Ff;
          case 36294:
            return Of;
          case 36295:
            return Bf;
          case 36296:
            return zf;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return Hf;
          case 35679:
          case 36299:
          case 36307:
            return Gf;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Vf;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return kf;
        }
      }
      class Xf {
        constructor(t, e, n) {
          (this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.type = e.type),
            (this.setValue = Tf(e.type));
        }
      }
      class Yf {
        constructor(t, e, n) {
          (this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.type = e.type),
            (this.size = e.size),
            (this.setValue = Wf(e.type));
        }
      }
      class qf {
        constructor(t) {
          (this.id = t), (this.seq = []), (this.map = {});
        }
        setValue(t, e, n) {
          const r = this.seq;
          for (let s = 0, a = r.length; s !== a; ++s) {
            const o = r[s];
            o.setValue(t, e[o.id], n);
          }
        }
      }
      const ds = /(\w+)(\])?(\[|\.)?/g;
      function mo(i, t) {
        i.seq.push(t), (i.map[t.id] = t);
      }
      function Kf(i, t, e) {
        const n = i.name,
          r = n.length;
        for (ds.lastIndex = 0; ; ) {
          const s = ds.exec(n),
            a = ds.lastIndex;
          let o = s[1];
          const l = s[2] === "]",
            c = s[3];
          if ((l && (o = o | 0), c === void 0 || (c === "[" && a + 2 === r))) {
            mo(e, c === void 0 ? new Xf(o, i, t) : new Yf(o, i, t));
            break;
          } else {
            let f = e.map[o];
            f === void 0 && ((f = new qf(o)), mo(e, f)), (e = f);
          }
        }
      }
      class Er {
        constructor(t, e) {
          (this.seq = []), (this.map = {});
          const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
          for (let r = 0; r < n; ++r) {
            const s = t.getActiveUniform(e, r),
              a = t.getUniformLocation(e, s.name);
            Kf(s, a, this);
          }
        }
        setValue(t, e, n, r) {
          const s = this.map[e];
          s !== void 0 && s.setValue(t, n, r);
        }
        setOptional(t, e, n) {
          const r = e[n];
          r !== void 0 && this.setValue(t, n, r);
        }
        static upload(t, e, n, r) {
          for (let s = 0, a = e.length; s !== a; ++s) {
            const o = e[s],
              l = n[o.id];
            l.needsUpdate !== !1 && o.setValue(t, l.value, r);
          }
        }
        static seqWithValue(t, e) {
          const n = [];
          for (let r = 0, s = t.length; r !== s; ++r) {
            const a = t[r];
            a.id in e && n.push(a);
          }
          return n;
        }
      }
      function _o(i, t, e) {
        const n = i.createShader(t);
        return i.shaderSource(n, e), i.compileShader(n), n;
      }
      const jf = 37297;
      let Zf = 0;
      function $f(i, t) {
        const e = i.split(`
`),
          n = [],
          r = Math.max(t - 6, 0),
          s = Math.min(t + 6, e.length);
        for (let a = r; a < s; a++) {
          const o = a + 1;
          n.push(`${o === t ? ">" : " "} ${o}: ${e[a]}`);
        }
        return n.join(`
`);
      }
      function Jf(i) {
        const t = Xt.getPrimaries(Xt.workingColorSpace),
          e = Xt.getPrimaries(i);
        let n;
        switch (
          (t === e
            ? (n = "")
            : t === Ar && e === Tr
            ? (n = "LinearDisplayP3ToLinearSRGB")
            : t === Tr && e === Ar && (n = "LinearSRGBToLinearDisplayP3"),
          i)
        ) {
          case bn:
          case Lr:
            return [n, "LinearTransferOETF"];
          case pe:
          case da:
            return [n, "sRGBTransferOETF"];
          default:
            return (
              console.warn("THREE.WebGLProgram: Unsupported color space:", i),
              [n, "LinearTransferOETF"]
            );
        }
      }
      function go(i, t, e) {
        const n = i.getShaderParameter(t, i.COMPILE_STATUS),
          r = i.getShaderInfoLog(t).trim();
        if (n && r === "") return "";
        const s = /ERROR: 0:(\d+)/.exec(r);
        if (s) {
          const a = parseInt(s[1]);
          return (
            e.toUpperCase() +
            `

` +
            r +
            `

` +
            $f(i.getShaderSource(t), a)
          );
        } else return r;
      }
      function Qf(i, t) {
        const e = Jf(t);
        return `vec4 ${i}( vec4 value ) { return ${e[0]}( ${e[1]}( value ) ); }`;
      }
      function tp(i, t) {
        let e;
        switch (t) {
          case Jl:
            e = "Linear";
            break;
          case Ql:
            e = "Reinhard";
            break;
          case tc:
            e = "Cineon";
            break;
          case ec:
            e = "ACESFilmic";
            break;
          case ic:
            e = "AgX";
            break;
          case rc:
            e = "Neutral";
            break;
          case nc:
            e = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
              (e = "Linear");
        }
        return (
          "vec3 " +
          i +
          "( vec3 color ) { return " +
          e +
          "ToneMapping( color ); }"
        );
      }
      const ur = new D();
      function ep() {
        Xt.getLuminanceCoefficients(ur);
        const i = ur.x.toFixed(4),
          t = ur.y.toFixed(4),
          e = ur.z.toFixed(4);
        return [
          "float luminance( const in vec3 rgb ) {",
          `	const vec3 weights = vec3( ${i}, ${t}, ${e} );`,
          "	return dot( weights, rgb );",
          "}",
        ].join(`
`);
      }
      function np(i) {
        return [
          i.extensionClipCullDistance
            ? "#extension GL_ANGLE_clip_cull_distance : require"
            : "",
          i.extensionMultiDraw
            ? "#extension GL_ANGLE_multi_draw : require"
            : "",
        ].filter(Li).join(`
`);
      }
      function ip(i) {
        const t = [];
        for (const e in i) {
          const n = i[e];
          n !== !1 && t.push("#define " + e + " " + n);
        }
        return t.join(`
`);
      }
      function rp(i, t) {
        const e = {},
          n = i.getProgramParameter(t, i.ACTIVE_ATTRIBUTES);
        for (let r = 0; r < n; r++) {
          const s = i.getActiveAttrib(t, r),
            a = s.name;
          let o = 1;
          s.type === i.FLOAT_MAT2 && (o = 2),
            s.type === i.FLOAT_MAT3 && (o = 3),
            s.type === i.FLOAT_MAT4 && (o = 4),
            (e[a] = {
              type: s.type,
              location: i.getAttribLocation(t, a),
              locationSize: o,
            });
        }
        return e;
      }
      function Li(i) {
        return i !== "";
      }
      function vo(i, t) {
        const e =
          t.numSpotLightShadows +
          t.numSpotLightMaps -
          t.numSpotLightShadowsWithMaps;
        return i
          .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
          .replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps)
          .replace(/NUM_SPOT_LIGHT_COORDS/g, e)
          .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
          .replace(
            /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
            t.numSpotLightShadowsWithMaps
          )
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
      }
      function xo(i, t) {
        return i
          .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            t.numClippingPlanes - t.numClipIntersection
          );
      }
      const sp = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function ia(i) {
        return i.replace(sp, op);
      }
      const ap = new Map();
      function op(i, t) {
        let e = Lt[t];
        if (e === void 0) {
          const n = ap.get(t);
          if (n !== void 0)
            (e = Lt[n]),
              console.warn(
                'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
                t,
                n
              );
          else throw new Error("Can not resolve #include <" + t + ">");
        }
        return ia(e);
      }
      const lp =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Mo(i) {
        return i.replace(lp, cp);
      }
      function cp(i, t, e, n) {
        let r = "";
        for (let s = parseInt(t); s < parseInt(e); s++)
          r += n
            .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, s);
        return r;
      }
      function So(i) {
        let t = `precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;
        return (
          i.precision === "highp"
            ? (t += `
#define HIGH_PRECISION`)
            : i.precision === "mediump"
            ? (t += `
#define MEDIUM_PRECISION`)
            : i.precision === "lowp" &&
              (t += `
#define LOW_PRECISION`),
          t
        );
      }
      function hp(i) {
        let t = "SHADOWMAP_TYPE_BASIC";
        return (
          i.shadowMapType === zo
            ? (t = "SHADOWMAP_TYPE_PCF")
            : i.shadowMapType === Ho
            ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
            : i.shadowMapType === nn && (t = "SHADOWMAP_TYPE_VSM"),
          t
        );
      }
      function up(i) {
        let t = "ENVMAP_TYPE_CUBE";
        if (i.envMap)
          switch (i.envMapMode) {
            case mi:
            case _i:
              t = "ENVMAP_TYPE_CUBE";
              break;
            case Pr:
              t = "ENVMAP_TYPE_CUBE_UV";
              break;
          }
        return t;
      }
      function dp(i) {
        let t = "ENVMAP_MODE_REFLECTION";
        if (i.envMap)
          switch (i.envMapMode) {
            case _i:
              t = "ENVMAP_MODE_REFRACTION";
              break;
          }
        return t;
      }
      function fp(i) {
        let t = "ENVMAP_BLENDING_NONE";
        if (i.envMap)
          switch (i.combine) {
            case Go:
              t = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case Zl:
              t = "ENVMAP_BLENDING_MIX";
              break;
            case $l:
              t = "ENVMAP_BLENDING_ADD";
              break;
          }
        return t;
      }
      function pp(i) {
        const t = i.envMapCubeUVHeight;
        if (t === null) return null;
        const e = Math.log2(t) - 2,
          n = 1 / t;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)),
          texelHeight: n,
          maxMip: e,
        };
      }
      function mp(i, t, e, n) {
        const r = i.getContext(),
          s = e.defines;
        let a = e.vertexShader,
          o = e.fragmentShader;
        const l = hp(e),
          c = up(e),
          h = dp(e),
          f = fp(e),
          p = pp(e),
          m = np(e),
          v = ip(s),
          M = r.createProgram();
        let u,
          d,
          T = e.glslVersion
            ? "#version " +
              e.glslVersion +
              `
`
            : "";
        e.isRawShaderMaterial
          ? ((u = [
              "#define SHADER_TYPE " + e.shaderType,
              "#define SHADER_NAME " + e.shaderName,
              v,
            ].filter(Li).join(`
`)),
            u.length > 0 &&
              (u += `
`),
            (d = [
              "#define SHADER_TYPE " + e.shaderType,
              "#define SHADER_NAME " + e.shaderName,
              v,
            ].filter(Li).join(`
`)),
            d.length > 0 &&
              (d += `
`))
          : ((u = [
              So(e),
              "#define SHADER_TYPE " + e.shaderType,
              "#define SHADER_NAME " + e.shaderName,
              v,
              e.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
              e.batching ? "#define USE_BATCHING" : "",
              e.batchingColor ? "#define USE_BATCHING_COLOR" : "",
              e.instancing ? "#define USE_INSTANCING" : "",
              e.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              e.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
              e.useFog && e.fog ? "#define USE_FOG" : "",
              e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
              e.map ? "#define USE_MAP" : "",
              e.envMap ? "#define USE_ENVMAP" : "",
              e.envMap ? "#define " + h : "",
              e.lightMap ? "#define USE_LIGHTMAP" : "",
              e.aoMap ? "#define USE_AOMAP" : "",
              e.bumpMap ? "#define USE_BUMPMAP" : "",
              e.normalMap ? "#define USE_NORMALMAP" : "",
              e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              e.normalMapTangentSpace
                ? "#define USE_NORMALMAP_TANGENTSPACE"
                : "",
              e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
              e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              e.anisotropy ? "#define USE_ANISOTROPY" : "",
              e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              e.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              e.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              e.specularMap ? "#define USE_SPECULARMAP" : "",
              e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              e.metalnessMap ? "#define USE_METALNESSMAP" : "",
              e.alphaMap ? "#define USE_ALPHAMAP" : "",
              e.alphaHash ? "#define USE_ALPHAHASH" : "",
              e.transmission ? "#define USE_TRANSMISSION" : "",
              e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              e.mapUv ? "#define MAP_UV " + e.mapUv : "",
              e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "",
              e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "",
              e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "",
              e.emissiveMapUv
                ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv
                : "",
              e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "",
              e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "",
              e.displacementMapUv
                ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv
                : "",
              e.metalnessMapUv
                ? "#define METALNESSMAP_UV " + e.metalnessMapUv
                : "",
              e.roughnessMapUv
                ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv
                : "",
              e.anisotropyMapUv
                ? "#define ANISOTROPYMAP_UV " + e.anisotropyMapUv
                : "",
              e.clearcoatMapUv
                ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv
                : "",
              e.clearcoatNormalMapUv
                ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv
                : "",
              e.clearcoatRoughnessMapUv
                ? "#define CLEARCOAT_ROUGHNESSMAP_UV " +
                  e.clearcoatRoughnessMapUv
                : "",
              e.iridescenceMapUv
                ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv
                : "",
              e.iridescenceThicknessMapUv
                ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
                  e.iridescenceThicknessMapUv
                : "",
              e.sheenColorMapUv
                ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv
                : "",
              e.sheenRoughnessMapUv
                ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv
                : "",
              e.specularMapUv
                ? "#define SPECULARMAP_UV " + e.specularMapUv
                : "",
              e.specularColorMapUv
                ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv
                : "",
              e.specularIntensityMapUv
                ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv
                : "",
              e.transmissionMapUv
                ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv
                : "",
              e.thicknessMapUv
                ? "#define THICKNESSMAP_UV " + e.thicknessMapUv
                : "",
              e.vertexTangents && e.flatShading === !1
                ? "#define USE_TANGENT"
                : "",
              e.vertexColors ? "#define USE_COLOR" : "",
              e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              e.vertexUv1s ? "#define USE_UV1" : "",
              e.vertexUv2s ? "#define USE_UV2" : "",
              e.vertexUv3s ? "#define USE_UV3" : "",
              e.pointsUvs ? "#define USE_POINTS_UV" : "",
              e.flatShading ? "#define FLAT_SHADED" : "",
              e.skinning ? "#define USE_SKINNING" : "",
              e.morphTargets ? "#define USE_MORPHTARGETS" : "",
              e.morphNormals && e.flatShading === !1
                ? "#define USE_MORPHNORMALS"
                : "",
              e.morphColors ? "#define USE_MORPHCOLORS" : "",
              e.morphTargetsCount > 0
                ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride
                : "",
              e.morphTargetsCount > 0
                ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount
                : "",
              e.doubleSided ? "#define DOUBLE_SIDED" : "",
              e.flipSided ? "#define FLIP_SIDED" : "",
              e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              e.shadowMapEnabled ? "#define " + l : "",
              e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
              e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              e.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "	attribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "	attribute vec3 instanceColor;",
              "#endif",
              "#ifdef USE_INSTANCING_MORPH",
              "	uniform sampler2D morphTexture;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_UV1",
              "	attribute vec2 uv1;",
              "#endif",
              "#ifdef USE_UV2",
              "	attribute vec2 uv2;",
              "#endif",
              "#ifdef USE_UV3",
              "	attribute vec2 uv3;",
              "#endif",
              "#ifdef USE_TANGENT",
              "	attribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "	attribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "	attribute vec3 color;",
              "#endif",
              "#ifdef USE_SKINNING",
              "	attribute vec4 skinIndex;",
              "	attribute vec4 skinWeight;",
              "#endif",
              `
`,
            ].filter(Li).join(`
`)),
            (d = [
              So(e),
              "#define SHADER_TYPE " + e.shaderType,
              "#define SHADER_NAME " + e.shaderName,
              v,
              e.useFog && e.fog ? "#define USE_FOG" : "",
              e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
              e.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
              e.map ? "#define USE_MAP" : "",
              e.matcap ? "#define USE_MATCAP" : "",
              e.envMap ? "#define USE_ENVMAP" : "",
              e.envMap ? "#define " + c : "",
              e.envMap ? "#define " + h : "",
              e.envMap ? "#define " + f : "",
              p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
              p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
              p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
              e.lightMap ? "#define USE_LIGHTMAP" : "",
              e.aoMap ? "#define USE_AOMAP" : "",
              e.bumpMap ? "#define USE_BUMPMAP" : "",
              e.normalMap ? "#define USE_NORMALMAP" : "",
              e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              e.normalMapTangentSpace
                ? "#define USE_NORMALMAP_TANGENTSPACE"
                : "",
              e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              e.anisotropy ? "#define USE_ANISOTROPY" : "",
              e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              e.clearcoat ? "#define USE_CLEARCOAT" : "",
              e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              e.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              e.dispersion ? "#define USE_DISPERSION" : "",
              e.iridescence ? "#define USE_IRIDESCENCE" : "",
              e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              e.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              e.specularMap ? "#define USE_SPECULARMAP" : "",
              e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              e.metalnessMap ? "#define USE_METALNESSMAP" : "",
              e.alphaMap ? "#define USE_ALPHAMAP" : "",
              e.alphaTest ? "#define USE_ALPHATEST" : "",
              e.alphaHash ? "#define USE_ALPHAHASH" : "",
              e.sheen ? "#define USE_SHEEN" : "",
              e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              e.transmission ? "#define USE_TRANSMISSION" : "",
              e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              e.vertexTangents && e.flatShading === !1
                ? "#define USE_TANGENT"
                : "",
              e.vertexColors || e.instancingColor || e.batchingColor
                ? "#define USE_COLOR"
                : "",
              e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              e.vertexUv1s ? "#define USE_UV1" : "",
              e.vertexUv2s ? "#define USE_UV2" : "",
              e.vertexUv3s ? "#define USE_UV3" : "",
              e.pointsUvs ? "#define USE_POINTS_UV" : "",
              e.gradientMap ? "#define USE_GRADIENTMAP" : "",
              e.flatShading ? "#define FLAT_SHADED" : "",
              e.doubleSided ? "#define DOUBLE_SIDED" : "",
              e.flipSided ? "#define FLIP_SIDED" : "",
              e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              e.shadowMapEnabled ? "#define " + l : "",
              e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
              e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              e.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              e.toneMapping !== yn ? "#define TONE_MAPPING" : "",
              e.toneMapping !== yn ? Lt.tonemapping_pars_fragment : "",
              e.toneMapping !== yn ? tp("toneMapping", e.toneMapping) : "",
              e.dithering ? "#define DITHERING" : "",
              e.opaque ? "#define OPAQUE" : "",
              Lt.colorspace_pars_fragment,
              Qf("linearToOutputTexel", e.outputColorSpace),
              ep(),
              e.useDepthPacking
                ? "#define DEPTH_PACKING " + e.depthPacking
                : "",
              `
`,
            ].filter(Li).join(`
`))),
          (a = ia(a)),
          (a = vo(a, e)),
          (a = xo(a, e)),
          (o = ia(o)),
          (o = vo(o, e)),
          (o = xo(o, e)),
          (a = Mo(a)),
          (o = Mo(o)),
          e.isRawShaderMaterial !== !0 &&
            ((T = `#version 300 es
`),
            (u =
              [
                m,
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join(`
`) +
              `
` +
              u),
            (d =
              [
                "#define varying in",
                e.glslVersion === Fa
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                e.glslVersion === Fa ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join(`
`) +
              `
` +
              d));
        const E = T + u + a,
          A = T + d + o,
          O = _o(r, r.VERTEX_SHADER, E),
          P = _o(r, r.FRAGMENT_SHADER, A);
        r.attachShader(M, O),
          r.attachShader(M, P),
          e.index0AttributeName !== void 0
            ? r.bindAttribLocation(M, 0, e.index0AttributeName)
            : e.morphTargets === !0 && r.bindAttribLocation(M, 0, "position"),
          r.linkProgram(M);
        function b(S) {
          if (i.debug.checkShaderErrors) {
            const V = r.getProgramInfoLog(M).trim(),
              z = r.getShaderInfoLog(O).trim(),
              Y = r.getShaderInfoLog(P).trim();
            let j = !0,
              G = !0;
            if (r.getProgramParameter(M, r.LINK_STATUS) === !1)
              if (((j = !1), typeof i.debug.onShaderError == "function"))
                i.debug.onShaderError(r, M, O, P);
              else {
                const K = go(r, O, "vertex"),
                  H = go(r, P, "fragment");
                console.error(
                  "THREE.WebGLProgram: Shader Error " +
                    r.getError() +
                    " - VALIDATE_STATUS " +
                    r.getProgramParameter(M, r.VALIDATE_STATUS) +
                    `

Material Name: ` +
                    S.name +
                    `
Material Type: ` +
                    S.type +
                    `

Program Info Log: ` +
                    V +
                    `
` +
                    K +
                    `
` +
                    H
                );
              }
            else
              V !== ""
                ? console.warn("THREE.WebGLProgram: Program Info Log:", V)
                : (z === "" || Y === "") && (G = !1);
            G &&
              (S.diagnostics = {
                runnable: j,
                programLog: V,
                vertexShader: { log: z, prefix: u },
                fragmentShader: { log: Y, prefix: d },
              });
          }
          r.deleteShader(O),
            r.deleteShader(P),
            (F = new Er(r, M)),
            (tt = rp(r, M));
        }
        let F;
        this.getUniforms = function () {
          return F === void 0 && b(this), F;
        };
        let tt;
        this.getAttributes = function () {
          return tt === void 0 && b(this), tt;
        };
        let _ = e.rendererExtensionParallelShaderCompile === !1;
        return (
          (this.isReady = function () {
            return _ === !1 && (_ = r.getProgramParameter(M, jf)), _;
          }),
          (this.destroy = function () {
            n.releaseStatesOfProgram(this),
              r.deleteProgram(M),
              (this.program = void 0);
          }),
          (this.type = e.shaderType),
          (this.name = e.shaderName),
          (this.id = Zf++),
          (this.cacheKey = t),
          (this.usedTimes = 1),
          (this.program = M),
          (this.vertexShader = O),
          (this.fragmentShader = P),
          this
        );
      }
      let _p = 0;
      class gp {
        constructor() {
          (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(t) {
          const e = t.vertexShader,
            n = t.fragmentShader,
            r = this._getShaderStage(e),
            s = this._getShaderStage(n),
            a = this._getShaderCacheForMaterial(t);
          return (
            a.has(r) === !1 && (a.add(r), r.usedTimes++),
            a.has(s) === !1 && (a.add(s), s.usedTimes++),
            this
          );
        }
        remove(t) {
          const e = this.materialCache.get(t);
          for (const n of e)
            n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
          return this.materialCache.delete(t), this;
        }
        getVertexShaderID(t) {
          return this._getShaderStage(t.vertexShader).id;
        }
        getFragmentShaderID(t) {
          return this._getShaderStage(t.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(t) {
          const e = this.materialCache;
          let n = e.get(t);
          return n === void 0 && ((n = new Set()), e.set(t, n)), n;
        }
        _getShaderStage(t) {
          const e = this.shaderCache;
          let n = e.get(t);
          return n === void 0 && ((n = new vp(t)), e.set(t, n)), n;
        }
      }
      class vp {
        constructor(t) {
          (this.id = _p++), (this.code = t), (this.usedTimes = 0);
        }
      }
      function xp(i, t, e, n, r, s, a) {
        const o = new rl(),
          l = new gp(),
          c = new Set(),
          h = [],
          f = r.logarithmicDepthBuffer,
          p = r.reverseDepthBuffer,
          m = r.vertexTextures;
        let v = r.precision;
        const M = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        };
        function u(_) {
          return c.add(_), _ === 0 ? "uv" : `uv${_}`;
        }
        function d(_, S, V, z, Y) {
          const j = z.fog,
            G = Y.geometry,
            K = _.isMeshStandardMaterial ? z.environment : null,
            H = (_.isMeshStandardMaterial ? e : t).get(_.envMap || K),
            ot = H && H.mapping === Pr ? H.image.height : null,
            lt = M[_.type];
          _.precision !== null &&
            ((v = r.getMaxPrecision(_.precision)),
            v !== _.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                _.precision,
                "not supported, using",
                v,
                "instead."
              ));
          const _t =
              G.morphAttributes.position ||
              G.morphAttributes.normal ||
              G.morphAttributes.color,
            Gt = _t !== void 0 ? _t.length : 0;
          let Yt = 0;
          G.morphAttributes.position !== void 0 && (Yt = 1),
            G.morphAttributes.normal !== void 0 && (Yt = 2),
            G.morphAttributes.color !== void 0 && (Yt = 3);
          let k, $, pt, ct;
          if (lt) {
            const Se = qe[lt];
            (k = Se.vertexShader), ($ = Se.fragmentShader);
          } else
            (k = _.vertexShader),
              ($ = _.fragmentShader),
              l.update(_),
              (pt = l.getVertexShaderID(_)),
              (ct = l.getFragmentShaderID(_));
          const Rt = i.getRenderTarget(),
            Et = Y.isInstancedMesh === !0,
            Nt = Y.isBatchedMesh === !0,
            Kt = !!_.map,
            Ft = !!_.matcap,
            w = !!H,
            Te = !!_.aoMap,
            Ut = !!_.lightMap,
            zt = !!_.bumpMap,
            Tt = !!_.normalMap,
            Jt = !!_.displacementMap,
            wt = !!_.emissiveMap,
            y = !!_.metalnessMap,
            g = !!_.roughnessMap,
            U = _.anisotropy > 0,
            X = _.clearcoat > 0,
            Z = _.dispersion > 0,
            W = _.iridescence > 0,
            gt = _.sheen > 0,
            nt = _.transmission > 0,
            ht = U && !!_.anisotropyMap,
            Ht = X && !!_.clearcoatMap,
            J = X && !!_.clearcoatNormalMap,
            ut = X && !!_.clearcoatRoughnessMap,
            At = W && !!_.iridescenceMap,
            bt = W && !!_.iridescenceThicknessMap,
            dt = gt && !!_.sheenColorMap,
            It = gt && !!_.sheenRoughnessMap,
            Ct = !!_.specularMap,
            $t = !!_.specularColorMap,
            R = !!_.specularIntensityMap,
            st = nt && !!_.transmissionMap,
            B = nt && !!_.thicknessMap,
            q = !!_.gradientMap,
            it = !!_.alphaMap,
            at = _.alphaTest > 0,
            Ot = !!_.alphaHash,
            re = !!_.extensions;
          let Me = yn;
          _.toneMapped &&
            (Rt === null || Rt.isXRRenderTarget === !0) &&
            (Me = i.toneMapping);
          const Vt = {
            shaderID: lt,
            shaderType: _.type,
            shaderName: _.name,
            vertexShader: k,
            fragmentShader: $,
            defines: _.defines,
            customVertexShaderID: pt,
            customFragmentShaderID: ct,
            isRawShaderMaterial: _.isRawShaderMaterial === !0,
            glslVersion: _.glslVersion,
            precision: v,
            batching: Nt,
            batchingColor: Nt && Y._colorsTexture !== null,
            instancing: Et,
            instancingColor: Et && Y.instanceColor !== null,
            instancingMorph: Et && Y.morphTexture !== null,
            supportsVertexTextures: m,
            outputColorSpace:
              Rt === null
                ? i.outputColorSpace
                : Rt.isXRRenderTarget === !0
                ? Rt.texture.colorSpace
                : bn,
            alphaToCoverage: !!_.alphaToCoverage,
            map: Kt,
            matcap: Ft,
            envMap: w,
            envMapMode: w && H.mapping,
            envMapCubeUVHeight: ot,
            aoMap: Te,
            lightMap: Ut,
            bumpMap: zt,
            normalMap: Tt,
            displacementMap: m && Jt,
            emissiveMap: wt,
            normalMapObjectSpace: Tt && _.normalMapType === lc,
            normalMapTangentSpace: Tt && _.normalMapType === Qo,
            metalnessMap: y,
            roughnessMap: g,
            anisotropy: U,
            anisotropyMap: ht,
            clearcoat: X,
            clearcoatMap: Ht,
            clearcoatNormalMap: J,
            clearcoatRoughnessMap: ut,
            dispersion: Z,
            iridescence: W,
            iridescenceMap: At,
            iridescenceThicknessMap: bt,
            sheen: gt,
            sheenColorMap: dt,
            sheenRoughnessMap: It,
            specularMap: Ct,
            specularColorMap: $t,
            specularIntensityMap: R,
            transmission: nt,
            transmissionMap: st,
            thicknessMap: B,
            gradientMap: q,
            opaque:
              _.transparent === !1 &&
              _.blending === ci &&
              _.alphaToCoverage === !1,
            alphaMap: it,
            alphaTest: at,
            alphaHash: Ot,
            combine: _.combine,
            mapUv: Kt && u(_.map.channel),
            aoMapUv: Te && u(_.aoMap.channel),
            lightMapUv: Ut && u(_.lightMap.channel),
            bumpMapUv: zt && u(_.bumpMap.channel),
            normalMapUv: Tt && u(_.normalMap.channel),
            displacementMapUv: Jt && u(_.displacementMap.channel),
            emissiveMapUv: wt && u(_.emissiveMap.channel),
            metalnessMapUv: y && u(_.metalnessMap.channel),
            roughnessMapUv: g && u(_.roughnessMap.channel),
            anisotropyMapUv: ht && u(_.anisotropyMap.channel),
            clearcoatMapUv: Ht && u(_.clearcoatMap.channel),
            clearcoatNormalMapUv: J && u(_.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: ut && u(_.clearcoatRoughnessMap.channel),
            iridescenceMapUv: At && u(_.iridescenceMap.channel),
            iridescenceThicknessMapUv:
              bt && u(_.iridescenceThicknessMap.channel),
            sheenColorMapUv: dt && u(_.sheenColorMap.channel),
            sheenRoughnessMapUv: It && u(_.sheenRoughnessMap.channel),
            specularMapUv: Ct && u(_.specularMap.channel),
            specularColorMapUv: $t && u(_.specularColorMap.channel),
            specularIntensityMapUv: R && u(_.specularIntensityMap.channel),
            transmissionMapUv: st && u(_.transmissionMap.channel),
            thicknessMapUv: B && u(_.thicknessMap.channel),
            alphaMapUv: it && u(_.alphaMap.channel),
            vertexTangents: !!G.attributes.tangent && (Tt || U),
            vertexColors: _.vertexColors,
            vertexAlphas:
              _.vertexColors === !0 &&
              !!G.attributes.color &&
              G.attributes.color.itemSize === 4,
            pointsUvs: Y.isPoints === !0 && !!G.attributes.uv && (Kt || it),
            fog: !!j,
            useFog: _.fog === !0,
            fogExp2: !!j && j.isFogExp2,
            flatShading: _.flatShading === !0,
            sizeAttenuation: _.sizeAttenuation === !0,
            logarithmicDepthBuffer: f,
            reverseDepthBuffer: p,
            skinning: Y.isSkinnedMesh === !0,
            morphTargets: G.morphAttributes.position !== void 0,
            morphNormals: G.morphAttributes.normal !== void 0,
            morphColors: G.morphAttributes.color !== void 0,
            morphTargetsCount: Gt,
            morphTextureStride: Yt,
            numDirLights: S.directional.length,
            numPointLights: S.point.length,
            numSpotLights: S.spot.length,
            numSpotLightMaps: S.spotLightMap.length,
            numRectAreaLights: S.rectArea.length,
            numHemiLights: S.hemi.length,
            numDirLightShadows: S.directionalShadowMap.length,
            numPointLightShadows: S.pointShadowMap.length,
            numSpotLightShadows: S.spotShadowMap.length,
            numSpotLightShadowsWithMaps: S.numSpotLightShadowsWithMaps,
            numLightProbes: S.numLightProbes,
            numClippingPlanes: a.numPlanes,
            numClipIntersection: a.numIntersection,
            dithering: _.dithering,
            shadowMapEnabled: i.shadowMap.enabled && V.length > 0,
            shadowMapType: i.shadowMap.type,
            toneMapping: Me,
            decodeVideoTexture:
              Kt &&
              _.map.isVideoTexture === !0 &&
              Xt.getTransfer(_.map.colorSpace) === te,
            premultipliedAlpha: _.premultipliedAlpha,
            doubleSided: _.side === sn,
            flipSided: _.side === ye,
            useDepthPacking: _.depthPacking >= 0,
            depthPacking: _.depthPacking || 0,
            index0AttributeName: _.index0AttributeName,
            extensionClipCullDistance:
              re &&
              _.extensions.clipCullDistance === !0 &&
              n.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw:
              ((re && _.extensions.multiDraw === !0) || Nt) &&
              n.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: n.has(
              "KHR_parallel_shader_compile"
            ),
            customProgramCacheKey: _.customProgramCacheKey(),
          };
          return (
            (Vt.vertexUv1s = c.has(1)),
            (Vt.vertexUv2s = c.has(2)),
            (Vt.vertexUv3s = c.has(3)),
            c.clear(),
            Vt
          );
        }
        function T(_) {
          const S = [];
          if (
            (_.shaderID
              ? S.push(_.shaderID)
              : (S.push(_.customVertexShaderID),
                S.push(_.customFragmentShaderID)),
            _.defines !== void 0)
          )
            for (const V in _.defines) S.push(V), S.push(_.defines[V]);
          return (
            _.isRawShaderMaterial === !1 &&
              (E(S, _), A(S, _), S.push(i.outputColorSpace)),
            S.push(_.customProgramCacheKey),
            S.join()
          );
        }
        function E(_, S) {
          _.push(S.precision),
            _.push(S.outputColorSpace),
            _.push(S.envMapMode),
            _.push(S.envMapCubeUVHeight),
            _.push(S.mapUv),
            _.push(S.alphaMapUv),
            _.push(S.lightMapUv),
            _.push(S.aoMapUv),
            _.push(S.bumpMapUv),
            _.push(S.normalMapUv),
            _.push(S.displacementMapUv),
            _.push(S.emissiveMapUv),
            _.push(S.metalnessMapUv),
            _.push(S.roughnessMapUv),
            _.push(S.anisotropyMapUv),
            _.push(S.clearcoatMapUv),
            _.push(S.clearcoatNormalMapUv),
            _.push(S.clearcoatRoughnessMapUv),
            _.push(S.iridescenceMapUv),
            _.push(S.iridescenceThicknessMapUv),
            _.push(S.sheenColorMapUv),
            _.push(S.sheenRoughnessMapUv),
            _.push(S.specularMapUv),
            _.push(S.specularColorMapUv),
            _.push(S.specularIntensityMapUv),
            _.push(S.transmissionMapUv),
            _.push(S.thicknessMapUv),
            _.push(S.combine),
            _.push(S.fogExp2),
            _.push(S.sizeAttenuation),
            _.push(S.morphTargetsCount),
            _.push(S.morphAttributeCount),
            _.push(S.numDirLights),
            _.push(S.numPointLights),
            _.push(S.numSpotLights),
            _.push(S.numSpotLightMaps),
            _.push(S.numHemiLights),
            _.push(S.numRectAreaLights),
            _.push(S.numDirLightShadows),
            _.push(S.numPointLightShadows),
            _.push(S.numSpotLightShadows),
            _.push(S.numSpotLightShadowsWithMaps),
            _.push(S.numLightProbes),
            _.push(S.shadowMapType),
            _.push(S.toneMapping),
            _.push(S.numClippingPlanes),
            _.push(S.numClipIntersection),
            _.push(S.depthPacking);
        }
        function A(_, S) {
          o.disableAll(),
            S.supportsVertexTextures && o.enable(0),
            S.instancing && o.enable(1),
            S.instancingColor && o.enable(2),
            S.instancingMorph && o.enable(3),
            S.matcap && o.enable(4),
            S.envMap && o.enable(5),
            S.normalMapObjectSpace && o.enable(6),
            S.normalMapTangentSpace && o.enable(7),
            S.clearcoat && o.enable(8),
            S.iridescence && o.enable(9),
            S.alphaTest && o.enable(10),
            S.vertexColors && o.enable(11),
            S.vertexAlphas && o.enable(12),
            S.vertexUv1s && o.enable(13),
            S.vertexUv2s && o.enable(14),
            S.vertexUv3s && o.enable(15),
            S.vertexTangents && o.enable(16),
            S.anisotropy && o.enable(17),
            S.alphaHash && o.enable(18),
            S.batching && o.enable(19),
            S.dispersion && o.enable(20),
            S.batchingColor && o.enable(21),
            _.push(o.mask),
            o.disableAll(),
            S.fog && o.enable(0),
            S.useFog && o.enable(1),
            S.flatShading && o.enable(2),
            S.logarithmicDepthBuffer && o.enable(3),
            S.reverseDepthBuffer && o.enable(4),
            S.skinning && o.enable(5),
            S.morphTargets && o.enable(6),
            S.morphNormals && o.enable(7),
            S.morphColors && o.enable(8),
            S.premultipliedAlpha && o.enable(9),
            S.shadowMapEnabled && o.enable(10),
            S.doubleSided && o.enable(11),
            S.flipSided && o.enable(12),
            S.useDepthPacking && o.enable(13),
            S.dithering && o.enable(14),
            S.transmission && o.enable(15),
            S.sheen && o.enable(16),
            S.opaque && o.enable(17),
            S.pointsUvs && o.enable(18),
            S.decodeVideoTexture && o.enable(19),
            S.alphaToCoverage && o.enable(20),
            _.push(o.mask);
        }
        function O(_) {
          const S = M[_.type];
          let V;
          if (S) {
            const z = qe[S];
            V = th.clone(z.uniforms);
          } else V = _.uniforms;
          return V;
        }
        function P(_, S) {
          let V;
          for (let z = 0, Y = h.length; z < Y; z++) {
            const j = h[z];
            if (j.cacheKey === S) {
              (V = j), ++V.usedTimes;
              break;
            }
          }
          return V === void 0 && ((V = new mp(i, S, _, s)), h.push(V)), V;
        }
        function b(_) {
          if (--_.usedTimes === 0) {
            const S = h.indexOf(_);
            (h[S] = h[h.length - 1]), h.pop(), _.destroy();
          }
        }
        function F(_) {
          l.remove(_);
        }
        function tt() {
          l.dispose();
        }
        return {
          getParameters: d,
          getProgramCacheKey: T,
          getUniforms: O,
          acquireProgram: P,
          releaseProgram: b,
          releaseShaderCache: F,
          programs: h,
          dispose: tt,
        };
      }
      function Mp() {
        let i = new WeakMap();
        function t(a) {
          return i.has(a);
        }
        function e(a) {
          let o = i.get(a);
          return o === void 0 && ((o = {}), i.set(a, o)), o;
        }
        function n(a) {
          i.delete(a);
        }
        function r(a, o, l) {
          i.get(a)[o] = l;
        }
        function s() {
          i = new WeakMap();
        }
        return { has: t, get: e, remove: n, update: r, dispose: s };
      }
      function Sp(i, t) {
        return i.groupOrder !== t.groupOrder
          ? i.groupOrder - t.groupOrder
          : i.renderOrder !== t.renderOrder
          ? i.renderOrder - t.renderOrder
          : i.material.id !== t.material.id
          ? i.material.id - t.material.id
          : i.z !== t.z
          ? i.z - t.z
          : i.id - t.id;
      }
      function Eo(i, t) {
        return i.groupOrder !== t.groupOrder
          ? i.groupOrder - t.groupOrder
          : i.renderOrder !== t.renderOrder
          ? i.renderOrder - t.renderOrder
          : i.z !== t.z
          ? t.z - i.z
          : i.id - t.id;
      }
      function yo() {
        const i = [];
        let t = 0;
        const e = [],
          n = [],
          r = [];
        function s() {
          (t = 0), (e.length = 0), (n.length = 0), (r.length = 0);
        }
        function a(f, p, m, v, M, u) {
          let d = i[t];
          return (
            d === void 0
              ? ((d = {
                  id: f.id,
                  object: f,
                  geometry: p,
                  material: m,
                  groupOrder: v,
                  renderOrder: f.renderOrder,
                  z: M,
                  group: u,
                }),
                (i[t] = d))
              : ((d.id = f.id),
                (d.object = f),
                (d.geometry = p),
                (d.material = m),
                (d.groupOrder = v),
                (d.renderOrder = f.renderOrder),
                (d.z = M),
                (d.group = u)),
            t++,
            d
          );
        }
        function o(f, p, m, v, M, u) {
          const d = a(f, p, m, v, M, u);
          m.transmission > 0
            ? n.push(d)
            : m.transparent === !0
            ? r.push(d)
            : e.push(d);
        }
        function l(f, p, m, v, M, u) {
          const d = a(f, p, m, v, M, u);
          m.transmission > 0
            ? n.unshift(d)
            : m.transparent === !0
            ? r.unshift(d)
            : e.unshift(d);
        }
        function c(f, p) {
          e.length > 1 && e.sort(f || Sp),
            n.length > 1 && n.sort(p || Eo),
            r.length > 1 && r.sort(p || Eo);
        }
        function h() {
          for (let f = t, p = i.length; f < p; f++) {
            const m = i[f];
            if (m.id === null) break;
            (m.id = null),
              (m.object = null),
              (m.geometry = null),
              (m.material = null),
              (m.group = null);
          }
        }
        return {
          opaque: e,
          transmissive: n,
          transparent: r,
          init: s,
          push: o,
          unshift: l,
          finish: h,
          sort: c,
        };
      }
      function Ep() {
        let i = new WeakMap();
        function t(n, r) {
          const s = i.get(n);
          let a;
          return (
            s === void 0
              ? ((a = new yo()), i.set(n, [a]))
              : r >= s.length
              ? ((a = new yo()), s.push(a))
              : (a = s[r]),
            a
          );
        }
        function e() {
          i = new WeakMap();
        }
        return { get: t, dispose: e };
      }
      function yp() {
        const i = {};
        return {
          get: function (t) {
            if (i[t.id] !== void 0) return i[t.id];
            let e;
            switch (t.type) {
              case "DirectionalLight":
                e = { direction: new D(), color: new Bt() };
                break;
              case "SpotLight":
                e = {
                  position: new D(),
                  direction: new D(),
                  color: new Bt(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                e = {
                  position: new D(),
                  color: new Bt(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                e = {
                  direction: new D(),
                  skyColor: new Bt(),
                  groundColor: new Bt(),
                };
                break;
              case "RectAreaLight":
                e = {
                  color: new Bt(),
                  position: new D(),
                  halfWidth: new D(),
                  halfHeight: new D(),
                };
                break;
            }
            return (i[t.id] = e), e;
          },
        };
      }
      function Tp() {
        const i = {};
        return {
          get: function (t) {
            if (i[t.id] !== void 0) return i[t.id];
            let e;
            switch (t.type) {
              case "DirectionalLight":
                e = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Pt(),
                };
                break;
              case "SpotLight":
                e = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Pt(),
                };
                break;
              case "PointLight":
                e = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Pt(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
                break;
            }
            return (i[t.id] = e), e;
          },
        };
      }
      let Ap = 0;
      function bp(i, t) {
        return (
          (t.castShadow ? 2 : 0) -
          (i.castShadow ? 2 : 0) +
          (t.map ? 1 : 0) -
          (i.map ? 1 : 0)
        );
      }
      function wp(i) {
        const t = new yp(),
          e = Tp(),
          n = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
              numSpotMaps: -1,
              numLightProbes: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0,
          };
        for (let c = 0; c < 9; c++) n.probe.push(new D());
        const r = new D(),
          s = new ee(),
          a = new ee();
        function o(c) {
          let h = 0,
            f = 0,
            p = 0;
          for (let tt = 0; tt < 9; tt++) n.probe[tt].set(0, 0, 0);
          let m = 0,
            v = 0,
            M = 0,
            u = 0,
            d = 0,
            T = 0,
            E = 0,
            A = 0,
            O = 0,
            P = 0,
            b = 0;
          c.sort(bp);
          for (let tt = 0, _ = c.length; tt < _; tt++) {
            const S = c[tt],
              V = S.color,
              z = S.intensity,
              Y = S.distance,
              j = S.shadow && S.shadow.map ? S.shadow.map.texture : null;
            if (S.isAmbientLight)
              (h += V.r * z), (f += V.g * z), (p += V.b * z);
            else if (S.isLightProbe) {
              for (let G = 0; G < 9; G++)
                n.probe[G].addScaledVector(S.sh.coefficients[G], z);
              b++;
            } else if (S.isDirectionalLight) {
              const G = t.get(S);
              if (
                (G.color.copy(S.color).multiplyScalar(S.intensity),
                S.castShadow)
              ) {
                const K = S.shadow,
                  H = e.get(S);
                (H.shadowIntensity = K.intensity),
                  (H.shadowBias = K.bias),
                  (H.shadowNormalBias = K.normalBias),
                  (H.shadowRadius = K.radius),
                  (H.shadowMapSize = K.mapSize),
                  (n.directionalShadow[m] = H),
                  (n.directionalShadowMap[m] = j),
                  (n.directionalShadowMatrix[m] = S.shadow.matrix),
                  T++;
              }
              (n.directional[m] = G), m++;
            } else if (S.isSpotLight) {
              const G = t.get(S);
              G.position.setFromMatrixPosition(S.matrixWorld),
                G.color.copy(V).multiplyScalar(z),
                (G.distance = Y),
                (G.coneCos = Math.cos(S.angle)),
                (G.penumbraCos = Math.cos(S.angle * (1 - S.penumbra))),
                (G.decay = S.decay),
                (n.spot[M] = G);
              const K = S.shadow;
              if (
                (S.map &&
                  ((n.spotLightMap[O] = S.map),
                  O++,
                  K.updateMatrices(S),
                  S.castShadow && P++),
                (n.spotLightMatrix[M] = K.matrix),
                S.castShadow)
              ) {
                const H = e.get(S);
                (H.shadowIntensity = K.intensity),
                  (H.shadowBias = K.bias),
                  (H.shadowNormalBias = K.normalBias),
                  (H.shadowRadius = K.radius),
                  (H.shadowMapSize = K.mapSize),
                  (n.spotShadow[M] = H),
                  (n.spotShadowMap[M] = j),
                  A++;
              }
              M++;
            } else if (S.isRectAreaLight) {
              const G = t.get(S);
              G.color.copy(V).multiplyScalar(z),
                G.halfWidth.set(S.width * 0.5, 0, 0),
                G.halfHeight.set(0, S.height * 0.5, 0),
                (n.rectArea[u] = G),
                u++;
            } else if (S.isPointLight) {
              const G = t.get(S);
              if (
                (G.color.copy(S.color).multiplyScalar(S.intensity),
                (G.distance = S.distance),
                (G.decay = S.decay),
                S.castShadow)
              ) {
                const K = S.shadow,
                  H = e.get(S);
                (H.shadowIntensity = K.intensity),
                  (H.shadowBias = K.bias),
                  (H.shadowNormalBias = K.normalBias),
                  (H.shadowRadius = K.radius),
                  (H.shadowMapSize = K.mapSize),
                  (H.shadowCameraNear = K.camera.near),
                  (H.shadowCameraFar = K.camera.far),
                  (n.pointShadow[v] = H),
                  (n.pointShadowMap[v] = j),
                  (n.pointShadowMatrix[v] = S.shadow.matrix),
                  E++;
              }
              (n.point[v] = G), v++;
            } else if (S.isHemisphereLight) {
              const G = t.get(S);
              G.skyColor.copy(S.color).multiplyScalar(z),
                G.groundColor.copy(S.groundColor).multiplyScalar(z),
                (n.hemi[d] = G),
                d++;
            }
          }
          u > 0 &&
            (i.has("OES_texture_float_linear") === !0
              ? ((n.rectAreaLTC1 = et.LTC_FLOAT_1),
                (n.rectAreaLTC2 = et.LTC_FLOAT_2))
              : ((n.rectAreaLTC1 = et.LTC_HALF_1),
                (n.rectAreaLTC2 = et.LTC_HALF_2))),
            (n.ambient[0] = h),
            (n.ambient[1] = f),
            (n.ambient[2] = p);
          const F = n.hash;
          (F.directionalLength !== m ||
            F.pointLength !== v ||
            F.spotLength !== M ||
            F.rectAreaLength !== u ||
            F.hemiLength !== d ||
            F.numDirectionalShadows !== T ||
            F.numPointShadows !== E ||
            F.numSpotShadows !== A ||
            F.numSpotMaps !== O ||
            F.numLightProbes !== b) &&
            ((n.directional.length = m),
            (n.spot.length = M),
            (n.rectArea.length = u),
            (n.point.length = v),
            (n.hemi.length = d),
            (n.directionalShadow.length = T),
            (n.directionalShadowMap.length = T),
            (n.pointShadow.length = E),
            (n.pointShadowMap.length = E),
            (n.spotShadow.length = A),
            (n.spotShadowMap.length = A),
            (n.directionalShadowMatrix.length = T),
            (n.pointShadowMatrix.length = E),
            (n.spotLightMatrix.length = A + O - P),
            (n.spotLightMap.length = O),
            (n.numSpotLightShadowsWithMaps = P),
            (n.numLightProbes = b),
            (F.directionalLength = m),
            (F.pointLength = v),
            (F.spotLength = M),
            (F.rectAreaLength = u),
            (F.hemiLength = d),
            (F.numDirectionalShadows = T),
            (F.numPointShadows = E),
            (F.numSpotShadows = A),
            (F.numSpotMaps = O),
            (F.numLightProbes = b),
            (n.version = Ap++));
        }
        function l(c, h) {
          let f = 0,
            p = 0,
            m = 0,
            v = 0,
            M = 0;
          const u = h.matrixWorldInverse;
          for (let d = 0, T = c.length; d < T; d++) {
            const E = c[d];
            if (E.isDirectionalLight) {
              const A = n.directional[f];
              A.direction.setFromMatrixPosition(E.matrixWorld),
                r.setFromMatrixPosition(E.target.matrixWorld),
                A.direction.sub(r),
                A.direction.transformDirection(u),
                f++;
            } else if (E.isSpotLight) {
              const A = n.spot[m];
              A.position.setFromMatrixPosition(E.matrixWorld),
                A.position.applyMatrix4(u),
                A.direction.setFromMatrixPosition(E.matrixWorld),
                r.setFromMatrixPosition(E.target.matrixWorld),
                A.direction.sub(r),
                A.direction.transformDirection(u),
                m++;
            } else if (E.isRectAreaLight) {
              const A = n.rectArea[v];
              A.position.setFromMatrixPosition(E.matrixWorld),
                A.position.applyMatrix4(u),
                a.identity(),
                s.copy(E.matrixWorld),
                s.premultiply(u),
                a.extractRotation(s),
                A.halfWidth.set(E.width * 0.5, 0, 0),
                A.halfHeight.set(0, E.height * 0.5, 0),
                A.halfWidth.applyMatrix4(a),
                A.halfHeight.applyMatrix4(a),
                v++;
            } else if (E.isPointLight) {
              const A = n.point[p];
              A.position.setFromMatrixPosition(E.matrixWorld),
                A.position.applyMatrix4(u),
                p++;
            } else if (E.isHemisphereLight) {
              const A = n.hemi[M];
              A.direction.setFromMatrixPosition(E.matrixWorld),
                A.direction.transformDirection(u),
                M++;
            }
          }
        }
        return { setup: o, setupView: l, state: n };
      }
      function To(i) {
        const t = new wp(i),
          e = [],
          n = [];
        function r(h) {
          (c.camera = h), (e.length = 0), (n.length = 0);
        }
        function s(h) {
          e.push(h);
        }
        function a(h) {
          n.push(h);
        }
        function o() {
          t.setup(e);
        }
        function l(h) {
          t.setupView(e, h);
        }
        const c = {
          lightsArray: e,
          shadowsArray: n,
          camera: null,
          lights: t,
          transmissionRenderTarget: {},
        };
        return {
          init: r,
          state: c,
          setupLights: o,
          setupLightsView: l,
          pushLight: s,
          pushShadow: a,
        };
      }
      function Rp(i) {
        let t = new WeakMap();
        function e(r, s = 0) {
          const a = t.get(r);
          let o;
          return (
            a === void 0
              ? ((o = new To(i)), t.set(r, [o]))
              : s >= a.length
              ? ((o = new To(i)), a.push(o))
              : (o = a[s]),
            o
          );
        }
        function n() {
          t = new WeakMap();
        }
        return { get: e, dispose: n };
      }
      class Cp extends Si {
        constructor(t) {
          super(),
            (this.isMeshDepthMaterial = !0),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = ac),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.depthPacking = t.depthPacking),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            this
          );
        }
      }
      class Pp extends Si {
        constructor(t) {
          super(),
            (this.isMeshDistanceMaterial = !0),
            (this.type = "MeshDistanceMaterial"),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            this
          );
        }
      }
      const Lp = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
        Dp = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
      function Up(i, t, e) {
        let n = new ma();
        const r = new Pt(),
          s = new Pt(),
          a = new Zt(),
          o = new Cp({ depthPacking: oc }),
          l = new Pp(),
          c = {},
          h = e.maxTextureSize,
          f = { [Tn]: ye, [ye]: Tn, [sn]: sn },
          p = new An({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new Pt() },
              radius: { value: 4 },
            },
            vertexShader: Lp,
            fragmentShader: Dp,
          }),
          m = p.clone();
        m.defines.HORIZONTAL_PASS = 1;
        const v = new cn();
        v.setAttribute(
          "position",
          new Ke(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const M = new Fe(v, p),
          u = this;
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = zo);
        let d = this.type;
        this.render = function (P, b, F) {
          if (
            u.enabled === !1 ||
            (u.autoUpdate === !1 && u.needsUpdate === !1) ||
            P.length === 0
          )
            return;
          const tt = i.getRenderTarget(),
            _ = i.getActiveCubeFace(),
            S = i.getActiveMipmapLevel(),
            V = i.state;
          V.setBlending(En),
            V.buffers.color.setClear(1, 1, 1, 1),
            V.buffers.depth.setTest(!0),
            V.setScissorTest(!1);
          const z = d !== nn && this.type === nn,
            Y = d === nn && this.type !== nn;
          for (let j = 0, G = P.length; j < G; j++) {
            const K = P[j],
              H = K.shadow;
            if (H === void 0) {
              console.warn("THREE.WebGLShadowMap:", K, "has no shadow.");
              continue;
            }
            if (H.autoUpdate === !1 && H.needsUpdate === !1) continue;
            r.copy(H.mapSize);
            const ot = H.getFrameExtents();
            if (
              (r.multiply(ot),
              s.copy(H.mapSize),
              (r.x > h || r.y > h) &&
                (r.x > h &&
                  ((s.x = Math.floor(h / ot.x)),
                  (r.x = s.x * ot.x),
                  (H.mapSize.x = s.x)),
                r.y > h &&
                  ((s.y = Math.floor(h / ot.y)),
                  (r.y = s.y * ot.y),
                  (H.mapSize.y = s.y))),
              H.map === null || z === !0 || Y === !0)
            ) {
              const _t =
                this.type !== nn ? { minFilter: Ne, magFilter: Ne } : {};
              H.map !== null && H.map.dispose(),
                (H.map = new Gn(r.x, r.y, _t)),
                (H.map.texture.name = K.name + ".shadowMap"),
                H.camera.updateProjectionMatrix();
            }
            i.setRenderTarget(H.map), i.clear();
            const lt = H.getViewportCount();
            for (let _t = 0; _t < lt; _t++) {
              const Gt = H.getViewport(_t);
              a.set(s.x * Gt.x, s.y * Gt.y, s.x * Gt.z, s.y * Gt.w),
                V.viewport(a),
                H.updateMatrices(K, _t),
                (n = H.getFrustum()),
                A(b, F, H.camera, K, this.type);
            }
            H.isPointLightShadow !== !0 && this.type === nn && T(H, F),
              (H.needsUpdate = !1);
          }
          (d = this.type), (u.needsUpdate = !1), i.setRenderTarget(tt, _, S);
        };
        function T(P, b) {
          const F = t.update(M);
          p.defines.VSM_SAMPLES !== P.blurSamples &&
            ((p.defines.VSM_SAMPLES = P.blurSamples),
            (m.defines.VSM_SAMPLES = P.blurSamples),
            (p.needsUpdate = !0),
            (m.needsUpdate = !0)),
            P.mapPass === null && (P.mapPass = new Gn(r.x, r.y)),
            (p.uniforms.shadow_pass.value = P.map.texture),
            (p.uniforms.resolution.value = P.mapSize),
            (p.uniforms.radius.value = P.radius),
            i.setRenderTarget(P.mapPass),
            i.clear(),
            i.renderBufferDirect(b, null, F, p, M, null),
            (m.uniforms.shadow_pass.value = P.mapPass.texture),
            (m.uniforms.resolution.value = P.mapSize),
            (m.uniforms.radius.value = P.radius),
            i.setRenderTarget(P.map),
            i.clear(),
            i.renderBufferDirect(b, null, F, m, M, null);
        }
        function E(P, b, F, tt) {
          let _ = null;
          const S =
            F.isPointLight === !0
              ? P.customDistanceMaterial
              : P.customDepthMaterial;
          if (S !== void 0) _ = S;
          else if (
            ((_ = F.isPointLight === !0 ? l : o),
            (i.localClippingEnabled &&
              b.clipShadows === !0 &&
              Array.isArray(b.clippingPlanes) &&
              b.clippingPlanes.length !== 0) ||
              (b.displacementMap && b.displacementScale !== 0) ||
              (b.alphaMap && b.alphaTest > 0) ||
              (b.map && b.alphaTest > 0))
          ) {
            const V = _.uuid,
              z = b.uuid;
            let Y = c[V];
            Y === void 0 && ((Y = {}), (c[V] = Y));
            let j = Y[z];
            j === void 0 &&
              ((j = _.clone()), (Y[z] = j), b.addEventListener("dispose", O)),
              (_ = j);
          }
          if (
            ((_.visible = b.visible),
            (_.wireframe = b.wireframe),
            tt === nn
              ? (_.side = b.shadowSide !== null ? b.shadowSide : b.side)
              : (_.side = b.shadowSide !== null ? b.shadowSide : f[b.side]),
            (_.alphaMap = b.alphaMap),
            (_.alphaTest = b.alphaTest),
            (_.map = b.map),
            (_.clipShadows = b.clipShadows),
            (_.clippingPlanes = b.clippingPlanes),
            (_.clipIntersection = b.clipIntersection),
            (_.displacementMap = b.displacementMap),
            (_.displacementScale = b.displacementScale),
            (_.displacementBias = b.displacementBias),
            (_.wireframeLinewidth = b.wireframeLinewidth),
            (_.linewidth = b.linewidth),
            F.isPointLight === !0 && _.isMeshDistanceMaterial === !0)
          ) {
            const V = i.properties.get(_);
            V.light = F;
          }
          return _;
        }
        function A(P, b, F, tt, _) {
          if (P.visible === !1) return;
          if (
            P.layers.test(b.layers) &&
            (P.isMesh || P.isLine || P.isPoints) &&
            (P.castShadow || (P.receiveShadow && _ === nn)) &&
            (!P.frustumCulled || n.intersectsObject(P))
          ) {
            P.modelViewMatrix.multiplyMatrices(
              F.matrixWorldInverse,
              P.matrixWorld
            );
            const z = t.update(P),
              Y = P.material;
            if (Array.isArray(Y)) {
              const j = z.groups;
              for (let G = 0, K = j.length; G < K; G++) {
                const H = j[G],
                  ot = Y[H.materialIndex];
                if (ot && ot.visible) {
                  const lt = E(P, ot, tt, _);
                  P.onBeforeShadow(i, P, b, F, z, lt, H),
                    i.renderBufferDirect(F, null, z, lt, P, H),
                    P.onAfterShadow(i, P, b, F, z, lt, H);
                }
              }
            } else if (Y.visible) {
              const j = E(P, Y, tt, _);
              P.onBeforeShadow(i, P, b, F, z, j, null),
                i.renderBufferDirect(F, null, z, j, P, null),
                P.onAfterShadow(i, P, b, F, z, j, null);
            }
          }
          const V = P.children;
          for (let z = 0, Y = V.length; z < Y; z++) A(V[z], b, F, tt, _);
        }
        function O(P) {
          P.target.removeEventListener("dispose", O);
          for (const F in c) {
            const tt = c[F],
              _ = P.target.uuid;
            _ in tt && (tt[_].dispose(), delete tt[_]);
          }
        }
      }
      const Ip = {
        [Ms]: Ss,
        [Es]: As,
        [ys]: bs,
        [pi]: Ts,
        [Ss]: Ms,
        [As]: Es,
        [bs]: ys,
        [Ts]: pi,
      };
      function Np(i) {
        function t() {
          let R = !1;
          const st = new Zt();
          let B = null;
          const q = new Zt(0, 0, 0, 0);
          return {
            setMask: function (it) {
              B !== it && !R && (i.colorMask(it, it, it, it), (B = it));
            },
            setLocked: function (it) {
              R = it;
            },
            setClear: function (it, at, Ot, re, Me) {
              Me === !0 && ((it *= re), (at *= re), (Ot *= re)),
                st.set(it, at, Ot, re),
                q.equals(st) === !1 &&
                  (i.clearColor(it, at, Ot, re), q.copy(st));
            },
            reset: function () {
              (R = !1), (B = null), q.set(-1, 0, 0, 0);
            },
          };
        }
        function e() {
          let R = !1,
            st = !1,
            B = null,
            q = null,
            it = null;
          return {
            setReversed: function (at) {
              st = at;
            },
            setTest: function (at) {
              at ? pt(i.DEPTH_TEST) : ct(i.DEPTH_TEST);
            },
            setMask: function (at) {
              B !== at && !R && (i.depthMask(at), (B = at));
            },
            setFunc: function (at) {
              if ((st && (at = Ip[at]), q !== at)) {
                switch (at) {
                  case Ms:
                    i.depthFunc(i.NEVER);
                    break;
                  case Ss:
                    i.depthFunc(i.ALWAYS);
                    break;
                  case Es:
                    i.depthFunc(i.LESS);
                    break;
                  case pi:
                    i.depthFunc(i.LEQUAL);
                    break;
                  case ys:
                    i.depthFunc(i.EQUAL);
                    break;
                  case Ts:
                    i.depthFunc(i.GEQUAL);
                    break;
                  case As:
                    i.depthFunc(i.GREATER);
                    break;
                  case bs:
                    i.depthFunc(i.NOTEQUAL);
                    break;
                  default:
                    i.depthFunc(i.LEQUAL);
                }
                q = at;
              }
            },
            setLocked: function (at) {
              R = at;
            },
            setClear: function (at) {
              it !== at && (i.clearDepth(at), (it = at));
            },
            reset: function () {
              (R = !1), (B = null), (q = null), (it = null);
            },
          };
        }
        function n() {
          let R = !1,
            st = null,
            B = null,
            q = null,
            it = null,
            at = null,
            Ot = null,
            re = null,
            Me = null;
          return {
            setTest: function (Vt) {
              R || (Vt ? pt(i.STENCIL_TEST) : ct(i.STENCIL_TEST));
            },
            setMask: function (Vt) {
              st !== Vt && !R && (i.stencilMask(Vt), (st = Vt));
            },
            setFunc: function (Vt, Se, Ze) {
              (B !== Vt || q !== Se || it !== Ze) &&
                (i.stencilFunc(Vt, Se, Ze), (B = Vt), (q = Se), (it = Ze));
            },
            setOp: function (Vt, Se, Ze) {
              (at !== Vt || Ot !== Se || re !== Ze) &&
                (i.stencilOp(Vt, Se, Ze), (at = Vt), (Ot = Se), (re = Ze));
            },
            setLocked: function (Vt) {
              R = Vt;
            },
            setClear: function (Vt) {
              Me !== Vt && (i.clearStencil(Vt), (Me = Vt));
            },
            reset: function () {
              (R = !1),
                (st = null),
                (B = null),
                (q = null),
                (it = null),
                (at = null),
                (Ot = null),
                (re = null),
                (Me = null);
            },
          };
        }
        const r = new t(),
          s = new e(),
          a = new n(),
          o = new WeakMap(),
          l = new WeakMap();
        let c = {},
          h = {},
          f = new WeakMap(),
          p = [],
          m = null,
          v = !1,
          M = null,
          u = null,
          d = null,
          T = null,
          E = null,
          A = null,
          O = null,
          P = new Bt(0, 0, 0),
          b = 0,
          F = !1,
          tt = null,
          _ = null,
          S = null,
          V = null,
          z = null;
        const Y = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let j = !1,
          G = 0;
        const K = i.getParameter(i.VERSION);
        K.indexOf("WebGL") !== -1
          ? ((G = parseFloat(/^WebGL (\d)/.exec(K)[1])), (j = G >= 1))
          : K.indexOf("OpenGL ES") !== -1 &&
            ((G = parseFloat(/^OpenGL ES (\d)/.exec(K)[1])), (j = G >= 2));
        let H = null,
          ot = {};
        const lt = i.getParameter(i.SCISSOR_BOX),
          _t = i.getParameter(i.VIEWPORT),
          Gt = new Zt().fromArray(lt),
          Yt = new Zt().fromArray(_t);
        function k(R, st, B, q) {
          const it = new Uint8Array(4),
            at = i.createTexture();
          i.bindTexture(R, at),
            i.texParameteri(R, i.TEXTURE_MIN_FILTER, i.NEAREST),
            i.texParameteri(R, i.TEXTURE_MAG_FILTER, i.NEAREST);
          for (let Ot = 0; Ot < B; Ot++)
            R === i.TEXTURE_3D || R === i.TEXTURE_2D_ARRAY
              ? i.texImage3D(
                  st,
                  0,
                  i.RGBA,
                  1,
                  1,
                  q,
                  0,
                  i.RGBA,
                  i.UNSIGNED_BYTE,
                  it
                )
              : i.texImage2D(
                  st + Ot,
                  0,
                  i.RGBA,
                  1,
                  1,
                  0,
                  i.RGBA,
                  i.UNSIGNED_BYTE,
                  it
                );
          return at;
        }
        const $ = {};
        ($[i.TEXTURE_2D] = k(i.TEXTURE_2D, i.TEXTURE_2D, 1)),
          ($[i.TEXTURE_CUBE_MAP] = k(
            i.TEXTURE_CUBE_MAP,
            i.TEXTURE_CUBE_MAP_POSITIVE_X,
            6
          )),
          ($[i.TEXTURE_2D_ARRAY] = k(
            i.TEXTURE_2D_ARRAY,
            i.TEXTURE_2D_ARRAY,
            1,
            1
          )),
          ($[i.TEXTURE_3D] = k(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1)),
          r.setClear(0, 0, 0, 1),
          s.setClear(1),
          a.setClear(0),
          pt(i.DEPTH_TEST),
          s.setFunc(pi),
          Ut(!1),
          zt(Pa),
          pt(i.CULL_FACE),
          w(En);
        function pt(R) {
          c[R] !== !0 && (i.enable(R), (c[R] = !0));
        }
        function ct(R) {
          c[R] !== !1 && (i.disable(R), (c[R] = !1));
        }
        function Rt(R, st) {
          return h[R] !== st
            ? (i.bindFramebuffer(R, st),
              (h[R] = st),
              R === i.DRAW_FRAMEBUFFER && (h[i.FRAMEBUFFER] = st),
              R === i.FRAMEBUFFER && (h[i.DRAW_FRAMEBUFFER] = st),
              !0)
            : !1;
        }
        function Et(R, st) {
          let B = p,
            q = !1;
          if (R) {
            (B = f.get(st)), B === void 0 && ((B = []), f.set(st, B));
            const it = R.textures;
            if (B.length !== it.length || B[0] !== i.COLOR_ATTACHMENT0) {
              for (let at = 0, Ot = it.length; at < Ot; at++)
                B[at] = i.COLOR_ATTACHMENT0 + at;
              (B.length = it.length), (q = !0);
            }
          } else B[0] !== i.BACK && ((B[0] = i.BACK), (q = !0));
          q && i.drawBuffers(B);
        }
        function Nt(R) {
          return m !== R ? (i.useProgram(R), (m = R), !0) : !1;
        }
        const Kt = {
          [Fn]: i.FUNC_ADD,
          [Ul]: i.FUNC_SUBTRACT,
          [Il]: i.FUNC_REVERSE_SUBTRACT,
        };
        (Kt[Nl] = i.MIN), (Kt[Fl] = i.MAX);
        const Ft = {
          [Ol]: i.ZERO,
          [Bl]: i.ONE,
          [zl]: i.SRC_COLOR,
          [vs]: i.SRC_ALPHA,
          [Xl]: i.SRC_ALPHA_SATURATE,
          [kl]: i.DST_COLOR,
          [Gl]: i.DST_ALPHA,
          [Hl]: i.ONE_MINUS_SRC_COLOR,
          [xs]: i.ONE_MINUS_SRC_ALPHA,
          [Wl]: i.ONE_MINUS_DST_COLOR,
          [Vl]: i.ONE_MINUS_DST_ALPHA,
          [Yl]: i.CONSTANT_COLOR,
          [ql]: i.ONE_MINUS_CONSTANT_COLOR,
          [Kl]: i.CONSTANT_ALPHA,
          [jl]: i.ONE_MINUS_CONSTANT_ALPHA,
        };
        function w(R, st, B, q, it, at, Ot, re, Me, Vt) {
          if (R === En) {
            v === !0 && (ct(i.BLEND), (v = !1));
            return;
          }
          if ((v === !1 && (pt(i.BLEND), (v = !0)), R !== Dl)) {
            if (R !== M || Vt !== F) {
              if (
                ((u !== Fn || E !== Fn) &&
                  (i.blendEquation(i.FUNC_ADD), (u = Fn), (E = Fn)),
                Vt)
              )
                switch (R) {
                  case ci:
                    i.blendFuncSeparate(
                      i.ONE,
                      i.ONE_MINUS_SRC_ALPHA,
                      i.ONE,
                      i.ONE_MINUS_SRC_ALPHA
                    );
                    break;
                  case La:
                    i.blendFunc(i.ONE, i.ONE);
                    break;
                  case Da:
                    i.blendFuncSeparate(
                      i.ZERO,
                      i.ONE_MINUS_SRC_COLOR,
                      i.ZERO,
                      i.ONE
                    );
                    break;
                  case Ua:
                    i.blendFuncSeparate(
                      i.ZERO,
                      i.SRC_COLOR,
                      i.ZERO,
                      i.SRC_ALPHA
                    );
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", R);
                    break;
                }
              else
                switch (R) {
                  case ci:
                    i.blendFuncSeparate(
                      i.SRC_ALPHA,
                      i.ONE_MINUS_SRC_ALPHA,
                      i.ONE,
                      i.ONE_MINUS_SRC_ALPHA
                    );
                    break;
                  case La:
                    i.blendFunc(i.SRC_ALPHA, i.ONE);
                    break;
                  case Da:
                    i.blendFuncSeparate(
                      i.ZERO,
                      i.ONE_MINUS_SRC_COLOR,
                      i.ZERO,
                      i.ONE
                    );
                    break;
                  case Ua:
                    i.blendFunc(i.ZERO, i.SRC_COLOR);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", R);
                    break;
                }
              (d = null),
                (T = null),
                (A = null),
                (O = null),
                P.set(0, 0, 0),
                (b = 0),
                (M = R),
                (F = Vt);
            }
            return;
          }
          (it = it || st),
            (at = at || B),
            (Ot = Ot || q),
            (st !== u || it !== E) &&
              (i.blendEquationSeparate(Kt[st], Kt[it]), (u = st), (E = it)),
            (B !== d || q !== T || at !== A || Ot !== O) &&
              (i.blendFuncSeparate(Ft[B], Ft[q], Ft[at], Ft[Ot]),
              (d = B),
              (T = q),
              (A = at),
              (O = Ot)),
            (re.equals(P) === !1 || Me !== b) &&
              (i.blendColor(re.r, re.g, re.b, Me), P.copy(re), (b = Me)),
            (M = R),
            (F = !1);
        }
        function Te(R, st) {
          R.side === sn ? ct(i.CULL_FACE) : pt(i.CULL_FACE);
          let B = R.side === ye;
          st && (B = !B),
            Ut(B),
            R.blending === ci && R.transparent === !1
              ? w(En)
              : w(
                  R.blending,
                  R.blendEquation,
                  R.blendSrc,
                  R.blendDst,
                  R.blendEquationAlpha,
                  R.blendSrcAlpha,
                  R.blendDstAlpha,
                  R.blendColor,
                  R.blendAlpha,
                  R.premultipliedAlpha
                ),
            s.setFunc(R.depthFunc),
            s.setTest(R.depthTest),
            s.setMask(R.depthWrite),
            r.setMask(R.colorWrite);
          const q = R.stencilWrite;
          a.setTest(q),
            q &&
              (a.setMask(R.stencilWriteMask),
              a.setFunc(R.stencilFunc, R.stencilRef, R.stencilFuncMask),
              a.setOp(R.stencilFail, R.stencilZFail, R.stencilZPass)),
            Jt(R.polygonOffset, R.polygonOffsetFactor, R.polygonOffsetUnits),
            R.alphaToCoverage === !0
              ? pt(i.SAMPLE_ALPHA_TO_COVERAGE)
              : ct(i.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function Ut(R) {
          tt !== R && (R ? i.frontFace(i.CW) : i.frontFace(i.CCW), (tt = R));
        }
        function zt(R) {
          R !== Pl
            ? (pt(i.CULL_FACE),
              R !== _ &&
                (R === Pa
                  ? i.cullFace(i.BACK)
                  : R === Ll
                  ? i.cullFace(i.FRONT)
                  : i.cullFace(i.FRONT_AND_BACK)))
            : ct(i.CULL_FACE),
            (_ = R);
        }
        function Tt(R) {
          R !== S && (j && i.lineWidth(R), (S = R));
        }
        function Jt(R, st, B) {
          R
            ? (pt(i.POLYGON_OFFSET_FILL),
              (V !== st || z !== B) &&
                (i.polygonOffset(st, B), (V = st), (z = B)))
            : ct(i.POLYGON_OFFSET_FILL);
        }
        function wt(R) {
          R ? pt(i.SCISSOR_TEST) : ct(i.SCISSOR_TEST);
        }
        function y(R) {
          R === void 0 && (R = i.TEXTURE0 + Y - 1),
            H !== R && (i.activeTexture(R), (H = R));
        }
        function g(R, st, B) {
          B === void 0 && (H === null ? (B = i.TEXTURE0 + Y - 1) : (B = H));
          let q = ot[B];
          q === void 0 &&
            ((q = { type: void 0, texture: void 0 }), (ot[B] = q)),
            (q.type !== R || q.texture !== st) &&
              (H !== B && (i.activeTexture(B), (H = B)),
              i.bindTexture(R, st || $[R]),
              (q.type = R),
              (q.texture = st));
        }
        function U() {
          const R = ot[H];
          R !== void 0 &&
            R.type !== void 0 &&
            (i.bindTexture(R.type, null),
            (R.type = void 0),
            (R.texture = void 0));
        }
        function X() {
          try {
            i.compressedTexImage2D.apply(i, arguments);
          } catch (R) {
            console.error("THREE.WebGLState:", R);
          }
        }
        function Z() {
          try {
            i.compressedTexImage3D.apply(i, arguments);
          } catch (R) {
            console.error("THREE.WebGLState:", R);
          }
        }
        function W() {
          try {
            i.texSubImage2D.apply(i, arguments);
          } catch (R) {
            console.error("THREE.WebGLState:", R);
          }
        }
        function gt() {
          try {
            i.texSubImage3D.apply(i, arguments);
          } catch (R) {
            console.error("THREE.WebGLState:", R);
          }
        }
        function nt() {
          try {
            i.compressedTexSubImage2D.apply(i, arguments);
          } catch (R) {
            console.error("THREE.WebGLState:", R);
          }
        }
        function ht() {
          try {
            i.compressedTexSubImage3D.apply(i, arguments);
          } catch (R) {
            console.error("THREE.WebGLState:", R);
          }
        }
        function Ht() {
          try {
            i.texStorage2D.apply(i, arguments);
          } catch (R) {
            console.error("THREE.WebGLState:", R);
          }
        }
        function J() {
          try {
            i.texStorage3D.apply(i, arguments);
          } catch (R) {
            console.error("THREE.WebGLState:", R);
          }
        }
        function ut() {
          try {
            i.texImage2D.apply(i, arguments);
          } catch (R) {
            console.error("THREE.WebGLState:", R);
          }
        }
        function At() {
          try {
            i.texImage3D.apply(i, arguments);
          } catch (R) {
            console.error("THREE.WebGLState:", R);
          }
        }
        function bt(R) {
          Gt.equals(R) === !1 && (i.scissor(R.x, R.y, R.z, R.w), Gt.copy(R));
        }
        function dt(R) {
          Yt.equals(R) === !1 && (i.viewport(R.x, R.y, R.z, R.w), Yt.copy(R));
        }
        function It(R, st) {
          let B = l.get(st);
          B === void 0 && ((B = new WeakMap()), l.set(st, B));
          let q = B.get(R);
          q === void 0 &&
            ((q = i.getUniformBlockIndex(st, R.name)), B.set(R, q));
        }
        function Ct(R, st) {
          const q = l.get(st).get(R);
          o.get(st) !== q &&
            (i.uniformBlockBinding(st, q, R.__bindingPointIndex), o.set(st, q));
        }
        function $t() {
          i.disable(i.BLEND),
            i.disable(i.CULL_FACE),
            i.disable(i.DEPTH_TEST),
            i.disable(i.POLYGON_OFFSET_FILL),
            i.disable(i.SCISSOR_TEST),
            i.disable(i.STENCIL_TEST),
            i.disable(i.SAMPLE_ALPHA_TO_COVERAGE),
            i.blendEquation(i.FUNC_ADD),
            i.blendFunc(i.ONE, i.ZERO),
            i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO),
            i.blendColor(0, 0, 0, 0),
            i.colorMask(!0, !0, !0, !0),
            i.clearColor(0, 0, 0, 0),
            i.depthMask(!0),
            i.depthFunc(i.LESS),
            i.clearDepth(1),
            i.stencilMask(4294967295),
            i.stencilFunc(i.ALWAYS, 0, 4294967295),
            i.stencilOp(i.KEEP, i.KEEP, i.KEEP),
            i.clearStencil(0),
            i.cullFace(i.BACK),
            i.frontFace(i.CCW),
            i.polygonOffset(0, 0),
            i.activeTexture(i.TEXTURE0),
            i.bindFramebuffer(i.FRAMEBUFFER, null),
            i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
            i.bindFramebuffer(i.READ_FRAMEBUFFER, null),
            i.useProgram(null),
            i.lineWidth(1),
            i.scissor(0, 0, i.canvas.width, i.canvas.height),
            i.viewport(0, 0, i.canvas.width, i.canvas.height),
            (c = {}),
            (H = null),
            (ot = {}),
            (h = {}),
            (f = new WeakMap()),
            (p = []),
            (m = null),
            (v = !1),
            (M = null),
            (u = null),
            (d = null),
            (T = null),
            (E = null),
            (A = null),
            (O = null),
            (P = new Bt(0, 0, 0)),
            (b = 0),
            (F = !1),
            (tt = null),
            (_ = null),
            (S = null),
            (V = null),
            (z = null),
            Gt.set(0, 0, i.canvas.width, i.canvas.height),
            Yt.set(0, 0, i.canvas.width, i.canvas.height),
            r.reset(),
            s.reset(),
            a.reset();
        }
        return {
          buffers: { color: r, depth: s, stencil: a },
          enable: pt,
          disable: ct,
          bindFramebuffer: Rt,
          drawBuffers: Et,
          useProgram: Nt,
          setBlending: w,
          setMaterial: Te,
          setFlipSided: Ut,
          setCullFace: zt,
          setLineWidth: Tt,
          setPolygonOffset: Jt,
          setScissorTest: wt,
          activeTexture: y,
          bindTexture: g,
          unbindTexture: U,
          compressedTexImage2D: X,
          compressedTexImage3D: Z,
          texImage2D: ut,
          texImage3D: At,
          updateUBOMapping: It,
          uniformBlockBinding: Ct,
          texStorage2D: Ht,
          texStorage3D: J,
          texSubImage2D: W,
          texSubImage3D: gt,
          compressedTexSubImage2D: nt,
          compressedTexSubImage3D: ht,
          scissor: bt,
          viewport: dt,
          reset: $t,
        };
      }
      function Ao(i, t, e, n) {
        const r = Fp(n);
        switch (e) {
          case Yo:
            return i * t;
          case Ko:
            return i * t;
          case jo:
            return i * t * 2;
          case Zo:
            return ((i * t) / r.components) * r.byteLength;
          case ca:
            return ((i * t) / r.components) * r.byteLength;
          case $o:
            return ((i * t * 2) / r.components) * r.byteLength;
          case ha:
            return ((i * t * 2) / r.components) * r.byteLength;
          case qo:
            return ((i * t * 3) / r.components) * r.byteLength;
          case Xe:
            return ((i * t * 4) / r.components) * r.byteLength;
          case ua:
            return ((i * t * 4) / r.components) * r.byteLength;
          case _r:
          case gr:
            return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 8;
          case vr:
          case xr:
            return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case Ds:
          case Is:
            return (Math.max(i, 16) * Math.max(t, 8)) / 4;
          case Ls:
          case Us:
            return (Math.max(i, 8) * Math.max(t, 8)) / 2;
          case Ns:
          case Fs:
            return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 8;
          case Os:
            return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case Bs:
            return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case zs:
            return Math.floor((i + 4) / 5) * Math.floor((t + 3) / 4) * 16;
          case Hs:
            return Math.floor((i + 4) / 5) * Math.floor((t + 4) / 5) * 16;
          case Gs:
            return Math.floor((i + 5) / 6) * Math.floor((t + 4) / 5) * 16;
          case Vs:
            return Math.floor((i + 5) / 6) * Math.floor((t + 5) / 6) * 16;
          case ks:
            return Math.floor((i + 7) / 8) * Math.floor((t + 4) / 5) * 16;
          case Ws:
            return Math.floor((i + 7) / 8) * Math.floor((t + 5) / 6) * 16;
          case Xs:
            return Math.floor((i + 7) / 8) * Math.floor((t + 7) / 8) * 16;
          case Ys:
            return Math.floor((i + 9) / 10) * Math.floor((t + 4) / 5) * 16;
          case qs:
            return Math.floor((i + 9) / 10) * Math.floor((t + 5) / 6) * 16;
          case Ks:
            return Math.floor((i + 9) / 10) * Math.floor((t + 7) / 8) * 16;
          case js:
            return Math.floor((i + 9) / 10) * Math.floor((t + 9) / 10) * 16;
          case Zs:
            return Math.floor((i + 11) / 12) * Math.floor((t + 9) / 10) * 16;
          case $s:
            return Math.floor((i + 11) / 12) * Math.floor((t + 11) / 12) * 16;
          case Mr:
          case Js:
          case Qs:
            return Math.ceil(i / 4) * Math.ceil(t / 4) * 16;
          case Jo:
          case ta:
            return Math.ceil(i / 4) * Math.ceil(t / 4) * 8;
          case ea:
          case na:
            return Math.ceil(i / 4) * Math.ceil(t / 4) * 16;
        }
        throw new Error(
          `Unable to determine texture byte length for ${e} format.`
        );
      }
      function Fp(i) {
        switch (i) {
          case ln:
          case ko:
            return { byteLength: 1, components: 1 };
          case Oi:
          case Wo:
          case Gi:
            return { byteLength: 2, components: 1 };
          case oa:
          case la:
            return { byteLength: 2, components: 4 };
          case Hn:
          case aa:
          case an:
            return { byteLength: 4, components: 1 };
          case Xo:
            return { byteLength: 4, components: 3 };
        }
        throw new Error(`Unknown texture type ${i}.`);
      }
      function Op(i, t, e, n, r, s, a) {
        const o = t.has("WEBGL_multisampled_render_to_texture")
            ? t.get("WEBGL_multisampled_render_to_texture")
            : null,
          l =
            typeof navigator > "u"
              ? !1
              : /OculusBrowser/g.test(navigator.userAgent),
          c = new Pt(),
          h = new WeakMap();
        let f;
        const p = new WeakMap();
        let m = !1;
        try {
          m =
            typeof OffscreenCanvas < "u" &&
            new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch {}
        function v(y, g) {
          return m ? new OffscreenCanvas(y, g) : zi("canvas");
        }
        function M(y, g, U) {
          let X = 1;
          const Z = wt(y);
          if (
            ((Z.width > U || Z.height > U) &&
              (X = U / Math.max(Z.width, Z.height)),
            X < 1)
          )
            if (
              (typeof HTMLImageElement < "u" &&
                y instanceof HTMLImageElement) ||
              (typeof HTMLCanvasElement < "u" &&
                y instanceof HTMLCanvasElement) ||
              (typeof ImageBitmap < "u" && y instanceof ImageBitmap) ||
              (typeof VideoFrame < "u" && y instanceof VideoFrame)
            ) {
              const W = Math.floor(X * Z.width),
                gt = Math.floor(X * Z.height);
              f === void 0 && (f = v(W, gt));
              const nt = g ? v(W, gt) : f;
              return (
                (nt.width = W),
                (nt.height = gt),
                nt.getContext("2d").drawImage(y, 0, 0, W, gt),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    Z.width +
                    "x" +
                    Z.height +
                    ") to (" +
                    W +
                    "x" +
                    gt +
                    ")."
                ),
                nt
              );
            } else
              return (
                "data" in y &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      Z.width +
                      "x" +
                      Z.height +
                      ")."
                  ),
                y
              );
          return y;
        }
        function u(y) {
          return y.generateMipmaps && y.minFilter !== Ne && y.minFilter !== ke;
        }
        function d(y) {
          i.generateMipmap(y);
        }
        function T(y, g, U, X, Z = !1) {
          if (y !== null) {
            if (i[y] !== void 0) return i[y];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                y +
                "'"
            );
          }
          let W = g;
          if (
            (g === i.RED &&
              (U === i.FLOAT && (W = i.R32F),
              U === i.HALF_FLOAT && (W = i.R16F),
              U === i.UNSIGNED_BYTE && (W = i.R8)),
            g === i.RED_INTEGER &&
              (U === i.UNSIGNED_BYTE && (W = i.R8UI),
              U === i.UNSIGNED_SHORT && (W = i.R16UI),
              U === i.UNSIGNED_INT && (W = i.R32UI),
              U === i.BYTE && (W = i.R8I),
              U === i.SHORT && (W = i.R16I),
              U === i.INT && (W = i.R32I)),
            g === i.RG &&
              (U === i.FLOAT && (W = i.RG32F),
              U === i.HALF_FLOAT && (W = i.RG16F),
              U === i.UNSIGNED_BYTE && (W = i.RG8)),
            g === i.RG_INTEGER &&
              (U === i.UNSIGNED_BYTE && (W = i.RG8UI),
              U === i.UNSIGNED_SHORT && (W = i.RG16UI),
              U === i.UNSIGNED_INT && (W = i.RG32UI),
              U === i.BYTE && (W = i.RG8I),
              U === i.SHORT && (W = i.RG16I),
              U === i.INT && (W = i.RG32I)),
            g === i.RGB_INTEGER &&
              (U === i.UNSIGNED_BYTE && (W = i.RGB8UI),
              U === i.UNSIGNED_SHORT && (W = i.RGB16UI),
              U === i.UNSIGNED_INT && (W = i.RGB32UI),
              U === i.BYTE && (W = i.RGB8I),
              U === i.SHORT && (W = i.RGB16I),
              U === i.INT && (W = i.RGB32I)),
            g === i.RGBA_INTEGER &&
              (U === i.UNSIGNED_BYTE && (W = i.RGBA8UI),
              U === i.UNSIGNED_SHORT && (W = i.RGBA16UI),
              U === i.UNSIGNED_INT && (W = i.RGBA32UI),
              U === i.BYTE && (W = i.RGBA8I),
              U === i.SHORT && (W = i.RGBA16I),
              U === i.INT && (W = i.RGBA32I)),
            g === i.RGB && U === i.UNSIGNED_INT_5_9_9_9_REV && (W = i.RGB9_E5),
            g === i.RGBA)
          ) {
            const gt = Z ? yr : Xt.getTransfer(X);
            U === i.FLOAT && (W = i.RGBA32F),
              U === i.HALF_FLOAT && (W = i.RGBA16F),
              U === i.UNSIGNED_BYTE &&
                (W = gt === te ? i.SRGB8_ALPHA8 : i.RGBA8),
              U === i.UNSIGNED_SHORT_4_4_4_4 && (W = i.RGBA4),
              U === i.UNSIGNED_SHORT_5_5_5_1 && (W = i.RGB5_A1);
          }
          return (
            (W === i.R16F ||
              W === i.R32F ||
              W === i.RG16F ||
              W === i.RG32F ||
              W === i.RGBA16F ||
              W === i.RGBA32F) &&
              t.get("EXT_color_buffer_float"),
            W
          );
        }
        function E(y, g) {
          let U;
          return (
            y
              ? g === null || g === Hn || g === gi
                ? (U = i.DEPTH24_STENCIL8)
                : g === an
                ? (U = i.DEPTH32F_STENCIL8)
                : g === Oi &&
                  ((U = i.DEPTH24_STENCIL8),
                  console.warn(
                    "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
                  ))
              : g === null || g === Hn || g === gi
              ? (U = i.DEPTH_COMPONENT24)
              : g === an
              ? (U = i.DEPTH_COMPONENT32F)
              : g === Oi && (U = i.DEPTH_COMPONENT16),
            U
          );
        }
        function A(y, g) {
          return u(y) === !0 ||
            (y.isFramebufferTexture && y.minFilter !== Ne && y.minFilter !== ke)
            ? Math.log2(Math.max(g.width, g.height)) + 1
            : y.mipmaps !== void 0 && y.mipmaps.length > 0
            ? y.mipmaps.length
            : y.isCompressedTexture && Array.isArray(y.image)
            ? g.mipmaps.length
            : 1;
        }
        function O(y) {
          const g = y.target;
          g.removeEventListener("dispose", O),
            b(g),
            g.isVideoTexture && h.delete(g);
        }
        function P(y) {
          const g = y.target;
          g.removeEventListener("dispose", P), tt(g);
        }
        function b(y) {
          const g = n.get(y);
          if (g.__webglInit === void 0) return;
          const U = y.source,
            X = p.get(U);
          if (X) {
            const Z = X[g.__cacheKey];
            Z.usedTimes--,
              Z.usedTimes === 0 && F(y),
              Object.keys(X).length === 0 && p.delete(U);
          }
          n.remove(y);
        }
        function F(y) {
          const g = n.get(y);
          i.deleteTexture(g.__webglTexture);
          const U = y.source,
            X = p.get(U);
          delete X[g.__cacheKey], a.memory.textures--;
        }
        function tt(y) {
          const g = n.get(y);
          if (
            (y.depthTexture && y.depthTexture.dispose(),
            y.isWebGLCubeRenderTarget)
          )
            for (let X = 0; X < 6; X++) {
              if (Array.isArray(g.__webglFramebuffer[X]))
                for (let Z = 0; Z < g.__webglFramebuffer[X].length; Z++)
                  i.deleteFramebuffer(g.__webglFramebuffer[X][Z]);
              else i.deleteFramebuffer(g.__webglFramebuffer[X]);
              g.__webglDepthbuffer &&
                i.deleteRenderbuffer(g.__webglDepthbuffer[X]);
            }
          else {
            if (Array.isArray(g.__webglFramebuffer))
              for (let X = 0; X < g.__webglFramebuffer.length; X++)
                i.deleteFramebuffer(g.__webglFramebuffer[X]);
            else i.deleteFramebuffer(g.__webglFramebuffer);
            if (
              (g.__webglDepthbuffer &&
                i.deleteRenderbuffer(g.__webglDepthbuffer),
              g.__webglMultisampledFramebuffer &&
                i.deleteFramebuffer(g.__webglMultisampledFramebuffer),
              g.__webglColorRenderbuffer)
            )
              for (let X = 0; X < g.__webglColorRenderbuffer.length; X++)
                g.__webglColorRenderbuffer[X] &&
                  i.deleteRenderbuffer(g.__webglColorRenderbuffer[X]);
            g.__webglDepthRenderbuffer &&
              i.deleteRenderbuffer(g.__webglDepthRenderbuffer);
          }
          const U = y.textures;
          for (let X = 0, Z = U.length; X < Z; X++) {
            const W = n.get(U[X]);
            W.__webglTexture &&
              (i.deleteTexture(W.__webglTexture), a.memory.textures--),
              n.remove(U[X]);
          }
          n.remove(y);
        }
        let _ = 0;
        function S() {
          _ = 0;
        }
        function V() {
          const y = _;
          return (
            y >= r.maxTextures &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  y +
                  " texture units while this GPU supports only " +
                  r.maxTextures
              ),
            (_ += 1),
            y
          );
        }
        function z(y) {
          const g = [];
          return (
            g.push(y.wrapS),
            g.push(y.wrapT),
            g.push(y.wrapR || 0),
            g.push(y.magFilter),
            g.push(y.minFilter),
            g.push(y.anisotropy),
            g.push(y.internalFormat),
            g.push(y.format),
            g.push(y.type),
            g.push(y.generateMipmaps),
            g.push(y.premultiplyAlpha),
            g.push(y.flipY),
            g.push(y.unpackAlignment),
            g.push(y.colorSpace),
            g.join()
          );
        }
        function Y(y, g) {
          const U = n.get(y);
          if (
            (y.isVideoTexture && Tt(y),
            y.isRenderTargetTexture === !1 &&
              y.version > 0 &&
              U.__version !== y.version)
          ) {
            const X = y.image;
            if (X === null)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but no image data found."
              );
            else if (X.complete === !1)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            else {
              Yt(U, y, g);
              return;
            }
          }
          e.bindTexture(i.TEXTURE_2D, U.__webglTexture, i.TEXTURE0 + g);
        }
        function j(y, g) {
          const U = n.get(y);
          if (y.version > 0 && U.__version !== y.version) {
            Yt(U, y, g);
            return;
          }
          e.bindTexture(i.TEXTURE_2D_ARRAY, U.__webglTexture, i.TEXTURE0 + g);
        }
        function G(y, g) {
          const U = n.get(y);
          if (y.version > 0 && U.__version !== y.version) {
            Yt(U, y, g);
            return;
          }
          e.bindTexture(i.TEXTURE_3D, U.__webglTexture, i.TEXTURE0 + g);
        }
        function K(y, g) {
          const U = n.get(y);
          if (y.version > 0 && U.__version !== y.version) {
            k(U, y, g);
            return;
          }
          e.bindTexture(i.TEXTURE_CUBE_MAP, U.__webglTexture, i.TEXTURE0 + g);
        }
        const H = {
            [Cs]: i.REPEAT,
            [Bn]: i.CLAMP_TO_EDGE,
            [Ps]: i.MIRRORED_REPEAT,
          },
          ot = {
            [Ne]: i.NEAREST,
            [sc]: i.NEAREST_MIPMAP_NEAREST,
            [Xi]: i.NEAREST_MIPMAP_LINEAR,
            [ke]: i.LINEAR,
            [zr]: i.LINEAR_MIPMAP_NEAREST,
            [zn]: i.LINEAR_MIPMAP_LINEAR,
          },
          lt = {
            [cc]: i.NEVER,
            [mc]: i.ALWAYS,
            [hc]: i.LESS,
            [tl]: i.LEQUAL,
            [uc]: i.EQUAL,
            [pc]: i.GEQUAL,
            [dc]: i.GREATER,
            [fc]: i.NOTEQUAL,
          };
        function _t(y, g) {
          if (
            (g.type === an &&
              t.has("OES_texture_float_linear") === !1 &&
              (g.magFilter === ke ||
                g.magFilter === zr ||
                g.magFilter === Xi ||
                g.magFilter === zn ||
                g.minFilter === ke ||
                g.minFilter === zr ||
                g.minFilter === Xi ||
                g.minFilter === zn) &&
              console.warn(
                "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
              ),
            i.texParameteri(y, i.TEXTURE_WRAP_S, H[g.wrapS]),
            i.texParameteri(y, i.TEXTURE_WRAP_T, H[g.wrapT]),
            (y === i.TEXTURE_3D || y === i.TEXTURE_2D_ARRAY) &&
              i.texParameteri(y, i.TEXTURE_WRAP_R, H[g.wrapR]),
            i.texParameteri(y, i.TEXTURE_MAG_FILTER, ot[g.magFilter]),
            i.texParameteri(y, i.TEXTURE_MIN_FILTER, ot[g.minFilter]),
            g.compareFunction &&
              (i.texParameteri(
                y,
                i.TEXTURE_COMPARE_MODE,
                i.COMPARE_REF_TO_TEXTURE
              ),
              i.texParameteri(
                y,
                i.TEXTURE_COMPARE_FUNC,
                lt[g.compareFunction]
              )),
            t.has("EXT_texture_filter_anisotropic") === !0)
          ) {
            if (
              g.magFilter === Ne ||
              (g.minFilter !== Xi && g.minFilter !== zn) ||
              (g.type === an && t.has("OES_texture_float_linear") === !1)
            )
              return;
            if (g.anisotropy > 1 || n.get(g).__currentAnisotropy) {
              const U = t.get("EXT_texture_filter_anisotropic");
              i.texParameterf(
                y,
                U.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(g.anisotropy, r.getMaxAnisotropy())
              ),
                (n.get(g).__currentAnisotropy = g.anisotropy);
            }
          }
        }
        function Gt(y, g) {
          let U = !1;
          y.__webglInit === void 0 &&
            ((y.__webglInit = !0), g.addEventListener("dispose", O));
          const X = g.source;
          let Z = p.get(X);
          Z === void 0 && ((Z = {}), p.set(X, Z));
          const W = z(g);
          if (W !== y.__cacheKey) {
            Z[W] === void 0 &&
              ((Z[W] = { texture: i.createTexture(), usedTimes: 0 }),
              a.memory.textures++,
              (U = !0)),
              Z[W].usedTimes++;
            const gt = Z[y.__cacheKey];
            gt !== void 0 &&
              (Z[y.__cacheKey].usedTimes--, gt.usedTimes === 0 && F(g)),
              (y.__cacheKey = W),
              (y.__webglTexture = Z[W].texture);
          }
          return U;
        }
        function Yt(y, g, U) {
          let X = i.TEXTURE_2D;
          (g.isDataArrayTexture || g.isCompressedArrayTexture) &&
            (X = i.TEXTURE_2D_ARRAY),
            g.isData3DTexture && (X = i.TEXTURE_3D);
          const Z = Gt(y, g),
            W = g.source;
          e.bindTexture(X, y.__webglTexture, i.TEXTURE0 + U);
          const gt = n.get(W);
          if (W.version !== gt.__version || Z === !0) {
            e.activeTexture(i.TEXTURE0 + U);
            const nt = Xt.getPrimaries(Xt.workingColorSpace),
              ht = g.colorSpace === vn ? null : Xt.getPrimaries(g.colorSpace),
              Ht =
                g.colorSpace === vn || nt === ht
                  ? i.NONE
                  : i.BROWSER_DEFAULT_WEBGL;
            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, g.flipY),
              i.pixelStorei(
                i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                g.premultiplyAlpha
              ),
              i.pixelStorei(i.UNPACK_ALIGNMENT, g.unpackAlignment),
              i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ht);
            let J = M(g.image, !1, r.maxTextureSize);
            J = Jt(g, J);
            const ut = s.convert(g.format, g.colorSpace),
              At = s.convert(g.type);
            let bt = T(
              g.internalFormat,
              ut,
              At,
              g.colorSpace,
              g.isVideoTexture
            );
            _t(X, g);
            let dt;
            const It = g.mipmaps,
              Ct = g.isVideoTexture !== !0,
              $t = gt.__version === void 0 || Z === !0,
              R = W.dataReady,
              st = A(g, J);
            if (g.isDepthTexture)
              (bt = E(g.format === vi, g.type)),
                $t &&
                  (Ct
                    ? e.texStorage2D(i.TEXTURE_2D, 1, bt, J.width, J.height)
                    : e.texImage2D(
                        i.TEXTURE_2D,
                        0,
                        bt,
                        J.width,
                        J.height,
                        0,
                        ut,
                        At,
                        null
                      ));
            else if (g.isDataTexture)
              if (It.length > 0) {
                Ct &&
                  $t &&
                  e.texStorage2D(
                    i.TEXTURE_2D,
                    st,
                    bt,
                    It[0].width,
                    It[0].height
                  );
                for (let B = 0, q = It.length; B < q; B++)
                  (dt = It[B]),
                    Ct
                      ? R &&
                        e.texSubImage2D(
                          i.TEXTURE_2D,
                          B,
                          0,
                          0,
                          dt.width,
                          dt.height,
                          ut,
                          At,
                          dt.data
                        )
                      : e.texImage2D(
                          i.TEXTURE_2D,
                          B,
                          bt,
                          dt.width,
                          dt.height,
                          0,
                          ut,
                          At,
                          dt.data
                        );
                g.generateMipmaps = !1;
              } else
                Ct
                  ? ($t &&
                      e.texStorage2D(i.TEXTURE_2D, st, bt, J.width, J.height),
                    R &&
                      e.texSubImage2D(
                        i.TEXTURE_2D,
                        0,
                        0,
                        0,
                        J.width,
                        J.height,
                        ut,
                        At,
                        J.data
                      ))
                  : e.texImage2D(
                      i.TEXTURE_2D,
                      0,
                      bt,
                      J.width,
                      J.height,
                      0,
                      ut,
                      At,
                      J.data
                    );
            else if (g.isCompressedTexture)
              if (g.isCompressedArrayTexture) {
                Ct &&
                  $t &&
                  e.texStorage3D(
                    i.TEXTURE_2D_ARRAY,
                    st,
                    bt,
                    It[0].width,
                    It[0].height,
                    J.depth
                  );
                for (let B = 0, q = It.length; B < q; B++)
                  if (((dt = It[B]), g.format !== Xe))
                    if (ut !== null)
                      if (Ct) {
                        if (R)
                          if (g.layerUpdates.size > 0) {
                            const it = Ao(
                              dt.width,
                              dt.height,
                              g.format,
                              g.type
                            );
                            for (const at of g.layerUpdates) {
                              const Ot = dt.data.subarray(
                                (at * it) / dt.data.BYTES_PER_ELEMENT,
                                ((at + 1) * it) / dt.data.BYTES_PER_ELEMENT
                              );
                              e.compressedTexSubImage3D(
                                i.TEXTURE_2D_ARRAY,
                                B,
                                0,
                                0,
                                at,
                                dt.width,
                                dt.height,
                                1,
                                ut,
                                Ot,
                                0,
                                0
                              );
                            }
                            g.clearLayerUpdates();
                          } else
                            e.compressedTexSubImage3D(
                              i.TEXTURE_2D_ARRAY,
                              B,
                              0,
                              0,
                              0,
                              dt.width,
                              dt.height,
                              J.depth,
                              ut,
                              dt.data,
                              0,
                              0
                            );
                      } else
                        e.compressedTexImage3D(
                          i.TEXTURE_2D_ARRAY,
                          B,
                          bt,
                          dt.width,
                          dt.height,
                          J.depth,
                          0,
                          dt.data,
                          0,
                          0
                        );
                    else
                      console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      );
                  else
                    Ct
                      ? R &&
                        e.texSubImage3D(
                          i.TEXTURE_2D_ARRAY,
                          B,
                          0,
                          0,
                          0,
                          dt.width,
                          dt.height,
                          J.depth,
                          ut,
                          At,
                          dt.data
                        )
                      : e.texImage3D(
                          i.TEXTURE_2D_ARRAY,
                          B,
                          bt,
                          dt.width,
                          dt.height,
                          J.depth,
                          0,
                          ut,
                          At,
                          dt.data
                        );
              } else {
                Ct &&
                  $t &&
                  e.texStorage2D(
                    i.TEXTURE_2D,
                    st,
                    bt,
                    It[0].width,
                    It[0].height
                  );
                for (let B = 0, q = It.length; B < q; B++)
                  (dt = It[B]),
                    g.format !== Xe
                      ? ut !== null
                        ? Ct
                          ? R &&
                            e.compressedTexSubImage2D(
                              i.TEXTURE_2D,
                              B,
                              0,
                              0,
                              dt.width,
                              dt.height,
                              ut,
                              dt.data
                            )
                          : e.compressedTexImage2D(
                              i.TEXTURE_2D,
                              B,
                              bt,
                              dt.width,
                              dt.height,
                              0,
                              dt.data
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                          )
                      : Ct
                      ? R &&
                        e.texSubImage2D(
                          i.TEXTURE_2D,
                          B,
                          0,
                          0,
                          dt.width,
                          dt.height,
                          ut,
                          At,
                          dt.data
                        )
                      : e.texImage2D(
                          i.TEXTURE_2D,
                          B,
                          bt,
                          dt.width,
                          dt.height,
                          0,
                          ut,
                          At,
                          dt.data
                        );
              }
            else if (g.isDataArrayTexture)
              if (Ct) {
                if (
                  ($t &&
                    e.texStorage3D(
                      i.TEXTURE_2D_ARRAY,
                      st,
                      bt,
                      J.width,
                      J.height,
                      J.depth
                    ),
                  R)
                )
                  if (g.layerUpdates.size > 0) {
                    const B = Ao(J.width, J.height, g.format, g.type);
                    for (const q of g.layerUpdates) {
                      const it = J.data.subarray(
                        (q * B) / J.data.BYTES_PER_ELEMENT,
                        ((q + 1) * B) / J.data.BYTES_PER_ELEMENT
                      );
                      e.texSubImage3D(
                        i.TEXTURE_2D_ARRAY,
                        0,
                        0,
                        0,
                        q,
                        J.width,
                        J.height,
                        1,
                        ut,
                        At,
                        it
                      );
                    }
                    g.clearLayerUpdates();
                  } else
                    e.texSubImage3D(
                      i.TEXTURE_2D_ARRAY,
                      0,
                      0,
                      0,
                      0,
                      J.width,
                      J.height,
                      J.depth,
                      ut,
                      At,
                      J.data
                    );
              } else
                e.texImage3D(
                  i.TEXTURE_2D_ARRAY,
                  0,
                  bt,
                  J.width,
                  J.height,
                  J.depth,
                  0,
                  ut,
                  At,
                  J.data
                );
            else if (g.isData3DTexture)
              Ct
                ? ($t &&
                    e.texStorage3D(
                      i.TEXTURE_3D,
                      st,
                      bt,
                      J.width,
                      J.height,
                      J.depth
                    ),
                  R &&
                    e.texSubImage3D(
                      i.TEXTURE_3D,
                      0,
                      0,
                      0,
                      0,
                      J.width,
                      J.height,
                      J.depth,
                      ut,
                      At,
                      J.data
                    ))
                : e.texImage3D(
                    i.TEXTURE_3D,
                    0,
                    bt,
                    J.width,
                    J.height,
                    J.depth,
                    0,
                    ut,
                    At,
                    J.data
                  );
            else if (g.isFramebufferTexture) {
              if ($t)
                if (Ct) e.texStorage2D(i.TEXTURE_2D, st, bt, J.width, J.height);
                else {
                  let B = J.width,
                    q = J.height;
                  for (let it = 0; it < st; it++)
                    e.texImage2D(i.TEXTURE_2D, it, bt, B, q, 0, ut, At, null),
                      (B >>= 1),
                      (q >>= 1);
                }
            } else if (It.length > 0) {
              if (Ct && $t) {
                const B = wt(It[0]);
                e.texStorage2D(i.TEXTURE_2D, st, bt, B.width, B.height);
              }
              for (let B = 0, q = It.length; B < q; B++)
                (dt = It[B]),
                  Ct
                    ? R && e.texSubImage2D(i.TEXTURE_2D, B, 0, 0, ut, At, dt)
                    : e.texImage2D(i.TEXTURE_2D, B, bt, ut, At, dt);
              g.generateMipmaps = !1;
            } else if (Ct) {
              if ($t) {
                const B = wt(J);
                e.texStorage2D(i.TEXTURE_2D, st, bt, B.width, B.height);
              }
              R && e.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, ut, At, J);
            } else e.texImage2D(i.TEXTURE_2D, 0, bt, ut, At, J);
            u(g) && d(X),
              (gt.__version = W.version),
              g.onUpdate && g.onUpdate(g);
          }
          y.__version = g.version;
        }
        function k(y, g, U) {
          if (g.image.length !== 6) return;
          const X = Gt(y, g),
            Z = g.source;
          e.bindTexture(i.TEXTURE_CUBE_MAP, y.__webglTexture, i.TEXTURE0 + U);
          const W = n.get(Z);
          if (Z.version !== W.__version || X === !0) {
            e.activeTexture(i.TEXTURE0 + U);
            const gt = Xt.getPrimaries(Xt.workingColorSpace),
              nt = g.colorSpace === vn ? null : Xt.getPrimaries(g.colorSpace),
              ht =
                g.colorSpace === vn || gt === nt
                  ? i.NONE
                  : i.BROWSER_DEFAULT_WEBGL;
            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, g.flipY),
              i.pixelStorei(
                i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                g.premultiplyAlpha
              ),
              i.pixelStorei(i.UNPACK_ALIGNMENT, g.unpackAlignment),
              i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, ht);
            const Ht = g.isCompressedTexture || g.image[0].isCompressedTexture,
              J = g.image[0] && g.image[0].isDataTexture,
              ut = [];
            for (let q = 0; q < 6; q++)
              !Ht && !J
                ? (ut[q] = M(g.image[q], !0, r.maxCubemapSize))
                : (ut[q] = J ? g.image[q].image : g.image[q]),
                (ut[q] = Jt(g, ut[q]));
            const At = ut[0],
              bt = s.convert(g.format, g.colorSpace),
              dt = s.convert(g.type),
              It = T(g.internalFormat, bt, dt, g.colorSpace),
              Ct = g.isVideoTexture !== !0,
              $t = W.__version === void 0 || X === !0,
              R = Z.dataReady;
            let st = A(g, At);
            _t(i.TEXTURE_CUBE_MAP, g);
            let B;
            if (Ht) {
              Ct &&
                $t &&
                e.texStorage2D(i.TEXTURE_CUBE_MAP, st, It, At.width, At.height);
              for (let q = 0; q < 6; q++) {
                B = ut[q].mipmaps;
                for (let it = 0; it < B.length; it++) {
                  const at = B[it];
                  g.format !== Xe
                    ? bt !== null
                      ? Ct
                        ? R &&
                          e.compressedTexSubImage2D(
                            i.TEXTURE_CUBE_MAP_POSITIVE_X + q,
                            it,
                            0,
                            0,
                            at.width,
                            at.height,
                            bt,
                            at.data
                          )
                        : e.compressedTexImage2D(
                            i.TEXTURE_CUBE_MAP_POSITIVE_X + q,
                            it,
                            It,
                            at.width,
                            at.height,
                            0,
                            at.data
                          )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                        )
                    : Ct
                    ? R &&
                      e.texSubImage2D(
                        i.TEXTURE_CUBE_MAP_POSITIVE_X + q,
                        it,
                        0,
                        0,
                        at.width,
                        at.height,
                        bt,
                        dt,
                        at.data
                      )
                    : e.texImage2D(
                        i.TEXTURE_CUBE_MAP_POSITIVE_X + q,
                        it,
                        It,
                        at.width,
                        at.height,
                        0,
                        bt,
                        dt,
                        at.data
                      );
                }
              }
            } else {
              if (((B = g.mipmaps), Ct && $t)) {
                B.length > 0 && st++;
                const q = wt(ut[0]);
                e.texStorage2D(i.TEXTURE_CUBE_MAP, st, It, q.width, q.height);
              }
              for (let q = 0; q < 6; q++)
                if (J) {
                  Ct
                    ? R &&
                      e.texSubImage2D(
                        i.TEXTURE_CUBE_MAP_POSITIVE_X + q,
                        0,
                        0,
                        0,
                        ut[q].width,
                        ut[q].height,
                        bt,
                        dt,
                        ut[q].data
                      )
                    : e.texImage2D(
                        i.TEXTURE_CUBE_MAP_POSITIVE_X + q,
                        0,
                        It,
                        ut[q].width,
                        ut[q].height,
                        0,
                        bt,
                        dt,
                        ut[q].data
                      );
                  for (let it = 0; it < B.length; it++) {
                    const Ot = B[it].image[q].image;
                    Ct
                      ? R &&
                        e.texSubImage2D(
                          i.TEXTURE_CUBE_MAP_POSITIVE_X + q,
                          it + 1,
                          0,
                          0,
                          Ot.width,
                          Ot.height,
                          bt,
                          dt,
                          Ot.data
                        )
                      : e.texImage2D(
                          i.TEXTURE_CUBE_MAP_POSITIVE_X + q,
                          it + 1,
                          It,
                          Ot.width,
                          Ot.height,
                          0,
                          bt,
                          dt,
                          Ot.data
                        );
                  }
                } else {
                  Ct
                    ? R &&
                      e.texSubImage2D(
                        i.TEXTURE_CUBE_MAP_POSITIVE_X + q,
                        0,
                        0,
                        0,
                        bt,
                        dt,
                        ut[q]
                      )
                    : e.texImage2D(
                        i.TEXTURE_CUBE_MAP_POSITIVE_X + q,
                        0,
                        It,
                        bt,
                        dt,
                        ut[q]
                      );
                  for (let it = 0; it < B.length; it++) {
                    const at = B[it];
                    Ct
                      ? R &&
                        e.texSubImage2D(
                          i.TEXTURE_CUBE_MAP_POSITIVE_X + q,
                          it + 1,
                          0,
                          0,
                          bt,
                          dt,
                          at.image[q]
                        )
                      : e.texImage2D(
                          i.TEXTURE_CUBE_MAP_POSITIVE_X + q,
                          it + 1,
                          It,
                          bt,
                          dt,
                          at.image[q]
                        );
                  }
                }
            }
            u(g) && d(i.TEXTURE_CUBE_MAP),
              (W.__version = Z.version),
              g.onUpdate && g.onUpdate(g);
          }
          y.__version = g.version;
        }
        function $(y, g, U, X, Z, W) {
          const gt = s.convert(U.format, U.colorSpace),
            nt = s.convert(U.type),
            ht = T(U.internalFormat, gt, nt, U.colorSpace);
          if (!n.get(g).__hasExternalTextures) {
            const J = Math.max(1, g.width >> W),
              ut = Math.max(1, g.height >> W);
            Z === i.TEXTURE_3D || Z === i.TEXTURE_2D_ARRAY
              ? e.texImage3D(Z, W, ht, J, ut, g.depth, 0, gt, nt, null)
              : e.texImage2D(Z, W, ht, J, ut, 0, gt, nt, null);
          }
          e.bindFramebuffer(i.FRAMEBUFFER, y),
            zt(g)
              ? o.framebufferTexture2DMultisampleEXT(
                  i.FRAMEBUFFER,
                  X,
                  Z,
                  n.get(U).__webglTexture,
                  0,
                  Ut(g)
                )
              : (Z === i.TEXTURE_2D ||
                  (Z >= i.TEXTURE_CUBE_MAP_POSITIVE_X &&
                    Z <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
                i.framebufferTexture2D(
                  i.FRAMEBUFFER,
                  X,
                  Z,
                  n.get(U).__webglTexture,
                  W
                ),
            e.bindFramebuffer(i.FRAMEBUFFER, null);
        }
        function pt(y, g, U) {
          if ((i.bindRenderbuffer(i.RENDERBUFFER, y), g.depthBuffer)) {
            const X = g.depthTexture,
              Z = X && X.isDepthTexture ? X.type : null,
              W = E(g.stencilBuffer, Z),
              gt = g.stencilBuffer
                ? i.DEPTH_STENCIL_ATTACHMENT
                : i.DEPTH_ATTACHMENT,
              nt = Ut(g);
            zt(g)
              ? o.renderbufferStorageMultisampleEXT(
                  i.RENDERBUFFER,
                  nt,
                  W,
                  g.width,
                  g.height
                )
              : U
              ? i.renderbufferStorageMultisample(
                  i.RENDERBUFFER,
                  nt,
                  W,
                  g.width,
                  g.height
                )
              : i.renderbufferStorage(i.RENDERBUFFER, W, g.width, g.height),
              i.framebufferRenderbuffer(i.FRAMEBUFFER, gt, i.RENDERBUFFER, y);
          } else {
            const X = g.textures;
            for (let Z = 0; Z < X.length; Z++) {
              const W = X[Z],
                gt = s.convert(W.format, W.colorSpace),
                nt = s.convert(W.type),
                ht = T(W.internalFormat, gt, nt, W.colorSpace),
                Ht = Ut(g);
              U && zt(g) === !1
                ? i.renderbufferStorageMultisample(
                    i.RENDERBUFFER,
                    Ht,
                    ht,
                    g.width,
                    g.height
                  )
                : zt(g)
                ? o.renderbufferStorageMultisampleEXT(
                    i.RENDERBUFFER,
                    Ht,
                    ht,
                    g.width,
                    g.height
                  )
                : i.renderbufferStorage(i.RENDERBUFFER, ht, g.width, g.height);
            }
          }
          i.bindRenderbuffer(i.RENDERBUFFER, null);
        }
        function ct(y, g) {
          if (g && g.isWebGLCubeRenderTarget)
            throw new Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (
            (e.bindFramebuffer(i.FRAMEBUFFER, y),
            !(g.depthTexture && g.depthTexture.isDepthTexture))
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (!n.get(g.depthTexture).__webglTexture ||
            g.depthTexture.image.width !== g.width ||
            g.depthTexture.image.height !== g.height) &&
            ((g.depthTexture.image.width = g.width),
            (g.depthTexture.image.height = g.height),
            (g.depthTexture.needsUpdate = !0)),
            Y(g.depthTexture, 0);
          const X = n.get(g.depthTexture).__webglTexture,
            Z = Ut(g);
          if (g.depthTexture.format === hi)
            zt(g)
              ? o.framebufferTexture2DMultisampleEXT(
                  i.FRAMEBUFFER,
                  i.DEPTH_ATTACHMENT,
                  i.TEXTURE_2D,
                  X,
                  0,
                  Z
                )
              : i.framebufferTexture2D(
                  i.FRAMEBUFFER,
                  i.DEPTH_ATTACHMENT,
                  i.TEXTURE_2D,
                  X,
                  0
                );
          else if (g.depthTexture.format === vi)
            zt(g)
              ? o.framebufferTexture2DMultisampleEXT(
                  i.FRAMEBUFFER,
                  i.DEPTH_STENCIL_ATTACHMENT,
                  i.TEXTURE_2D,
                  X,
                  0,
                  Z
                )
              : i.framebufferTexture2D(
                  i.FRAMEBUFFER,
                  i.DEPTH_STENCIL_ATTACHMENT,
                  i.TEXTURE_2D,
                  X,
                  0
                );
          else throw new Error("Unknown depthTexture format");
        }
        function Rt(y) {
          const g = n.get(y),
            U = y.isWebGLCubeRenderTarget === !0;
          if (g.__boundDepthTexture !== y.depthTexture) {
            const X = y.depthTexture;
            if ((g.__depthDisposeCallback && g.__depthDisposeCallback(), X)) {
              const Z = () => {
                delete g.__boundDepthTexture,
                  delete g.__depthDisposeCallback,
                  X.removeEventListener("dispose", Z);
              };
              X.addEventListener("dispose", Z), (g.__depthDisposeCallback = Z);
            }
            g.__boundDepthTexture = X;
          }
          if (y.depthTexture && !g.__autoAllocateDepthBuffer) {
            if (U)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            ct(g.__webglFramebuffer, y);
          } else if (U) {
            g.__webglDepthbuffer = [];
            for (let X = 0; X < 6; X++)
              if (
                (e.bindFramebuffer(i.FRAMEBUFFER, g.__webglFramebuffer[X]),
                g.__webglDepthbuffer[X] === void 0)
              )
                (g.__webglDepthbuffer[X] = i.createRenderbuffer()),
                  pt(g.__webglDepthbuffer[X], y, !1);
              else {
                const Z = y.stencilBuffer
                    ? i.DEPTH_STENCIL_ATTACHMENT
                    : i.DEPTH_ATTACHMENT,
                  W = g.__webglDepthbuffer[X];
                i.bindRenderbuffer(i.RENDERBUFFER, W),
                  i.framebufferRenderbuffer(
                    i.FRAMEBUFFER,
                    Z,
                    i.RENDERBUFFER,
                    W
                  );
              }
          } else if (
            (e.bindFramebuffer(i.FRAMEBUFFER, g.__webglFramebuffer),
            g.__webglDepthbuffer === void 0)
          )
            (g.__webglDepthbuffer = i.createRenderbuffer()),
              pt(g.__webglDepthbuffer, y, !1);
          else {
            const X = y.stencilBuffer
                ? i.DEPTH_STENCIL_ATTACHMENT
                : i.DEPTH_ATTACHMENT,
              Z = g.__webglDepthbuffer;
            i.bindRenderbuffer(i.RENDERBUFFER, Z),
              i.framebufferRenderbuffer(i.FRAMEBUFFER, X, i.RENDERBUFFER, Z);
          }
          e.bindFramebuffer(i.FRAMEBUFFER, null);
        }
        function Et(y, g, U) {
          const X = n.get(y);
          g !== void 0 &&
            $(
              X.__webglFramebuffer,
              y,
              y.texture,
              i.COLOR_ATTACHMENT0,
              i.TEXTURE_2D,
              0
            ),
            U !== void 0 && Rt(y);
        }
        function Nt(y) {
          const g = y.texture,
            U = n.get(y),
            X = n.get(g);
          y.addEventListener("dispose", P);
          const Z = y.textures,
            W = y.isWebGLCubeRenderTarget === !0,
            gt = Z.length > 1;
          if (
            (gt ||
              (X.__webglTexture === void 0 &&
                (X.__webglTexture = i.createTexture()),
              (X.__version = g.version),
              a.memory.textures++),
            W)
          ) {
            U.__webglFramebuffer = [];
            for (let nt = 0; nt < 6; nt++)
              if (g.mipmaps && g.mipmaps.length > 0) {
                U.__webglFramebuffer[nt] = [];
                for (let ht = 0; ht < g.mipmaps.length; ht++)
                  U.__webglFramebuffer[nt][ht] = i.createFramebuffer();
              } else U.__webglFramebuffer[nt] = i.createFramebuffer();
          } else {
            if (g.mipmaps && g.mipmaps.length > 0) {
              U.__webglFramebuffer = [];
              for (let nt = 0; nt < g.mipmaps.length; nt++)
                U.__webglFramebuffer[nt] = i.createFramebuffer();
            } else U.__webglFramebuffer = i.createFramebuffer();
            if (gt)
              for (let nt = 0, ht = Z.length; nt < ht; nt++) {
                const Ht = n.get(Z[nt]);
                Ht.__webglTexture === void 0 &&
                  ((Ht.__webglTexture = i.createTexture()),
                  a.memory.textures++);
              }
            if (y.samples > 0 && zt(y) === !1) {
              (U.__webglMultisampledFramebuffer = i.createFramebuffer()),
                (U.__webglColorRenderbuffer = []),
                e.bindFramebuffer(
                  i.FRAMEBUFFER,
                  U.__webglMultisampledFramebuffer
                );
              for (let nt = 0; nt < Z.length; nt++) {
                const ht = Z[nt];
                (U.__webglColorRenderbuffer[nt] = i.createRenderbuffer()),
                  i.bindRenderbuffer(
                    i.RENDERBUFFER,
                    U.__webglColorRenderbuffer[nt]
                  );
                const Ht = s.convert(ht.format, ht.colorSpace),
                  J = s.convert(ht.type),
                  ut = T(
                    ht.internalFormat,
                    Ht,
                    J,
                    ht.colorSpace,
                    y.isXRRenderTarget === !0
                  ),
                  At = Ut(y);
                i.renderbufferStorageMultisample(
                  i.RENDERBUFFER,
                  At,
                  ut,
                  y.width,
                  y.height
                ),
                  i.framebufferRenderbuffer(
                    i.FRAMEBUFFER,
                    i.COLOR_ATTACHMENT0 + nt,
                    i.RENDERBUFFER,
                    U.__webglColorRenderbuffer[nt]
                  );
              }
              i.bindRenderbuffer(i.RENDERBUFFER, null),
                y.depthBuffer &&
                  ((U.__webglDepthRenderbuffer = i.createRenderbuffer()),
                  pt(U.__webglDepthRenderbuffer, y, !0)),
                e.bindFramebuffer(i.FRAMEBUFFER, null);
            }
          }
          if (W) {
            e.bindTexture(i.TEXTURE_CUBE_MAP, X.__webglTexture),
              _t(i.TEXTURE_CUBE_MAP, g);
            for (let nt = 0; nt < 6; nt++)
              if (g.mipmaps && g.mipmaps.length > 0)
                for (let ht = 0; ht < g.mipmaps.length; ht++)
                  $(
                    U.__webglFramebuffer[nt][ht],
                    y,
                    g,
                    i.COLOR_ATTACHMENT0,
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + nt,
                    ht
                  );
              else
                $(
                  U.__webglFramebuffer[nt],
                  y,
                  g,
                  i.COLOR_ATTACHMENT0,
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + nt,
                  0
                );
            u(g) && d(i.TEXTURE_CUBE_MAP), e.unbindTexture();
          } else if (gt) {
            for (let nt = 0, ht = Z.length; nt < ht; nt++) {
              const Ht = Z[nt],
                J = n.get(Ht);
              e.bindTexture(i.TEXTURE_2D, J.__webglTexture),
                _t(i.TEXTURE_2D, Ht),
                $(
                  U.__webglFramebuffer,
                  y,
                  Ht,
                  i.COLOR_ATTACHMENT0 + nt,
                  i.TEXTURE_2D,
                  0
                ),
                u(Ht) && d(i.TEXTURE_2D);
            }
            e.unbindTexture();
          } else {
            let nt = i.TEXTURE_2D;
            if (
              ((y.isWebGL3DRenderTarget || y.isWebGLArrayRenderTarget) &&
                (nt = y.isWebGL3DRenderTarget
                  ? i.TEXTURE_3D
                  : i.TEXTURE_2D_ARRAY),
              e.bindTexture(nt, X.__webglTexture),
              _t(nt, g),
              g.mipmaps && g.mipmaps.length > 0)
            )
              for (let ht = 0; ht < g.mipmaps.length; ht++)
                $(U.__webglFramebuffer[ht], y, g, i.COLOR_ATTACHMENT0, nt, ht);
            else $(U.__webglFramebuffer, y, g, i.COLOR_ATTACHMENT0, nt, 0);
            u(g) && d(nt), e.unbindTexture();
          }
          y.depthBuffer && Rt(y);
        }
        function Kt(y) {
          const g = y.textures;
          for (let U = 0, X = g.length; U < X; U++) {
            const Z = g[U];
            if (u(Z)) {
              const W = y.isWebGLCubeRenderTarget
                  ? i.TEXTURE_CUBE_MAP
                  : i.TEXTURE_2D,
                gt = n.get(Z).__webglTexture;
              e.bindTexture(W, gt), d(W), e.unbindTexture();
            }
          }
        }
        const Ft = [],
          w = [];
        function Te(y) {
          if (y.samples > 0) {
            if (zt(y) === !1) {
              const g = y.textures,
                U = y.width,
                X = y.height;
              let Z = i.COLOR_BUFFER_BIT;
              const W = y.stencilBuffer
                  ? i.DEPTH_STENCIL_ATTACHMENT
                  : i.DEPTH_ATTACHMENT,
                gt = n.get(y),
                nt = g.length > 1;
              if (nt)
                for (let ht = 0; ht < g.length; ht++)
                  e.bindFramebuffer(
                    i.FRAMEBUFFER,
                    gt.__webglMultisampledFramebuffer
                  ),
                    i.framebufferRenderbuffer(
                      i.FRAMEBUFFER,
                      i.COLOR_ATTACHMENT0 + ht,
                      i.RENDERBUFFER,
                      null
                    ),
                    e.bindFramebuffer(i.FRAMEBUFFER, gt.__webglFramebuffer),
                    i.framebufferTexture2D(
                      i.DRAW_FRAMEBUFFER,
                      i.COLOR_ATTACHMENT0 + ht,
                      i.TEXTURE_2D,
                      null,
                      0
                    );
              e.bindFramebuffer(
                i.READ_FRAMEBUFFER,
                gt.__webglMultisampledFramebuffer
              ),
                e.bindFramebuffer(i.DRAW_FRAMEBUFFER, gt.__webglFramebuffer);
              for (let ht = 0; ht < g.length; ht++) {
                if (
                  (y.resolveDepthBuffer &&
                    (y.depthBuffer && (Z |= i.DEPTH_BUFFER_BIT),
                    y.stencilBuffer &&
                      y.resolveStencilBuffer &&
                      (Z |= i.STENCIL_BUFFER_BIT)),
                  nt)
                ) {
                  i.framebufferRenderbuffer(
                    i.READ_FRAMEBUFFER,
                    i.COLOR_ATTACHMENT0,
                    i.RENDERBUFFER,
                    gt.__webglColorRenderbuffer[ht]
                  );
                  const Ht = n.get(g[ht]).__webglTexture;
                  i.framebufferTexture2D(
                    i.DRAW_FRAMEBUFFER,
                    i.COLOR_ATTACHMENT0,
                    i.TEXTURE_2D,
                    Ht,
                    0
                  );
                }
                i.blitFramebuffer(0, 0, U, X, 0, 0, U, X, Z, i.NEAREST),
                  l === !0 &&
                    ((Ft.length = 0),
                    (w.length = 0),
                    Ft.push(i.COLOR_ATTACHMENT0 + ht),
                    y.depthBuffer &&
                      y.resolveDepthBuffer === !1 &&
                      (Ft.push(W),
                      w.push(W),
                      i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, w)),
                    i.invalidateFramebuffer(i.READ_FRAMEBUFFER, Ft));
              }
              if (
                (e.bindFramebuffer(i.READ_FRAMEBUFFER, null),
                e.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
                nt)
              )
                for (let ht = 0; ht < g.length; ht++) {
                  e.bindFramebuffer(
                    i.FRAMEBUFFER,
                    gt.__webglMultisampledFramebuffer
                  ),
                    i.framebufferRenderbuffer(
                      i.FRAMEBUFFER,
                      i.COLOR_ATTACHMENT0 + ht,
                      i.RENDERBUFFER,
                      gt.__webglColorRenderbuffer[ht]
                    );
                  const Ht = n.get(g[ht]).__webglTexture;
                  e.bindFramebuffer(i.FRAMEBUFFER, gt.__webglFramebuffer),
                    i.framebufferTexture2D(
                      i.DRAW_FRAMEBUFFER,
                      i.COLOR_ATTACHMENT0 + ht,
                      i.TEXTURE_2D,
                      Ht,
                      0
                    );
                }
              e.bindFramebuffer(
                i.DRAW_FRAMEBUFFER,
                gt.__webglMultisampledFramebuffer
              );
            } else if (y.depthBuffer && y.resolveDepthBuffer === !1 && l) {
              const g = y.stencilBuffer
                ? i.DEPTH_STENCIL_ATTACHMENT
                : i.DEPTH_ATTACHMENT;
              i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [g]);
            }
          }
        }
        function Ut(y) {
          return Math.min(r.maxSamples, y.samples);
        }
        function zt(y) {
          const g = n.get(y);
          return (
            y.samples > 0 &&
            t.has("WEBGL_multisampled_render_to_texture") === !0 &&
            g.__useRenderToTexture !== !1
          );
        }
        function Tt(y) {
          const g = a.render.frame;
          h.get(y) !== g && (h.set(y, g), y.update());
        }
        function Jt(y, g) {
          const U = y.colorSpace,
            X = y.format,
            Z = y.type;
          return (
            y.isCompressedTexture === !0 ||
              y.isVideoTexture === !0 ||
              (U !== bn &&
                U !== vn &&
                (Xt.getTransfer(U) === te
                  ? (X !== Xe || Z !== ln) &&
                    console.warn(
                      "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                    )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture color space:",
                      U
                    ))),
            g
          );
        }
        function wt(y) {
          return (
            typeof HTMLImageElement < "u" && y instanceof HTMLImageElement
              ? ((c.width = y.naturalWidth || y.width),
                (c.height = y.naturalHeight || y.height))
              : typeof VideoFrame < "u" && y instanceof VideoFrame
              ? ((c.width = y.displayWidth), (c.height = y.displayHeight))
              : ((c.width = y.width), (c.height = y.height)),
            c
          );
        }
        (this.allocateTextureUnit = V),
          (this.resetTextureUnits = S),
          (this.setTexture2D = Y),
          (this.setTexture2DArray = j),
          (this.setTexture3D = G),
          (this.setTextureCube = K),
          (this.rebindTextures = Et),
          (this.setupRenderTarget = Nt),
          (this.updateRenderTargetMipmap = Kt),
          (this.updateMultisampleRenderTarget = Te),
          (this.setupDepthRenderbuffer = Rt),
          (this.setupFrameBufferTexture = $),
          (this.useMultisampledRTT = zt);
      }
      function Bp(i, t) {
        function e(n, r = vn) {
          let s;
          const a = Xt.getTransfer(r);
          if (n === ln) return i.UNSIGNED_BYTE;
          if (n === oa) return i.UNSIGNED_SHORT_4_4_4_4;
          if (n === la) return i.UNSIGNED_SHORT_5_5_5_1;
          if (n === Xo) return i.UNSIGNED_INT_5_9_9_9_REV;
          if (n === ko) return i.BYTE;
          if (n === Wo) return i.SHORT;
          if (n === Oi) return i.UNSIGNED_SHORT;
          if (n === aa) return i.INT;
          if (n === Hn) return i.UNSIGNED_INT;
          if (n === an) return i.FLOAT;
          if (n === Gi) return i.HALF_FLOAT;
          if (n === Yo) return i.ALPHA;
          if (n === qo) return i.RGB;
          if (n === Xe) return i.RGBA;
          if (n === Ko) return i.LUMINANCE;
          if (n === jo) return i.LUMINANCE_ALPHA;
          if (n === hi) return i.DEPTH_COMPONENT;
          if (n === vi) return i.DEPTH_STENCIL;
          if (n === Zo) return i.RED;
          if (n === ca) return i.RED_INTEGER;
          if (n === $o) return i.RG;
          if (n === ha) return i.RG_INTEGER;
          if (n === ua) return i.RGBA_INTEGER;
          if (n === _r || n === gr || n === vr || n === xr)
            if (a === te)
              if (
                ((s = t.get("WEBGL_compressed_texture_s3tc_srgb")), s !== null)
              ) {
                if (n === _r) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (n === gr) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (n === vr) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (n === xr) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else return null;
            else if (
              ((s = t.get("WEBGL_compressed_texture_s3tc")), s !== null)
            ) {
              if (n === _r) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (n === gr) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (n === vr) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (n === xr) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
          if (n === Ls || n === Ds || n === Us || n === Is)
            if (((s = t.get("WEBGL_compressed_texture_pvrtc")), s !== null)) {
              if (n === Ls) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (n === Ds) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (n === Us) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (n === Is) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
          if (n === Ns || n === Fs || n === Os)
            if (((s = t.get("WEBGL_compressed_texture_etc")), s !== null)) {
              if (n === Ns || n === Fs)
                return a === te
                  ? s.COMPRESSED_SRGB8_ETC2
                  : s.COMPRESSED_RGB8_ETC2;
              if (n === Os)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : s.COMPRESSED_RGBA8_ETC2_EAC;
            } else return null;
          if (
            n === Bs ||
            n === zs ||
            n === Hs ||
            n === Gs ||
            n === Vs ||
            n === ks ||
            n === Ws ||
            n === Xs ||
            n === Ys ||
            n === qs ||
            n === Ks ||
            n === js ||
            n === Zs ||
            n === $s
          )
            if (((s = t.get("WEBGL_compressed_texture_astc")), s !== null)) {
              if (n === Bs)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (n === zs)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (n === Hs)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (n === Gs)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (n === Vs)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (n === ks)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (n === Ws)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (n === Xs)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (n === Ys)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (n === qs)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (n === Ks)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (n === js)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (n === Zs)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (n === $s)
                return a === te
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else return null;
          if (n === Mr || n === Js || n === Qs)
            if (((s = t.get("EXT_texture_compression_bptc")), s !== null)) {
              if (n === Mr)
                return a === te
                  ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
              if (n === Js) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
              if (n === Qs) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
            } else return null;
          if (n === Jo || n === ta || n === ea || n === na)
            if (((s = t.get("EXT_texture_compression_rgtc")), s !== null)) {
              if (n === Mr) return s.COMPRESSED_RED_RGTC1_EXT;
              if (n === ta) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
              if (n === ea) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
              if (n === na) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            } else return null;
          return n === gi ? i.UNSIGNED_INT_24_8 : i[n] !== void 0 ? i[n] : null;
        }
        return { convert: e };
      }
      class zp extends Pe {
        constructor(t = []) {
          super(), (this.isArrayCamera = !0), (this.cameras = t);
        }
      }
      class dr extends ue {
        constructor() {
          super(), (this.isGroup = !0), (this.type = "Group");
        }
      }
      const Hp = { type: "move" };
      class fs {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            this._hand === null &&
              ((this._hand = new dr()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            this._targetRay === null &&
              ((this._targetRay = new dr()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new D()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new D())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            this._grip === null &&
              ((this._grip = new dr()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new D()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new D())),
            this._grip
          );
        }
        dispatchEvent(t) {
          return (
            this._targetRay !== null && this._targetRay.dispatchEvent(t),
            this._grip !== null && this._grip.dispatchEvent(t),
            this._hand !== null && this._hand.dispatchEvent(t),
            this
          );
        }
        connect(t) {
          if (t && t.hand) {
            const e = this._hand;
            if (e) for (const n of t.hand.values()) this._getHandJoint(e, n);
          }
          return this.dispatchEvent({ type: "connected", data: t }), this;
        }
        disconnect(t) {
          return (
            this.dispatchEvent({ type: "disconnected", data: t }),
            this._targetRay !== null && (this._targetRay.visible = !1),
            this._grip !== null && (this._grip.visible = !1),
            this._hand !== null && (this._hand.visible = !1),
            this
          );
        }
        update(t, e, n) {
          let r = null,
            s = null,
            a = null;
          const o = this._targetRay,
            l = this._grip,
            c = this._hand;
          if (t && e.session.visibilityState !== "visible-blurred") {
            if (c && t.hand) {
              a = !0;
              for (const M of t.hand.values()) {
                const u = e.getJointPose(M, n),
                  d = this._getHandJoint(c, M);
                u !== null &&
                  (d.matrix.fromArray(u.transform.matrix),
                  d.matrix.decompose(d.position, d.rotation, d.scale),
                  (d.matrixWorldNeedsUpdate = !0),
                  (d.jointRadius = u.radius)),
                  (d.visible = u !== null);
              }
              const h = c.joints["index-finger-tip"],
                f = c.joints["thumb-tip"],
                p = h.position.distanceTo(f.position),
                m = 0.02,
                v = 0.005;
              c.inputState.pinching && p > m + v
                ? ((c.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: t.handedness,
                    target: this,
                  }))
                : !c.inputState.pinching &&
                  p <= m - v &&
                  ((c.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: t.handedness,
                    target: this,
                  }));
            } else
              l !== null &&
                t.gripSpace &&
                ((s = e.getPose(t.gripSpace, n)),
                s !== null &&
                  (l.matrix.fromArray(s.transform.matrix),
                  l.matrix.decompose(l.position, l.rotation, l.scale),
                  (l.matrixWorldNeedsUpdate = !0),
                  s.linearVelocity
                    ? ((l.hasLinearVelocity = !0),
                      l.linearVelocity.copy(s.linearVelocity))
                    : (l.hasLinearVelocity = !1),
                  s.angularVelocity
                    ? ((l.hasAngularVelocity = !0),
                      l.angularVelocity.copy(s.angularVelocity))
                    : (l.hasAngularVelocity = !1)));
            o !== null &&
              ((r = e.getPose(t.targetRaySpace, n)),
              r === null && s !== null && (r = s),
              r !== null &&
                (o.matrix.fromArray(r.transform.matrix),
                o.matrix.decompose(o.position, o.rotation, o.scale),
                (o.matrixWorldNeedsUpdate = !0),
                r.linearVelocity
                  ? ((o.hasLinearVelocity = !0),
                    o.linearVelocity.copy(r.linearVelocity))
                  : (o.hasLinearVelocity = !1),
                r.angularVelocity
                  ? ((o.hasAngularVelocity = !0),
                    o.angularVelocity.copy(r.angularVelocity))
                  : (o.hasAngularVelocity = !1),
                this.dispatchEvent(Hp)));
          }
          return (
            o !== null && (o.visible = r !== null),
            l !== null && (l.visible = s !== null),
            c !== null && (c.visible = a !== null),
            this
          );
        }
        _getHandJoint(t, e) {
          if (t.joints[e.jointName] === void 0) {
            const n = new dr();
            (n.matrixAutoUpdate = !1),
              (n.visible = !1),
              (t.joints[e.jointName] = n),
              t.add(n);
          }
          return t.joints[e.jointName];
        }
      }
      const Gp = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
        Vp = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
      class kp {
        constructor() {
          (this.texture = null),
            (this.mesh = null),
            (this.depthNear = 0),
            (this.depthFar = 0);
        }
        init(t, e, n) {
          if (this.texture === null) {
            const r = new xe(),
              s = t.properties.get(r);
            (s.__webglTexture = e.texture),
              (e.depthNear != n.depthNear || e.depthFar != n.depthFar) &&
                ((this.depthNear = e.depthNear), (this.depthFar = e.depthFar)),
              (this.texture = r);
          }
        }
        getMesh(t) {
          if (this.texture !== null && this.mesh === null) {
            const e = t.cameras[0].viewport,
              n = new An({
                vertexShader: Gp,
                fragmentShader: Vp,
                uniforms: {
                  depthColor: { value: this.texture },
                  depthWidth: { value: e.z },
                  depthHeight: { value: e.w },
                },
              });
            this.mesh = new Fe(new Ur(20, 20), n);
          }
          return this.mesh;
        }
        reset() {
          (this.texture = null), (this.mesh = null);
        }
        getDepthTexture() {
          return this.texture;
        }
      }
      class Wp extends kn {
        constructor(t, e) {
          super();
          const n = this;
          let r = null,
            s = 1,
            a = null,
            o = "local-floor",
            l = 1,
            c = null,
            h = null,
            f = null,
            p = null,
            m = null,
            v = null;
          const M = new kp(),
            u = e.getContextAttributes();
          let d = null,
            T = null;
          const E = [],
            A = [],
            O = new Pt();
          let P = null;
          const b = new Pe();
          b.layers.enable(1), (b.viewport = new Zt());
          const F = new Pe();
          F.layers.enable(2), (F.viewport = new Zt());
          const tt = [b, F],
            _ = new zp();
          _.layers.enable(1), _.layers.enable(2);
          let S = null,
            V = null;
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (k) {
              let $ = E[k];
              return (
                $ === void 0 && (($ = new fs()), (E[k] = $)),
                $.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (k) {
              let $ = E[k];
              return (
                $ === void 0 && (($ = new fs()), (E[k] = $)), $.getGripSpace()
              );
            }),
            (this.getHand = function (k) {
              let $ = E[k];
              return (
                $ === void 0 && (($ = new fs()), (E[k] = $)), $.getHandSpace()
              );
            });
          function z(k) {
            const $ = A.indexOf(k.inputSource);
            if ($ === -1) return;
            const pt = E[$];
            pt !== void 0 &&
              (pt.update(k.inputSource, k.frame, c || a),
              pt.dispatchEvent({ type: k.type, data: k.inputSource }));
          }
          function Y() {
            r.removeEventListener("select", z),
              r.removeEventListener("selectstart", z),
              r.removeEventListener("selectend", z),
              r.removeEventListener("squeeze", z),
              r.removeEventListener("squeezestart", z),
              r.removeEventListener("squeezeend", z),
              r.removeEventListener("end", Y),
              r.removeEventListener("inputsourceschange", j);
            for (let k = 0; k < E.length; k++) {
              const $ = A[k];
              $ !== null && ((A[k] = null), E[k].disconnect($));
            }
            (S = null),
              (V = null),
              M.reset(),
              t.setRenderTarget(d),
              (m = null),
              (p = null),
              (f = null),
              (r = null),
              (T = null),
              Yt.stop(),
              (n.isPresenting = !1),
              t.setPixelRatio(P),
              t.setSize(O.width, O.height, !1),
              n.dispatchEvent({ type: "sessionend" });
          }
          (this.setFramebufferScaleFactor = function (k) {
            (s = k),
              n.isPresenting === !0 &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
            (this.setReferenceSpaceType = function (k) {
              (o = k),
                n.isPresenting === !0 &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return c || a;
            }),
            (this.setReferenceSpace = function (k) {
              c = k;
            }),
            (this.getBaseLayer = function () {
              return p !== null ? p : m;
            }),
            (this.getBinding = function () {
              return f;
            }),
            (this.getFrame = function () {
              return v;
            }),
            (this.getSession = function () {
              return r;
            }),
            (this.setSession = async function (k) {
              if (((r = k), r !== null)) {
                if (
                  ((d = t.getRenderTarget()),
                  r.addEventListener("select", z),
                  r.addEventListener("selectstart", z),
                  r.addEventListener("selectend", z),
                  r.addEventListener("squeeze", z),
                  r.addEventListener("squeezestart", z),
                  r.addEventListener("squeezeend", z),
                  r.addEventListener("end", Y),
                  r.addEventListener("inputsourceschange", j),
                  u.xrCompatible !== !0 && (await e.makeXRCompatible()),
                  (P = t.getPixelRatio()),
                  t.getSize(O),
                  r.renderState.layers === void 0)
                ) {
                  const $ = {
                    antialias: u.antialias,
                    alpha: !0,
                    depth: u.depth,
                    stencil: u.stencil,
                    framebufferScaleFactor: s,
                  };
                  (m = new XRWebGLLayer(r, e, $)),
                    r.updateRenderState({ baseLayer: m }),
                    t.setPixelRatio(1),
                    t.setSize(m.framebufferWidth, m.framebufferHeight, !1),
                    (T = new Gn(m.framebufferWidth, m.framebufferHeight, {
                      format: Xe,
                      type: ln,
                      colorSpace: t.outputColorSpace,
                      stencilBuffer: u.stencil,
                    }));
                } else {
                  let $ = null,
                    pt = null,
                    ct = null;
                  u.depth &&
                    ((ct = u.stencil
                      ? e.DEPTH24_STENCIL8
                      : e.DEPTH_COMPONENT24),
                    ($ = u.stencil ? vi : hi),
                    (pt = u.stencil ? gi : Hn));
                  const Rt = {
                    colorFormat: e.RGBA8,
                    depthFormat: ct,
                    scaleFactor: s,
                  };
                  (f = new XRWebGLBinding(r, e)),
                    (p = f.createProjectionLayer(Rt)),
                    r.updateRenderState({ layers: [p] }),
                    t.setPixelRatio(1),
                    t.setSize(p.textureWidth, p.textureHeight, !1),
                    (T = new Gn(p.textureWidth, p.textureHeight, {
                      format: Xe,
                      type: ln,
                      depthTexture: new fl(
                        p.textureWidth,
                        p.textureHeight,
                        pt,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        $
                      ),
                      stencilBuffer: u.stencil,
                      colorSpace: t.outputColorSpace,
                      samples: u.antialias ? 4 : 0,
                      resolveDepthBuffer: p.ignoreDepthValues === !1,
                    }));
                }
                (T.isXRRenderTarget = !0),
                  this.setFoveation(l),
                  (c = null),
                  (a = await r.requestReferenceSpace(o)),
                  Yt.setContext(r),
                  Yt.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: "sessionstart" });
              }
            }),
            (this.getEnvironmentBlendMode = function () {
              if (r !== null) return r.environmentBlendMode;
            }),
            (this.getDepthTexture = function () {
              return M.getDepthTexture();
            });
          function j(k) {
            for (let $ = 0; $ < k.removed.length; $++) {
              const pt = k.removed[$],
                ct = A.indexOf(pt);
              ct >= 0 && ((A[ct] = null), E[ct].disconnect(pt));
            }
            for (let $ = 0; $ < k.added.length; $++) {
              const pt = k.added[$];
              let ct = A.indexOf(pt);
              if (ct === -1) {
                for (let Et = 0; Et < E.length; Et++)
                  if (Et >= A.length) {
                    A.push(pt), (ct = Et);
                    break;
                  } else if (A[Et] === null) {
                    (A[Et] = pt), (ct = Et);
                    break;
                  }
                if (ct === -1) break;
              }
              const Rt = E[ct];
              Rt && Rt.connect(pt);
            }
          }
          const G = new D(),
            K = new D();
          function H(k, $, pt) {
            G.setFromMatrixPosition($.matrixWorld),
              K.setFromMatrixPosition(pt.matrixWorld);
            const ct = G.distanceTo(K),
              Rt = $.projectionMatrix.elements,
              Et = pt.projectionMatrix.elements,
              Nt = Rt[14] / (Rt[10] - 1),
              Kt = Rt[14] / (Rt[10] + 1),
              Ft = (Rt[9] + 1) / Rt[5],
              w = (Rt[9] - 1) / Rt[5],
              Te = (Rt[8] - 1) / Rt[0],
              Ut = (Et[8] + 1) / Et[0],
              zt = Nt * Te,
              Tt = Nt * Ut,
              Jt = ct / (-Te + Ut),
              wt = Jt * -Te;
            if (
              ($.matrixWorld.decompose(k.position, k.quaternion, k.scale),
              k.translateX(wt),
              k.translateZ(Jt),
              k.matrixWorld.compose(k.position, k.quaternion, k.scale),
              k.matrixWorldInverse.copy(k.matrixWorld).invert(),
              Rt[10] === -1)
            )
              k.projectionMatrix.copy($.projectionMatrix),
                k.projectionMatrixInverse.copy($.projectionMatrixInverse);
            else {
              const y = Nt + Jt,
                g = Kt + Jt,
                U = zt - wt,
                X = Tt + (ct - wt),
                Z = ((Ft * Kt) / g) * y,
                W = ((w * Kt) / g) * y;
              k.projectionMatrix.makePerspective(U, X, Z, W, y, g),
                k.projectionMatrixInverse.copy(k.projectionMatrix).invert();
            }
          }
          function ot(k, $) {
            $ === null
              ? k.matrixWorld.copy(k.matrix)
              : k.matrixWorld.multiplyMatrices($.matrixWorld, k.matrix),
              k.matrixWorldInverse.copy(k.matrixWorld).invert();
          }
          this.updateCamera = function (k) {
            if (r === null) return;
            let $ = k.near,
              pt = k.far;
            M.texture !== null &&
              (M.depthNear > 0 && ($ = M.depthNear),
              M.depthFar > 0 && (pt = M.depthFar)),
              (_.near = F.near = b.near = $),
              (_.far = F.far = b.far = pt),
              (S !== _.near || V !== _.far) &&
                (r.updateRenderState({ depthNear: _.near, depthFar: _.far }),
                (S = _.near),
                (V = _.far));
            const ct = k.parent,
              Rt = _.cameras;
            ot(_, ct);
            for (let Et = 0; Et < Rt.length; Et++) ot(Rt[Et], ct);
            Rt.length === 2
              ? H(_, b, F)
              : _.projectionMatrix.copy(b.projectionMatrix),
              lt(k, _, ct);
          };
          function lt(k, $, pt) {
            pt === null
              ? k.matrix.copy($.matrixWorld)
              : (k.matrix.copy(pt.matrixWorld),
                k.matrix.invert(),
                k.matrix.multiply($.matrixWorld)),
              k.matrix.decompose(k.position, k.quaternion, k.scale),
              k.updateMatrixWorld(!0),
              k.projectionMatrix.copy($.projectionMatrix),
              k.projectionMatrixInverse.copy($.projectionMatrixInverse),
              k.isPerspectiveCamera &&
                ((k.fov =
                  Bi * 2 * Math.atan(1 / k.projectionMatrix.elements[5])),
                (k.zoom = 1));
          }
          (this.getCamera = function () {
            return _;
          }),
            (this.getFoveation = function () {
              if (!(p === null && m === null)) return l;
            }),
            (this.setFoveation = function (k) {
              (l = k),
                p !== null && (p.fixedFoveation = k),
                m !== null &&
                  m.fixedFoveation !== void 0 &&
                  (m.fixedFoveation = k);
            }),
            (this.hasDepthSensing = function () {
              return M.texture !== null;
            }),
            (this.getDepthSensingMesh = function () {
              return M.getMesh(_);
            });
          let _t = null;
          function Gt(k, $) {
            if (((h = $.getViewerPose(c || a)), (v = $), h !== null)) {
              const pt = h.views;
              m !== null &&
                (t.setRenderTargetFramebuffer(T, m.framebuffer),
                t.setRenderTarget(T));
              let ct = !1;
              pt.length !== _.cameras.length &&
                ((_.cameras.length = 0), (ct = !0));
              for (let Et = 0; Et < pt.length; Et++) {
                const Nt = pt[Et];
                let Kt = null;
                if (m !== null) Kt = m.getViewport(Nt);
                else {
                  const w = f.getViewSubImage(p, Nt);
                  (Kt = w.viewport),
                    Et === 0 &&
                      (t.setRenderTargetTextures(
                        T,
                        w.colorTexture,
                        p.ignoreDepthValues ? void 0 : w.depthStencilTexture
                      ),
                      t.setRenderTarget(T));
                }
                let Ft = tt[Et];
                Ft === void 0 &&
                  ((Ft = new Pe()),
                  Ft.layers.enable(Et),
                  (Ft.viewport = new Zt()),
                  (tt[Et] = Ft)),
                  Ft.matrix.fromArray(Nt.transform.matrix),
                  Ft.matrix.decompose(Ft.position, Ft.quaternion, Ft.scale),
                  Ft.projectionMatrix.fromArray(Nt.projectionMatrix),
                  Ft.projectionMatrixInverse.copy(Ft.projectionMatrix).invert(),
                  Ft.viewport.set(Kt.x, Kt.y, Kt.width, Kt.height),
                  Et === 0 &&
                    (_.matrix.copy(Ft.matrix),
                    _.matrix.decompose(_.position, _.quaternion, _.scale)),
                  ct === !0 && _.cameras.push(Ft);
              }
              const Rt = r.enabledFeatures;
              if (Rt && Rt.includes("depth-sensing")) {
                const Et = f.getDepthInformation(pt[0]);
                Et && Et.isValid && Et.texture && M.init(t, Et, r.renderState);
              }
            }
            for (let pt = 0; pt < E.length; pt++) {
              const ct = A[pt],
                Rt = E[pt];
              ct !== null && Rt !== void 0 && Rt.update(ct, $, c || a);
            }
            _t && _t(k, $),
              $.detectedPlanes &&
                n.dispatchEvent({ type: "planesdetected", data: $ }),
              (v = null);
          }
          const Yt = new dl();
          Yt.setAnimationLoop(Gt),
            (this.setAnimationLoop = function (k) {
              _t = k;
            }),
            (this.dispose = function () {});
        }
      }
      const In = new je(),
        Xp = new ee();
      function Yp(i, t) {
        function e(u, d) {
          u.matrixAutoUpdate === !0 && u.updateMatrix(), d.value.copy(u.matrix);
        }
        function n(u, d) {
          d.color.getRGB(u.fogColor.value, cl(i)),
            d.isFog
              ? ((u.fogNear.value = d.near), (u.fogFar.value = d.far))
              : d.isFogExp2 && (u.fogDensity.value = d.density);
        }
        function r(u, d, T, E, A) {
          d.isMeshBasicMaterial || d.isMeshLambertMaterial
            ? s(u, d)
            : d.isMeshToonMaterial
            ? (s(u, d), f(u, d))
            : d.isMeshPhongMaterial
            ? (s(u, d), h(u, d))
            : d.isMeshStandardMaterial
            ? (s(u, d), p(u, d), d.isMeshPhysicalMaterial && m(u, d, A))
            : d.isMeshMatcapMaterial
            ? (s(u, d), v(u, d))
            : d.isMeshDepthMaterial
            ? s(u, d)
            : d.isMeshDistanceMaterial
            ? (s(u, d), M(u, d))
            : d.isMeshNormalMaterial
            ? s(u, d)
            : d.isLineBasicMaterial
            ? (a(u, d), d.isLineDashedMaterial && o(u, d))
            : d.isPointsMaterial
            ? l(u, d, T, E)
            : d.isSpriteMaterial
            ? c(u, d)
            : d.isShadowMaterial
            ? (u.color.value.copy(d.color), (u.opacity.value = d.opacity))
            : d.isShaderMaterial && (d.uniformsNeedUpdate = !1);
        }
        function s(u, d) {
          (u.opacity.value = d.opacity),
            d.color && u.diffuse.value.copy(d.color),
            d.emissive &&
              u.emissive.value
                .copy(d.emissive)
                .multiplyScalar(d.emissiveIntensity),
            d.map && ((u.map.value = d.map), e(d.map, u.mapTransform)),
            d.alphaMap &&
              ((u.alphaMap.value = d.alphaMap),
              e(d.alphaMap, u.alphaMapTransform)),
            d.bumpMap &&
              ((u.bumpMap.value = d.bumpMap),
              e(d.bumpMap, u.bumpMapTransform),
              (u.bumpScale.value = d.bumpScale),
              d.side === ye && (u.bumpScale.value *= -1)),
            d.normalMap &&
              ((u.normalMap.value = d.normalMap),
              e(d.normalMap, u.normalMapTransform),
              u.normalScale.value.copy(d.normalScale),
              d.side === ye && u.normalScale.value.negate()),
            d.displacementMap &&
              ((u.displacementMap.value = d.displacementMap),
              e(d.displacementMap, u.displacementMapTransform),
              (u.displacementScale.value = d.displacementScale),
              (u.displacementBias.value = d.displacementBias)),
            d.emissiveMap &&
              ((u.emissiveMap.value = d.emissiveMap),
              e(d.emissiveMap, u.emissiveMapTransform)),
            d.specularMap &&
              ((u.specularMap.value = d.specularMap),
              e(d.specularMap, u.specularMapTransform)),
            d.alphaTest > 0 && (u.alphaTest.value = d.alphaTest);
          const T = t.get(d),
            E = T.envMap,
            A = T.envMapRotation;
          E &&
            ((u.envMap.value = E),
            In.copy(A),
            (In.x *= -1),
            (In.y *= -1),
            (In.z *= -1),
            E.isCubeTexture &&
              E.isRenderTargetTexture === !1 &&
              ((In.y *= -1), (In.z *= -1)),
            u.envMapRotation.value.setFromMatrix4(Xp.makeRotationFromEuler(In)),
            (u.flipEnvMap.value =
              E.isCubeTexture && E.isRenderTargetTexture === !1 ? -1 : 1),
            (u.reflectivity.value = d.reflectivity),
            (u.ior.value = d.ior),
            (u.refractionRatio.value = d.refractionRatio)),
            d.lightMap &&
              ((u.lightMap.value = d.lightMap),
              (u.lightMapIntensity.value = d.lightMapIntensity),
              e(d.lightMap, u.lightMapTransform)),
            d.aoMap &&
              ((u.aoMap.value = d.aoMap),
              (u.aoMapIntensity.value = d.aoMapIntensity),
              e(d.aoMap, u.aoMapTransform));
        }
        function a(u, d) {
          u.diffuse.value.copy(d.color),
            (u.opacity.value = d.opacity),
            d.map && ((u.map.value = d.map), e(d.map, u.mapTransform));
        }
        function o(u, d) {
          (u.dashSize.value = d.dashSize),
            (u.totalSize.value = d.dashSize + d.gapSize),
            (u.scale.value = d.scale);
        }
        function l(u, d, T, E) {
          u.diffuse.value.copy(d.color),
            (u.opacity.value = d.opacity),
            (u.size.value = d.size * T),
            (u.scale.value = E * 0.5),
            d.map && ((u.map.value = d.map), e(d.map, u.uvTransform)),
            d.alphaMap &&
              ((u.alphaMap.value = d.alphaMap),
              e(d.alphaMap, u.alphaMapTransform)),
            d.alphaTest > 0 && (u.alphaTest.value = d.alphaTest);
        }
        function c(u, d) {
          u.diffuse.value.copy(d.color),
            (u.opacity.value = d.opacity),
            (u.rotation.value = d.rotation),
            d.map && ((u.map.value = d.map), e(d.map, u.mapTransform)),
            d.alphaMap &&
              ((u.alphaMap.value = d.alphaMap),
              e(d.alphaMap, u.alphaMapTransform)),
            d.alphaTest > 0 && (u.alphaTest.value = d.alphaTest);
        }
        function h(u, d) {
          u.specular.value.copy(d.specular),
            (u.shininess.value = Math.max(d.shininess, 1e-4));
        }
        function f(u, d) {
          d.gradientMap && (u.gradientMap.value = d.gradientMap);
        }
        function p(u, d) {
          (u.metalness.value = d.metalness),
            d.metalnessMap &&
              ((u.metalnessMap.value = d.metalnessMap),
              e(d.metalnessMap, u.metalnessMapTransform)),
            (u.roughness.value = d.roughness),
            d.roughnessMap &&
              ((u.roughnessMap.value = d.roughnessMap),
              e(d.roughnessMap, u.roughnessMapTransform)),
            d.envMap && (u.envMapIntensity.value = d.envMapIntensity);
        }
        function m(u, d, T) {
          (u.ior.value = d.ior),
            d.sheen > 0 &&
              (u.sheenColor.value.copy(d.sheenColor).multiplyScalar(d.sheen),
              (u.sheenRoughness.value = d.sheenRoughness),
              d.sheenColorMap &&
                ((u.sheenColorMap.value = d.sheenColorMap),
                e(d.sheenColorMap, u.sheenColorMapTransform)),
              d.sheenRoughnessMap &&
                ((u.sheenRoughnessMap.value = d.sheenRoughnessMap),
                e(d.sheenRoughnessMap, u.sheenRoughnessMapTransform))),
            d.clearcoat > 0 &&
              ((u.clearcoat.value = d.clearcoat),
              (u.clearcoatRoughness.value = d.clearcoatRoughness),
              d.clearcoatMap &&
                ((u.clearcoatMap.value = d.clearcoatMap),
                e(d.clearcoatMap, u.clearcoatMapTransform)),
              d.clearcoatRoughnessMap &&
                ((u.clearcoatRoughnessMap.value = d.clearcoatRoughnessMap),
                e(d.clearcoatRoughnessMap, u.clearcoatRoughnessMapTransform)),
              d.clearcoatNormalMap &&
                ((u.clearcoatNormalMap.value = d.clearcoatNormalMap),
                e(d.clearcoatNormalMap, u.clearcoatNormalMapTransform),
                u.clearcoatNormalScale.value.copy(d.clearcoatNormalScale),
                d.side === ye && u.clearcoatNormalScale.value.negate())),
            d.dispersion > 0 && (u.dispersion.value = d.dispersion),
            d.iridescence > 0 &&
              ((u.iridescence.value = d.iridescence),
              (u.iridescenceIOR.value = d.iridescenceIOR),
              (u.iridescenceThicknessMinimum.value =
                d.iridescenceThicknessRange[0]),
              (u.iridescenceThicknessMaximum.value =
                d.iridescenceThicknessRange[1]),
              d.iridescenceMap &&
                ((u.iridescenceMap.value = d.iridescenceMap),
                e(d.iridescenceMap, u.iridescenceMapTransform)),
              d.iridescenceThicknessMap &&
                ((u.iridescenceThicknessMap.value = d.iridescenceThicknessMap),
                e(
                  d.iridescenceThicknessMap,
                  u.iridescenceThicknessMapTransform
                ))),
            d.transmission > 0 &&
              ((u.transmission.value = d.transmission),
              (u.transmissionSamplerMap.value = T.texture),
              u.transmissionSamplerSize.value.set(T.width, T.height),
              d.transmissionMap &&
                ((u.transmissionMap.value = d.transmissionMap),
                e(d.transmissionMap, u.transmissionMapTransform)),
              (u.thickness.value = d.thickness),
              d.thicknessMap &&
                ((u.thicknessMap.value = d.thicknessMap),
                e(d.thicknessMap, u.thicknessMapTransform)),
              (u.attenuationDistance.value = d.attenuationDistance),
              u.attenuationColor.value.copy(d.attenuationColor)),
            d.anisotropy > 0 &&
              (u.anisotropyVector.value.set(
                d.anisotropy * Math.cos(d.anisotropyRotation),
                d.anisotropy * Math.sin(d.anisotropyRotation)
              ),
              d.anisotropyMap &&
                ((u.anisotropyMap.value = d.anisotropyMap),
                e(d.anisotropyMap, u.anisotropyMapTransform))),
            (u.specularIntensity.value = d.specularIntensity),
            u.specularColor.value.copy(d.specularColor),
            d.specularColorMap &&
              ((u.specularColorMap.value = d.specularColorMap),
              e(d.specularColorMap, u.specularColorMapTransform)),
            d.specularIntensityMap &&
              ((u.specularIntensityMap.value = d.specularIntensityMap),
              e(d.specularIntensityMap, u.specularIntensityMapTransform));
        }
        function v(u, d) {
          d.matcap && (u.matcap.value = d.matcap);
        }
        function M(u, d) {
          const T = t.get(d).light;
          u.referencePosition.value.setFromMatrixPosition(T.matrixWorld),
            (u.nearDistance.value = T.shadow.camera.near),
            (u.farDistance.value = T.shadow.camera.far);
        }
        return { refreshFogUniforms: n, refreshMaterialUniforms: r };
      }
      function qp(i, t, e, n) {
        let r = {},
          s = {},
          a = [];
        const o = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
        function l(T, E) {
          const A = E.program;
          n.uniformBlockBinding(T, A);
        }
        function c(T, E) {
          let A = r[T.id];
          A === void 0 &&
            (v(T), (A = h(T)), (r[T.id] = A), T.addEventListener("dispose", u));
          const O = E.program;
          n.updateUBOMapping(T, O);
          const P = t.render.frame;
          s[T.id] !== P && (p(T), (s[T.id] = P));
        }
        function h(T) {
          const E = f();
          T.__bindingPointIndex = E;
          const A = i.createBuffer(),
            O = T.__size,
            P = T.usage;
          return (
            i.bindBuffer(i.UNIFORM_BUFFER, A),
            i.bufferData(i.UNIFORM_BUFFER, O, P),
            i.bindBuffer(i.UNIFORM_BUFFER, null),
            i.bindBufferBase(i.UNIFORM_BUFFER, E, A),
            A
          );
        }
        function f() {
          for (let T = 0; T < o; T++)
            if (a.indexOf(T) === -1) return a.push(T), T;
          return (
            console.error(
              "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
            ),
            0
          );
        }
        function p(T) {
          const E = r[T.id],
            A = T.uniforms,
            O = T.__cache;
          i.bindBuffer(i.UNIFORM_BUFFER, E);
          for (let P = 0, b = A.length; P < b; P++) {
            const F = Array.isArray(A[P]) ? A[P] : [A[P]];
            for (let tt = 0, _ = F.length; tt < _; tt++) {
              const S = F[tt];
              if (m(S, P, tt, O) === !0) {
                const V = S.__offset,
                  z = Array.isArray(S.value) ? S.value : [S.value];
                let Y = 0;
                for (let j = 0; j < z.length; j++) {
                  const G = z[j],
                    K = M(G);
                  typeof G == "number" || typeof G == "boolean"
                    ? ((S.__data[0] = G),
                      i.bufferSubData(i.UNIFORM_BUFFER, V + Y, S.__data))
                    : G.isMatrix3
                    ? ((S.__data[0] = G.elements[0]),
                      (S.__data[1] = G.elements[1]),
                      (S.__data[2] = G.elements[2]),
                      (S.__data[3] = 0),
                      (S.__data[4] = G.elements[3]),
                      (S.__data[5] = G.elements[4]),
                      (S.__data[6] = G.elements[5]),
                      (S.__data[7] = 0),
                      (S.__data[8] = G.elements[6]),
                      (S.__data[9] = G.elements[7]),
                      (S.__data[10] = G.elements[8]),
                      (S.__data[11] = 0))
                    : (G.toArray(S.__data, Y),
                      (Y += K.storage / Float32Array.BYTES_PER_ELEMENT));
                }
                i.bufferSubData(i.UNIFORM_BUFFER, V, S.__data);
              }
            }
          }
          i.bindBuffer(i.UNIFORM_BUFFER, null);
        }
        function m(T, E, A, O) {
          const P = T.value,
            b = E + "_" + A;
          if (O[b] === void 0)
            return (
              typeof P == "number" || typeof P == "boolean"
                ? (O[b] = P)
                : (O[b] = P.clone()),
              !0
            );
          {
            const F = O[b];
            if (typeof P == "number" || typeof P == "boolean") {
              if (F !== P) return (O[b] = P), !0;
            } else if (F.equals(P) === !1) return F.copy(P), !0;
          }
          return !1;
        }
        function v(T) {
          const E = T.uniforms;
          let A = 0;
          const O = 16;
          for (let b = 0, F = E.length; b < F; b++) {
            const tt = Array.isArray(E[b]) ? E[b] : [E[b]];
            for (let _ = 0, S = tt.length; _ < S; _++) {
              const V = tt[_],
                z = Array.isArray(V.value) ? V.value : [V.value];
              for (let Y = 0, j = z.length; Y < j; Y++) {
                const G = z[Y],
                  K = M(G),
                  H = A % O,
                  ot = H % K.boundary,
                  lt = H + ot;
                (A += ot),
                  lt !== 0 && O - lt < K.storage && (A += O - lt),
                  (V.__data = new Float32Array(
                    K.storage / Float32Array.BYTES_PER_ELEMENT
                  )),
                  (V.__offset = A),
                  (A += K.storage);
              }
            }
          }
          const P = A % O;
          return P > 0 && (A += O - P), (T.__size = A), (T.__cache = {}), this;
        }
        function M(T) {
          const E = { boundary: 0, storage: 0 };
          return (
            typeof T == "number" || typeof T == "boolean"
              ? ((E.boundary = 4), (E.storage = 4))
              : T.isVector2
              ? ((E.boundary = 8), (E.storage = 8))
              : T.isVector3 || T.isColor
              ? ((E.boundary = 16), (E.storage = 12))
              : T.isVector4
              ? ((E.boundary = 16), (E.storage = 16))
              : T.isMatrix3
              ? ((E.boundary = 48), (E.storage = 48))
              : T.isMatrix4
              ? ((E.boundary = 64), (E.storage = 64))
              : T.isTexture
              ? console.warn(
                  "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
                )
              : console.warn(
                  "THREE.WebGLRenderer: Unsupported uniform value type.",
                  T
                ),
            E
          );
        }
        function u(T) {
          const E = T.target;
          E.removeEventListener("dispose", u);
          const A = a.indexOf(E.__bindingPointIndex);
          a.splice(A, 1),
            i.deleteBuffer(r[E.id]),
            delete r[E.id],
            delete s[E.id];
        }
        function d() {
          for (const T in r) i.deleteBuffer(r[T]);
          (a = []), (r = {}), (s = {});
        }
        return { bind: l, update: c, dispose: d };
      }
      class Kp {
        constructor(t = {}) {
          const {
            canvas: e = Uc(),
            context: n = null,
            depth: r = !0,
            stencil: s = !1,
            alpha: a = !1,
            antialias: o = !1,
            premultipliedAlpha: l = !0,
            preserveDrawingBuffer: c = !1,
            powerPreference: h = "default",
            failIfMajorPerformanceCaveat: f = !1,
          } = t;
          this.isWebGLRenderer = !0;
          let p;
          if (n !== null) {
            if (
              typeof WebGLRenderingContext < "u" &&
              n instanceof WebGLRenderingContext
            )
              throw new Error(
                "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
              );
            p = n.getContextAttributes().alpha;
          } else p = a;
          const m = new Uint32Array(4),
            v = new Int32Array(4);
          let M = null,
            u = null;
          const d = [],
            T = [];
          (this.domElement = e),
            (this.debug = { checkShaderErrors: !0, onShaderError: null }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this._outputColorSpace = pe),
            (this.toneMapping = yn),
            (this.toneMappingExposure = 1);
          const E = this;
          let A = !1,
            O = 0,
            P = 0,
            b = null,
            F = -1,
            tt = null;
          const _ = new Zt(),
            S = new Zt();
          let V = null;
          const z = new Bt(0);
          let Y = 0,
            j = e.width,
            G = e.height,
            K = 1,
            H = null,
            ot = null;
          const lt = new Zt(0, 0, j, G),
            _t = new Zt(0, 0, j, G);
          let Gt = !1;
          const Yt = new ma();
          let k = !1,
            $ = !1;
          const pt = new ee(),
            ct = new ee(),
            Rt = new D(),
            Et = new Zt(),
            Nt = {
              background: null,
              fog: null,
              environment: null,
              overrideMaterial: null,
              isScene: !0,
            };
          let Kt = !1;
          function Ft() {
            return b === null ? K : 1;
          }
          let w = n;
          function Te(x, C) {
            return e.getContext(x, C);
          }
          try {
            const x = {
              alpha: !0,
              depth: r,
              stencil: s,
              antialias: o,
              premultipliedAlpha: l,
              preserveDrawingBuffer: c,
              powerPreference: h,
              failIfMajorPerformanceCaveat: f,
            };
            if (
              ("setAttribute" in e &&
                e.setAttribute("data-engine", `three.js r${sa}`),
              e.addEventListener("webglcontextlost", q, !1),
              e.addEventListener("webglcontextrestored", it, !1),
              e.addEventListener("webglcontextcreationerror", at, !1),
              w === null)
            ) {
              const C = "webgl2";
              if (((w = Te(C, x)), w === null))
                throw Te(C)
                  ? new Error(
                      "Error creating WebGL context with your selected attributes."
                    )
                  : new Error("Error creating WebGL context.");
            }
          } catch (x) {
            throw (console.error("THREE.WebGLRenderer: " + x.message), x);
          }
          let Ut,
            zt,
            Tt,
            Jt,
            wt,
            y,
            g,
            U,
            X,
            Z,
            W,
            gt,
            nt,
            ht,
            Ht,
            J,
            ut,
            At,
            bt,
            dt,
            It,
            Ct,
            $t,
            R;
          function st() {
            (Ut = new Jd(w)),
              Ut.init(),
              (Ct = new Bp(w, Ut)),
              (zt = new Xd(w, Ut, t, Ct)),
              (Tt = new Np(w)),
              zt.reverseDepthBuffer && Tt.buffers.depth.setReversed(!0),
              (Jt = new ef(w)),
              (wt = new Mp()),
              (y = new Op(w, Ut, Tt, wt, zt, Ct, Jt)),
              (g = new qd(E)),
              (U = new $d(E)),
              (X = new oh(w)),
              ($t = new kd(w, X)),
              (Z = new Qd(w, X, Jt, $t)),
              (W = new rf(w, Z, X, Jt)),
              (bt = new nf(w, zt, y)),
              (J = new Yd(wt)),
              (gt = new xp(E, g, U, Ut, zt, $t, J)),
              (nt = new Yp(E, wt)),
              (ht = new Ep()),
              (Ht = new Rp(Ut)),
              (At = new Vd(E, g, U, Tt, W, p, l)),
              (ut = new Up(E, W, zt)),
              (R = new qp(w, Jt, zt, Tt)),
              (dt = new Wd(w, Ut, Jt)),
              (It = new tf(w, Ut, Jt)),
              (Jt.programs = gt.programs),
              (E.capabilities = zt),
              (E.extensions = Ut),
              (E.properties = wt),
              (E.renderLists = ht),
              (E.shadowMap = ut),
              (E.state = Tt),
              (E.info = Jt);
          }
          st();
          const B = new Wp(E, w);
          (this.xr = B),
            (this.getContext = function () {
              return w;
            }),
            (this.getContextAttributes = function () {
              return w.getContextAttributes();
            }),
            (this.forceContextLoss = function () {
              const x = Ut.get("WEBGL_lose_context");
              x && x.loseContext();
            }),
            (this.forceContextRestore = function () {
              const x = Ut.get("WEBGL_lose_context");
              x && x.restoreContext();
            }),
            (this.getPixelRatio = function () {
              return K;
            }),
            (this.setPixelRatio = function (x) {
              x !== void 0 && ((K = x), this.setSize(j, G, !1));
            }),
            (this.getSize = function (x) {
              return x.set(j, G);
            }),
            (this.setSize = function (x, C, I = !0) {
              if (B.isPresenting) {
                console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                );
                return;
              }
              (j = x),
                (G = C),
                (e.width = Math.floor(x * K)),
                (e.height = Math.floor(C * K)),
                I === !0 &&
                  ((e.style.width = x + "px"), (e.style.height = C + "px")),
                this.setViewport(0, 0, x, C);
            }),
            (this.getDrawingBufferSize = function (x) {
              return x.set(j * K, G * K).floor();
            }),
            (this.setDrawingBufferSize = function (x, C, I) {
              (j = x),
                (G = C),
                (K = I),
                (e.width = Math.floor(x * I)),
                (e.height = Math.floor(C * I)),
                this.setViewport(0, 0, x, C);
            }),
            (this.getCurrentViewport = function (x) {
              return x.copy(_);
            }),
            (this.getViewport = function (x) {
              return x.copy(lt);
            }),
            (this.setViewport = function (x, C, I, N) {
              x.isVector4 ? lt.set(x.x, x.y, x.z, x.w) : lt.set(x, C, I, N),
                Tt.viewport(_.copy(lt).multiplyScalar(K).round());
            }),
            (this.getScissor = function (x) {
              return x.copy(_t);
            }),
            (this.setScissor = function (x, C, I, N) {
              x.isVector4 ? _t.set(x.x, x.y, x.z, x.w) : _t.set(x, C, I, N),
                Tt.scissor(S.copy(_t).multiplyScalar(K).round());
            }),
            (this.getScissorTest = function () {
              return Gt;
            }),
            (this.setScissorTest = function (x) {
              Tt.setScissorTest((Gt = x));
            }),
            (this.setOpaqueSort = function (x) {
              H = x;
            }),
            (this.setTransparentSort = function (x) {
              ot = x;
            }),
            (this.getClearColor = function (x) {
              return x.copy(At.getClearColor());
            }),
            (this.setClearColor = function () {
              At.setClearColor.apply(At, arguments);
            }),
            (this.getClearAlpha = function () {
              return At.getClearAlpha();
            }),
            (this.setClearAlpha = function () {
              At.setClearAlpha.apply(At, arguments);
            }),
            (this.clear = function (x = !0, C = !0, I = !0) {
              let N = 0;
              if (x) {
                let L = !1;
                if (b !== null) {
                  const Q = b.texture.format;
                  L = Q === ua || Q === ha || Q === ca;
                }
                if (L) {
                  const Q = b.texture.type,
                    rt =
                      Q === ln ||
                      Q === Hn ||
                      Q === Oi ||
                      Q === gi ||
                      Q === oa ||
                      Q === la,
                    ft = At.getClearColor(),
                    mt = At.getClearAlpha(),
                    St = ft.r,
                    yt = ft.g,
                    vt = ft.b;
                  rt
                    ? ((m[0] = St),
                      (m[1] = yt),
                      (m[2] = vt),
                      (m[3] = mt),
                      w.clearBufferuiv(w.COLOR, 0, m))
                    : ((v[0] = St),
                      (v[1] = yt),
                      (v[2] = vt),
                      (v[3] = mt),
                      w.clearBufferiv(w.COLOR, 0, v));
                } else N |= w.COLOR_BUFFER_BIT;
              }
              C &&
                ((N |= w.DEPTH_BUFFER_BIT),
                w.clearDepth(this.capabilities.reverseDepthBuffer ? 0 : 1)),
                I &&
                  ((N |= w.STENCIL_BUFFER_BIT),
                  this.state.buffers.stencil.setMask(4294967295)),
                w.clear(N);
            }),
            (this.clearColor = function () {
              this.clear(!0, !1, !1);
            }),
            (this.clearDepth = function () {
              this.clear(!1, !0, !1);
            }),
            (this.clearStencil = function () {
              this.clear(!1, !1, !0);
            }),
            (this.dispose = function () {
              e.removeEventListener("webglcontextlost", q, !1),
                e.removeEventListener("webglcontextrestored", it, !1),
                e.removeEventListener("webglcontextcreationerror", at, !1),
                ht.dispose(),
                Ht.dispose(),
                wt.dispose(),
                g.dispose(),
                U.dispose(),
                W.dispose(),
                $t.dispose(),
                R.dispose(),
                gt.dispose(),
                B.dispose(),
                B.removeEventListener("sessionstart", xa),
                B.removeEventListener("sessionend", Ma),
                Rn.stop();
            });
          function q(x) {
            x.preventDefault(),
              console.log("THREE.WebGLRenderer: Context Lost."),
              (A = !0);
          }
          function it() {
            console.log("THREE.WebGLRenderer: Context Restored."), (A = !1);
            const x = Jt.autoReset,
              C = ut.enabled,
              I = ut.autoUpdate,
              N = ut.needsUpdate,
              L = ut.type;
            st(),
              (Jt.autoReset = x),
              (ut.enabled = C),
              (ut.autoUpdate = I),
              (ut.needsUpdate = N),
              (ut.type = L);
          }
          function at(x) {
            console.error(
              "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
              x.statusMessage
            );
          }
          function Ot(x) {
            const C = x.target;
            C.removeEventListener("dispose", Ot), re(C);
          }
          function re(x) {
            Me(x), wt.remove(x);
          }
          function Me(x) {
            const C = wt.get(x).programs;
            C !== void 0 &&
              (C.forEach(function (I) {
                gt.releaseProgram(I);
              }),
              x.isShaderMaterial && gt.releaseShaderCache(x));
          }
          this.renderBufferDirect = function (x, C, I, N, L, Q) {
            C === null && (C = Nt);
            const rt = L.isMesh && L.matrixWorld.determinant() < 0,
              ft = Tl(x, C, I, N, L);
            Tt.setMaterial(N, rt);
            let mt = I.index,
              St = 1;
            if (N.wireframe === !0) {
              if (((mt = Z.getWireframeAttribute(I)), mt === void 0)) return;
              St = 2;
            }
            const yt = I.drawRange,
              vt = I.attributes.position;
            let qt = yt.start * St,
              Qt = (yt.start + yt.count) * St;
            Q !== null &&
              ((qt = Math.max(qt, Q.start * St)),
              (Qt = Math.min(Qt, (Q.start + Q.count) * St))),
              mt !== null
                ? ((qt = Math.max(qt, 0)), (Qt = Math.min(Qt, mt.count)))
                : vt != null &&
                  ((qt = Math.max(qt, 0)), (Qt = Math.min(Qt, vt.count)));
            const ne = Qt - qt;
            if (ne < 0 || ne === 1 / 0) return;
            $t.setup(L, N, ft, I, mt);
            let Ae,
              kt = dt;
            if (
              (mt !== null && ((Ae = X.get(mt)), (kt = It), kt.setIndex(Ae)),
              L.isMesh)
            )
              N.wireframe === !0
                ? (Tt.setLineWidth(N.wireframeLinewidth * Ft()),
                  kt.setMode(w.LINES))
                : kt.setMode(w.TRIANGLES);
            else if (L.isLine) {
              let xt = N.linewidth;
              xt === void 0 && (xt = 1),
                Tt.setLineWidth(xt * Ft()),
                L.isLineSegments
                  ? kt.setMode(w.LINES)
                  : L.isLineLoop
                  ? kt.setMode(w.LINE_LOOP)
                  : kt.setMode(w.LINE_STRIP);
            } else
              L.isPoints
                ? kt.setMode(w.POINTS)
                : L.isSprite && kt.setMode(w.TRIANGLES);
            if (L.isBatchedMesh)
              if (L._multiDrawInstances !== null)
                kt.renderMultiDrawInstances(
                  L._multiDrawStarts,
                  L._multiDrawCounts,
                  L._multiDrawCount,
                  L._multiDrawInstances
                );
              else if (Ut.get("WEBGL_multi_draw"))
                kt.renderMultiDraw(
                  L._multiDrawStarts,
                  L._multiDrawCounts,
                  L._multiDrawCount
                );
              else {
                const xt = L._multiDrawStarts,
                  he = L._multiDrawCounts,
                  Wt = L._multiDrawCount,
                  Oe = mt ? X.get(mt).bytesPerElement : 1,
                  Wn = wt.get(N).currentProgram.getUniforms();
                for (let be = 0; be < Wt; be++)
                  Wn.setValue(w, "_gl_DrawID", be),
                    kt.render(xt[be] / Oe, he[be]);
              }
            else if (L.isInstancedMesh) kt.renderInstances(qt, ne, L.count);
            else if (I.isInstancedBufferGeometry) {
              const xt =
                  I._maxInstanceCount !== void 0 ? I._maxInstanceCount : 1 / 0,
                he = Math.min(I.instanceCount, xt);
              kt.renderInstances(qt, ne, he);
            } else kt.render(qt, ne);
          };
          function Vt(x, C, I) {
            x.transparent === !0 && x.side === sn && x.forceSinglePass === !1
              ? ((x.side = ye),
                (x.needsUpdate = !0),
                Wi(x, C, I),
                (x.side = Tn),
                (x.needsUpdate = !0),
                Wi(x, C, I),
                (x.side = sn))
              : Wi(x, C, I);
          }
          (this.compile = function (x, C, I = null) {
            I === null && (I = x),
              (u = Ht.get(I)),
              u.init(C),
              T.push(u),
              I.traverseVisible(function (L) {
                L.isLight &&
                  L.layers.test(C.layers) &&
                  (u.pushLight(L), L.castShadow && u.pushShadow(L));
              }),
              x !== I &&
                x.traverseVisible(function (L) {
                  L.isLight &&
                    L.layers.test(C.layers) &&
                    (u.pushLight(L), L.castShadow && u.pushShadow(L));
                }),
              u.setupLights();
            const N = new Set();
            return (
              x.traverse(function (L) {
                if (!(L.isMesh || L.isPoints || L.isLine || L.isSprite)) return;
                const Q = L.material;
                if (Q)
                  if (Array.isArray(Q))
                    for (let rt = 0; rt < Q.length; rt++) {
                      const ft = Q[rt];
                      Vt(ft, I, L), N.add(ft);
                    }
                  else Vt(Q, I, L), N.add(Q);
              }),
              T.pop(),
              (u = null),
              N
            );
          }),
            (this.compileAsync = function (x, C, I = null) {
              const N = this.compile(x, C, I);
              return new Promise((L) => {
                function Q() {
                  if (
                    (N.forEach(function (rt) {
                      wt.get(rt).currentProgram.isReady() && N.delete(rt);
                    }),
                    N.size === 0)
                  ) {
                    L(x);
                    return;
                  }
                  setTimeout(Q, 10);
                }
                Ut.get("KHR_parallel_shader_compile") !== null
                  ? Q()
                  : setTimeout(Q, 10);
              });
            });
          let Se = null;
          function Ze(x) {
            Se && Se(x);
          }
          function xa() {
            Rn.stop();
          }
          function Ma() {
            Rn.start();
          }
          const Rn = new dl();
          Rn.setAnimationLoop(Ze),
            typeof self < "u" && Rn.setContext(self),
            (this.setAnimationLoop = function (x) {
              (Se = x),
                B.setAnimationLoop(x),
                x === null ? Rn.stop() : Rn.start();
            }),
            B.addEventListener("sessionstart", xa),
            B.addEventListener("sessionend", Ma),
            (this.render = function (x, C) {
              if (C !== void 0 && C.isCamera !== !0) {
                console.error(
                  "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                );
                return;
              }
              if (A === !0) return;
              if (
                (x.matrixWorldAutoUpdate === !0 && x.updateMatrixWorld(),
                C.parent === null &&
                  C.matrixWorldAutoUpdate === !0 &&
                  C.updateMatrixWorld(),
                B.enabled === !0 &&
                  B.isPresenting === !0 &&
                  (B.cameraAutoUpdate === !0 && B.updateCamera(C),
                  (C = B.getCamera())),
                x.isScene === !0 && x.onBeforeRender(E, x, C, b),
                (u = Ht.get(x, T.length)),
                u.init(C),
                T.push(u),
                ct.multiplyMatrices(C.projectionMatrix, C.matrixWorldInverse),
                Yt.setFromProjectionMatrix(ct),
                ($ = this.localClippingEnabled),
                (k = J.init(this.clippingPlanes, $)),
                (M = ht.get(x, d.length)),
                M.init(),
                d.push(M),
                B.enabled === !0 && B.isPresenting === !0)
              ) {
                const Q = E.xr.getDepthSensingMesh();
                Q !== null && Nr(Q, C, -1 / 0, E.sortObjects);
              }
              Nr(x, C, 0, E.sortObjects),
                M.finish(),
                E.sortObjects === !0 && M.sort(H, ot),
                (Kt =
                  B.enabled === !1 ||
                  B.isPresenting === !1 ||
                  B.hasDepthSensing() === !1),
                Kt && At.addToRenderList(M, x),
                this.info.render.frame++,
                k === !0 && J.beginShadows();
              const I = u.state.shadowsArray;
              ut.render(I, x, C),
                k === !0 && J.endShadows(),
                this.info.autoReset === !0 && this.info.reset();
              const N = M.opaque,
                L = M.transmissive;
              if ((u.setupLights(), C.isArrayCamera)) {
                const Q = C.cameras;
                if (L.length > 0)
                  for (let rt = 0, ft = Q.length; rt < ft; rt++) {
                    const mt = Q[rt];
                    Ea(N, L, x, mt);
                  }
                Kt && At.render(x);
                for (let rt = 0, ft = Q.length; rt < ft; rt++) {
                  const mt = Q[rt];
                  Sa(M, x, mt, mt.viewport);
                }
              } else
                L.length > 0 && Ea(N, L, x, C), Kt && At.render(x), Sa(M, x, C);
              b !== null &&
                (y.updateMultisampleRenderTarget(b),
                y.updateRenderTargetMipmap(b)),
                x.isScene === !0 && x.onAfterRender(E, x, C),
                $t.resetDefaultState(),
                (F = -1),
                (tt = null),
                T.pop(),
                T.length > 0
                  ? ((u = T[T.length - 1]),
                    k === !0 &&
                      J.setGlobalState(E.clippingPlanes, u.state.camera))
                  : (u = null),
                d.pop(),
                d.length > 0 ? (M = d[d.length - 1]) : (M = null);
            });
          function Nr(x, C, I, N) {
            if (x.visible === !1) return;
            if (x.layers.test(C.layers)) {
              if (x.isGroup) I = x.renderOrder;
              else if (x.isLOD) x.autoUpdate === !0 && x.update(C);
              else if (x.isLight)
                u.pushLight(x), x.castShadow && u.pushShadow(x);
              else if (x.isSprite) {
                if (!x.frustumCulled || Yt.intersectsSprite(x)) {
                  N && Et.setFromMatrixPosition(x.matrixWorld).applyMatrix4(ct);
                  const rt = W.update(x),
                    ft = x.material;
                  ft.visible && M.push(x, rt, ft, I, Et.z, null);
                }
              } else if (
                (x.isMesh || x.isLine || x.isPoints) &&
                (!x.frustumCulled || Yt.intersectsObject(x))
              ) {
                const rt = W.update(x),
                  ft = x.material;
                if (
                  (N &&
                    (x.boundingSphere !== void 0
                      ? (x.boundingSphere === null && x.computeBoundingSphere(),
                        Et.copy(x.boundingSphere.center))
                      : (rt.boundingSphere === null &&
                          rt.computeBoundingSphere(),
                        Et.copy(rt.boundingSphere.center)),
                    Et.applyMatrix4(x.matrixWorld).applyMatrix4(ct)),
                  Array.isArray(ft))
                ) {
                  const mt = rt.groups;
                  for (let St = 0, yt = mt.length; St < yt; St++) {
                    const vt = mt[St],
                      qt = ft[vt.materialIndex];
                    qt && qt.visible && M.push(x, rt, qt, I, Et.z, vt);
                  }
                } else ft.visible && M.push(x, rt, ft, I, Et.z, null);
              }
            }
            const Q = x.children;
            for (let rt = 0, ft = Q.length; rt < ft; rt++) Nr(Q[rt], C, I, N);
          }
          function Sa(x, C, I, N) {
            const L = x.opaque,
              Q = x.transmissive,
              rt = x.transparent;
            u.setupLightsView(I),
              k === !0 && J.setGlobalState(E.clippingPlanes, I),
              N && Tt.viewport(_.copy(N)),
              L.length > 0 && ki(L, C, I),
              Q.length > 0 && ki(Q, C, I),
              rt.length > 0 && ki(rt, C, I),
              Tt.buffers.depth.setTest(!0),
              Tt.buffers.depth.setMask(!0),
              Tt.buffers.color.setMask(!0),
              Tt.setPolygonOffset(!1);
          }
          function Ea(x, C, I, N) {
            if ((I.isScene === !0 ? I.overrideMaterial : null) !== null) return;
            u.state.transmissionRenderTarget[N.id] === void 0 &&
              (u.state.transmissionRenderTarget[N.id] = new Gn(1, 1, {
                generateMipmaps: !0,
                type:
                  Ut.has("EXT_color_buffer_half_float") ||
                  Ut.has("EXT_color_buffer_float")
                    ? Gi
                    : ln,
                minFilter: zn,
                samples: 4,
                stencilBuffer: s,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: Xt.workingColorSpace,
              }));
            const Q = u.state.transmissionRenderTarget[N.id],
              rt = N.viewport || _;
            Q.setSize(rt.z, rt.w);
            const ft = E.getRenderTarget();
            E.setRenderTarget(Q),
              E.getClearColor(z),
              (Y = E.getClearAlpha()),
              Y < 1 && E.setClearColor(16777215, 0.5),
              E.clear(),
              Kt && At.render(I);
            const mt = E.toneMapping;
            E.toneMapping = yn;
            const St = N.viewport;
            if (
              (N.viewport !== void 0 && (N.viewport = void 0),
              u.setupLightsView(N),
              k === !0 && J.setGlobalState(E.clippingPlanes, N),
              ki(x, I, N),
              y.updateMultisampleRenderTarget(Q),
              y.updateRenderTargetMipmap(Q),
              Ut.has("WEBGL_multisampled_render_to_texture") === !1)
            ) {
              let yt = !1;
              for (let vt = 0, qt = C.length; vt < qt; vt++) {
                const Qt = C[vt],
                  ne = Qt.object,
                  Ae = Qt.geometry,
                  kt = Qt.material,
                  xt = Qt.group;
                if (kt.side === sn && ne.layers.test(N.layers)) {
                  const he = kt.side;
                  (kt.side = ye),
                    (kt.needsUpdate = !0),
                    ya(ne, I, N, Ae, kt, xt),
                    (kt.side = he),
                    (kt.needsUpdate = !0),
                    (yt = !0);
                }
              }
              yt === !0 &&
                (y.updateMultisampleRenderTarget(Q),
                y.updateRenderTargetMipmap(Q));
            }
            E.setRenderTarget(ft),
              E.setClearColor(z, Y),
              St !== void 0 && (N.viewport = St),
              (E.toneMapping = mt);
          }
          function ki(x, C, I) {
            const N = C.isScene === !0 ? C.overrideMaterial : null;
            for (let L = 0, Q = x.length; L < Q; L++) {
              const rt = x[L],
                ft = rt.object,
                mt = rt.geometry,
                St = N === null ? rt.material : N,
                yt = rt.group;
              ft.layers.test(I.layers) && ya(ft, C, I, mt, St, yt);
            }
          }
          function ya(x, C, I, N, L, Q) {
            x.onBeforeRender(E, C, I, N, L, Q),
              x.modelViewMatrix.multiplyMatrices(
                I.matrixWorldInverse,
                x.matrixWorld
              ),
              x.normalMatrix.getNormalMatrix(x.modelViewMatrix),
              L.onBeforeRender(E, C, I, N, x, Q),
              L.transparent === !0 && L.side === sn && L.forceSinglePass === !1
                ? ((L.side = ye),
                  (L.needsUpdate = !0),
                  E.renderBufferDirect(I, C, N, L, x, Q),
                  (L.side = Tn),
                  (L.needsUpdate = !0),
                  E.renderBufferDirect(I, C, N, L, x, Q),
                  (L.side = sn))
                : E.renderBufferDirect(I, C, N, L, x, Q),
              x.onAfterRender(E, C, I, N, L, Q);
          }
          function Wi(x, C, I) {
            C.isScene !== !0 && (C = Nt);
            const N = wt.get(x),
              L = u.state.lights,
              Q = u.state.shadowsArray,
              rt = L.state.version,
              ft = gt.getParameters(x, L.state, Q, C, I),
              mt = gt.getProgramCacheKey(ft);
            let St = N.programs;
            (N.environment = x.isMeshStandardMaterial ? C.environment : null),
              (N.fog = C.fog),
              (N.envMap = (x.isMeshStandardMaterial ? U : g).get(
                x.envMap || N.environment
              )),
              (N.envMapRotation =
                N.environment !== null && x.envMap === null
                  ? C.environmentRotation
                  : x.envMapRotation),
              St === void 0 &&
                (x.addEventListener("dispose", Ot),
                (St = new Map()),
                (N.programs = St));
            let yt = St.get(mt);
            if (yt !== void 0) {
              if (N.currentProgram === yt && N.lightsStateVersion === rt)
                return Aa(x, ft), yt;
            } else
              (ft.uniforms = gt.getUniforms(x)),
                x.onBeforeCompile(ft, E),
                (yt = gt.acquireProgram(ft, mt)),
                St.set(mt, yt),
                (N.uniforms = ft.uniforms);
            const vt = N.uniforms;
            return (
              ((!x.isShaderMaterial && !x.isRawShaderMaterial) ||
                x.clipping === !0) &&
                (vt.clippingPlanes = J.uniform),
              Aa(x, ft),
              (N.needsLights = bl(x)),
              (N.lightsStateVersion = rt),
              N.needsLights &&
                ((vt.ambientLightColor.value = L.state.ambient),
                (vt.lightProbe.value = L.state.probe),
                (vt.directionalLights.value = L.state.directional),
                (vt.directionalLightShadows.value = L.state.directionalShadow),
                (vt.spotLights.value = L.state.spot),
                (vt.spotLightShadows.value = L.state.spotShadow),
                (vt.rectAreaLights.value = L.state.rectArea),
                (vt.ltc_1.value = L.state.rectAreaLTC1),
                (vt.ltc_2.value = L.state.rectAreaLTC2),
                (vt.pointLights.value = L.state.point),
                (vt.pointLightShadows.value = L.state.pointShadow),
                (vt.hemisphereLights.value = L.state.hemi),
                (vt.directionalShadowMap.value = L.state.directionalShadowMap),
                (vt.directionalShadowMatrix.value =
                  L.state.directionalShadowMatrix),
                (vt.spotShadowMap.value = L.state.spotShadowMap),
                (vt.spotLightMatrix.value = L.state.spotLightMatrix),
                (vt.spotLightMap.value = L.state.spotLightMap),
                (vt.pointShadowMap.value = L.state.pointShadowMap),
                (vt.pointShadowMatrix.value = L.state.pointShadowMatrix)),
              (N.currentProgram = yt),
              (N.uniformsList = null),
              yt
            );
          }
          function Ta(x) {
            if (x.uniformsList === null) {
              const C = x.currentProgram.getUniforms();
              x.uniformsList = Er.seqWithValue(C.seq, x.uniforms);
            }
            return x.uniformsList;
          }
          function Aa(x, C) {
            const I = wt.get(x);
            (I.outputColorSpace = C.outputColorSpace),
              (I.batching = C.batching),
              (I.batchingColor = C.batchingColor),
              (I.instancing = C.instancing),
              (I.instancingColor = C.instancingColor),
              (I.instancingMorph = C.instancingMorph),
              (I.skinning = C.skinning),
              (I.morphTargets = C.morphTargets),
              (I.morphNormals = C.morphNormals),
              (I.morphColors = C.morphColors),
              (I.morphTargetsCount = C.morphTargetsCount),
              (I.numClippingPlanes = C.numClippingPlanes),
              (I.numIntersection = C.numClipIntersection),
              (I.vertexAlphas = C.vertexAlphas),
              (I.vertexTangents = C.vertexTangents),
              (I.toneMapping = C.toneMapping);
          }
          function Tl(x, C, I, N, L) {
            C.isScene !== !0 && (C = Nt), y.resetTextureUnits();
            const Q = C.fog,
              rt = N.isMeshStandardMaterial ? C.environment : null,
              ft =
                b === null
                  ? E.outputColorSpace
                  : b.isXRRenderTarget === !0
                  ? b.texture.colorSpace
                  : bn,
              mt = (N.isMeshStandardMaterial ? U : g).get(N.envMap || rt),
              St =
                N.vertexColors === !0 &&
                !!I.attributes.color &&
                I.attributes.color.itemSize === 4,
              yt =
                !!I.attributes.tangent && (!!N.normalMap || N.anisotropy > 0),
              vt = !!I.morphAttributes.position,
              qt = !!I.morphAttributes.normal,
              Qt = !!I.morphAttributes.color;
            let ne = yn;
            N.toneMapped &&
              (b === null || b.isXRRenderTarget === !0) &&
              (ne = E.toneMapping);
            const Ae =
                I.morphAttributes.position ||
                I.morphAttributes.normal ||
                I.morphAttributes.color,
              kt = Ae !== void 0 ? Ae.length : 0,
              xt = wt.get(N),
              he = u.state.lights;
            if (k === !0 && ($ === !0 || x !== tt)) {
              const De = x === tt && N.id === F;
              J.setState(N, x, De);
            }
            let Wt = !1;
            N.version === xt.__version
              ? ((xt.needsLights &&
                  xt.lightsStateVersion !== he.state.version) ||
                  xt.outputColorSpace !== ft ||
                  (L.isBatchedMesh && xt.batching === !1) ||
                  (!L.isBatchedMesh && xt.batching === !0) ||
                  (L.isBatchedMesh &&
                    xt.batchingColor === !0 &&
                    L.colorTexture === null) ||
                  (L.isBatchedMesh &&
                    xt.batchingColor === !1 &&
                    L.colorTexture !== null) ||
                  (L.isInstancedMesh && xt.instancing === !1) ||
                  (!L.isInstancedMesh && xt.instancing === !0) ||
                  (L.isSkinnedMesh && xt.skinning === !1) ||
                  (!L.isSkinnedMesh && xt.skinning === !0) ||
                  (L.isInstancedMesh &&
                    xt.instancingColor === !0 &&
                    L.instanceColor === null) ||
                  (L.isInstancedMesh &&
                    xt.instancingColor === !1 &&
                    L.instanceColor !== null) ||
                  (L.isInstancedMesh &&
                    xt.instancingMorph === !0 &&
                    L.morphTexture === null) ||
                  (L.isInstancedMesh &&
                    xt.instancingMorph === !1 &&
                    L.morphTexture !== null) ||
                  xt.envMap !== mt ||
                  (N.fog === !0 && xt.fog !== Q) ||
                  (xt.numClippingPlanes !== void 0 &&
                    (xt.numClippingPlanes !== J.numPlanes ||
                      xt.numIntersection !== J.numIntersection)) ||
                  xt.vertexAlphas !== St ||
                  xt.vertexTangents !== yt ||
                  xt.morphTargets !== vt ||
                  xt.morphNormals !== qt ||
                  xt.morphColors !== Qt ||
                  xt.toneMapping !== ne ||
                  xt.morphTargetsCount !== kt) &&
                (Wt = !0)
              : ((Wt = !0), (xt.__version = N.version));
            let Oe = xt.currentProgram;
            Wt === !0 && (Oe = Wi(N, C, L));
            let Wn = !1,
              be = !1,
              Fr = !1;
            const ie = Oe.getUniforms(),
              hn = xt.uniforms;
            if (
              (Tt.useProgram(Oe.program) && ((Wn = !0), (be = !0), (Fr = !0)),
              N.id !== F && ((F = N.id), (be = !0)),
              Wn || tt !== x)
            ) {
              zt.reverseDepthBuffer
                ? (pt.copy(x.projectionMatrix),
                  Nc(pt),
                  Fc(pt),
                  ie.setValue(w, "projectionMatrix", pt))
                : ie.setValue(w, "projectionMatrix", x.projectionMatrix),
                ie.setValue(w, "viewMatrix", x.matrixWorldInverse);
              const De = ie.map.cameraPosition;
              De !== void 0 &&
                De.setValue(w, Rt.setFromMatrixPosition(x.matrixWorld)),
                zt.logarithmicDepthBuffer &&
                  ie.setValue(
                    w,
                    "logDepthBufFC",
                    2 / (Math.log(x.far + 1) / Math.LN2)
                  ),
                (N.isMeshPhongMaterial ||
                  N.isMeshToonMaterial ||
                  N.isMeshLambertMaterial ||
                  N.isMeshBasicMaterial ||
                  N.isMeshStandardMaterial ||
                  N.isShaderMaterial) &&
                  ie.setValue(
                    w,
                    "isOrthographic",
                    x.isOrthographicCamera === !0
                  ),
                tt !== x && ((tt = x), (be = !0), (Fr = !0));
            }
            if (L.isSkinnedMesh) {
              ie.setOptional(w, L, "bindMatrix"),
                ie.setOptional(w, L, "bindMatrixInverse");
              const De = L.skeleton;
              De &&
                (De.boneTexture === null && De.computeBoneTexture(),
                ie.setValue(w, "boneTexture", De.boneTexture, y));
            }
            L.isBatchedMesh &&
              (ie.setOptional(w, L, "batchingTexture"),
              ie.setValue(w, "batchingTexture", L._matricesTexture, y),
              ie.setOptional(w, L, "batchingIdTexture"),
              ie.setValue(w, "batchingIdTexture", L._indirectTexture, y),
              ie.setOptional(w, L, "batchingColorTexture"),
              L._colorsTexture !== null &&
                ie.setValue(w, "batchingColorTexture", L._colorsTexture, y));
            const Or = I.morphAttributes;
            if (
              ((Or.position !== void 0 ||
                Or.normal !== void 0 ||
                Or.color !== void 0) &&
                bt.update(L, I, Oe),
              (be || xt.receiveShadow !== L.receiveShadow) &&
                ((xt.receiveShadow = L.receiveShadow),
                ie.setValue(w, "receiveShadow", L.receiveShadow)),
              N.isMeshGouraudMaterial &&
                N.envMap !== null &&
                ((hn.envMap.value = mt),
                (hn.flipEnvMap.value =
                  mt.isCubeTexture && mt.isRenderTargetTexture === !1
                    ? -1
                    : 1)),
              N.isMeshStandardMaterial &&
                N.envMap === null &&
                C.environment !== null &&
                (hn.envMapIntensity.value = C.environmentIntensity),
              be &&
                (ie.setValue(w, "toneMappingExposure", E.toneMappingExposure),
                xt.needsLights && Al(hn, Fr),
                Q && N.fog === !0 && nt.refreshFogUniforms(hn, Q),
                nt.refreshMaterialUniforms(
                  hn,
                  N,
                  K,
                  G,
                  u.state.transmissionRenderTarget[x.id]
                ),
                Er.upload(w, Ta(xt), hn, y)),
              N.isShaderMaterial &&
                N.uniformsNeedUpdate === !0 &&
                (Er.upload(w, Ta(xt), hn, y), (N.uniformsNeedUpdate = !1)),
              N.isSpriteMaterial && ie.setValue(w, "center", L.center),
              ie.setValue(w, "modelViewMatrix", L.modelViewMatrix),
              ie.setValue(w, "normalMatrix", L.normalMatrix),
              ie.setValue(w, "modelMatrix", L.matrixWorld),
              N.isShaderMaterial || N.isRawShaderMaterial)
            ) {
              const De = N.uniformsGroups;
              for (let Br = 0, wl = De.length; Br < wl; Br++) {
                const ba = De[Br];
                R.update(ba, Oe), R.bind(ba, Oe);
              }
            }
            return Oe;
          }
          function Al(x, C) {
            (x.ambientLightColor.needsUpdate = C),
              (x.lightProbe.needsUpdate = C),
              (x.directionalLights.needsUpdate = C),
              (x.directionalLightShadows.needsUpdate = C),
              (x.pointLights.needsUpdate = C),
              (x.pointLightShadows.needsUpdate = C),
              (x.spotLights.needsUpdate = C),
              (x.spotLightShadows.needsUpdate = C),
              (x.rectAreaLights.needsUpdate = C),
              (x.hemisphereLights.needsUpdate = C);
          }
          function bl(x) {
            return (
              x.isMeshLambertMaterial ||
              x.isMeshToonMaterial ||
              x.isMeshPhongMaterial ||
              x.isMeshStandardMaterial ||
              x.isShadowMaterial ||
              (x.isShaderMaterial && x.lights === !0)
            );
          }
          (this.getActiveCubeFace = function () {
            return O;
          }),
            (this.getActiveMipmapLevel = function () {
              return P;
            }),
            (this.getRenderTarget = function () {
              return b;
            }),
            (this.setRenderTargetTextures = function (x, C, I) {
              (wt.get(x.texture).__webglTexture = C),
                (wt.get(x.depthTexture).__webglTexture = I);
              const N = wt.get(x);
              (N.__hasExternalTextures = !0),
                (N.__autoAllocateDepthBuffer = I === void 0),
                N.__autoAllocateDepthBuffer ||
                  (Ut.has("WEBGL_multisampled_render_to_texture") === !0 &&
                    (console.warn(
                      "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                    ),
                    (N.__useRenderToTexture = !1)));
            }),
            (this.setRenderTargetFramebuffer = function (x, C) {
              const I = wt.get(x);
              (I.__webglFramebuffer = C),
                (I.__useDefaultFramebuffer = C === void 0);
            }),
            (this.setRenderTarget = function (x, C = 0, I = 0) {
              (b = x), (O = C), (P = I);
              let N = !0,
                L = null,
                Q = !1,
                rt = !1;
              if (x) {
                const mt = wt.get(x);
                if (mt.__useDefaultFramebuffer !== void 0)
                  Tt.bindFramebuffer(w.FRAMEBUFFER, null), (N = !1);
                else if (mt.__webglFramebuffer === void 0)
                  y.setupRenderTarget(x);
                else if (mt.__hasExternalTextures)
                  y.rebindTextures(
                    x,
                    wt.get(x.texture).__webglTexture,
                    wt.get(x.depthTexture).__webglTexture
                  );
                else if (x.depthBuffer) {
                  const vt = x.depthTexture;
                  if (mt.__boundDepthTexture !== vt) {
                    if (
                      vt !== null &&
                      wt.has(vt) &&
                      (x.width !== vt.image.width ||
                        x.height !== vt.image.height)
                    )
                      throw new Error(
                        "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."
                      );
                    y.setupDepthRenderbuffer(x);
                  }
                }
                const St = x.texture;
                (St.isData3DTexture ||
                  St.isDataArrayTexture ||
                  St.isCompressedArrayTexture) &&
                  (rt = !0);
                const yt = wt.get(x).__webglFramebuffer;
                x.isWebGLCubeRenderTarget
                  ? (Array.isArray(yt[C]) ? (L = yt[C][I]) : (L = yt[C]),
                    (Q = !0))
                  : x.samples > 0 && y.useMultisampledRTT(x) === !1
                  ? (L = wt.get(x).__webglMultisampledFramebuffer)
                  : Array.isArray(yt)
                  ? (L = yt[I])
                  : (L = yt),
                  _.copy(x.viewport),
                  S.copy(x.scissor),
                  (V = x.scissorTest);
              } else
                _.copy(lt).multiplyScalar(K).floor(),
                  S.copy(_t).multiplyScalar(K).floor(),
                  (V = Gt);
              if (
                (Tt.bindFramebuffer(w.FRAMEBUFFER, L) &&
                  N &&
                  Tt.drawBuffers(x, L),
                Tt.viewport(_),
                Tt.scissor(S),
                Tt.setScissorTest(V),
                Q)
              ) {
                const mt = wt.get(x.texture);
                w.framebufferTexture2D(
                  w.FRAMEBUFFER,
                  w.COLOR_ATTACHMENT0,
                  w.TEXTURE_CUBE_MAP_POSITIVE_X + C,
                  mt.__webglTexture,
                  I
                );
              } else if (rt) {
                const mt = wt.get(x.texture),
                  St = C || 0;
                w.framebufferTextureLayer(
                  w.FRAMEBUFFER,
                  w.COLOR_ATTACHMENT0,
                  mt.__webglTexture,
                  I || 0,
                  St
                );
              }
              F = -1;
            }),
            (this.readRenderTargetPixels = function (x, C, I, N, L, Q, rt) {
              if (!(x && x.isWebGLRenderTarget)) {
                console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                );
                return;
              }
              let ft = wt.get(x).__webglFramebuffer;
              if (
                (x.isWebGLCubeRenderTarget && rt !== void 0 && (ft = ft[rt]),
                ft)
              ) {
                Tt.bindFramebuffer(w.FRAMEBUFFER, ft);
                try {
                  const mt = x.texture,
                    St = mt.format,
                    yt = mt.type;
                  if (!zt.textureFormatReadable(St)) {
                    console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                    );
                    return;
                  }
                  if (!zt.textureTypeReadable(yt)) {
                    console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                    );
                    return;
                  }
                  C >= 0 &&
                    C <= x.width - N &&
                    I >= 0 &&
                    I <= x.height - L &&
                    w.readPixels(C, I, N, L, Ct.convert(St), Ct.convert(yt), Q);
                } finally {
                  const mt = b !== null ? wt.get(b).__webglFramebuffer : null;
                  Tt.bindFramebuffer(w.FRAMEBUFFER, mt);
                }
              }
            }),
            (this.readRenderTargetPixelsAsync = async function (
              x,
              C,
              I,
              N,
              L,
              Q,
              rt
            ) {
              if (!(x && x.isWebGLRenderTarget))
                throw new Error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                );
              let ft = wt.get(x).__webglFramebuffer;
              if (
                (x.isWebGLCubeRenderTarget && rt !== void 0 && (ft = ft[rt]),
                ft)
              ) {
                const mt = x.texture,
                  St = mt.format,
                  yt = mt.type;
                if (!zt.textureFormatReadable(St))
                  throw new Error(
                    "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
                  );
                if (!zt.textureTypeReadable(yt))
                  throw new Error(
                    "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                if (C >= 0 && C <= x.width - N && I >= 0 && I <= x.height - L) {
                  Tt.bindFramebuffer(w.FRAMEBUFFER, ft);
                  const vt = w.createBuffer();
                  w.bindBuffer(w.PIXEL_PACK_BUFFER, vt),
                    w.bufferData(
                      w.PIXEL_PACK_BUFFER,
                      Q.byteLength,
                      w.STREAM_READ
                    ),
                    w.readPixels(C, I, N, L, Ct.convert(St), Ct.convert(yt), 0);
                  const qt = b !== null ? wt.get(b).__webglFramebuffer : null;
                  Tt.bindFramebuffer(w.FRAMEBUFFER, qt);
                  const Qt = w.fenceSync(w.SYNC_GPU_COMMANDS_COMPLETE, 0);
                  return (
                    w.flush(),
                    await Ic(w, Qt, 4),
                    w.bindBuffer(w.PIXEL_PACK_BUFFER, vt),
                    w.getBufferSubData(w.PIXEL_PACK_BUFFER, 0, Q),
                    w.deleteBuffer(vt),
                    w.deleteSync(Qt),
                    Q
                  );
                } else
                  throw new Error(
                    "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range."
                  );
              }
            }),
            (this.copyFramebufferToTexture = function (x, C = null, I = 0) {
              x.isTexture !== !0 &&
                (Sr(
                  "WebGLRenderer: copyFramebufferToTexture function signature has changed."
                ),
                (C = arguments[0] || null),
                (x = arguments[1]));
              const N = Math.pow(2, -I),
                L = Math.floor(x.image.width * N),
                Q = Math.floor(x.image.height * N),
                rt = C !== null ? C.x : 0,
                ft = C !== null ? C.y : 0;
              y.setTexture2D(x, 0),
                w.copyTexSubImage2D(w.TEXTURE_2D, I, 0, 0, rt, ft, L, Q),
                Tt.unbindTexture();
            }),
            (this.copyTextureToTexture = function (
              x,
              C,
              I = null,
              N = null,
              L = 0
            ) {
              x.isTexture !== !0 &&
                (Sr(
                  "WebGLRenderer: copyTextureToTexture function signature has changed."
                ),
                (N = arguments[0] || null),
                (x = arguments[1]),
                (C = arguments[2]),
                (L = arguments[3] || 0),
                (I = null));
              let Q, rt, ft, mt, St, yt;
              I !== null
                ? ((Q = I.max.x - I.min.x),
                  (rt = I.max.y - I.min.y),
                  (ft = I.min.x),
                  (mt = I.min.y))
                : ((Q = x.image.width),
                  (rt = x.image.height),
                  (ft = 0),
                  (mt = 0)),
                N !== null ? ((St = N.x), (yt = N.y)) : ((St = 0), (yt = 0));
              const vt = Ct.convert(C.format),
                qt = Ct.convert(C.type);
              y.setTexture2D(C, 0),
                w.pixelStorei(w.UNPACK_FLIP_Y_WEBGL, C.flipY),
                w.pixelStorei(
                  w.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                  C.premultiplyAlpha
                ),
                w.pixelStorei(w.UNPACK_ALIGNMENT, C.unpackAlignment);
              const Qt = w.getParameter(w.UNPACK_ROW_LENGTH),
                ne = w.getParameter(w.UNPACK_IMAGE_HEIGHT),
                Ae = w.getParameter(w.UNPACK_SKIP_PIXELS),
                kt = w.getParameter(w.UNPACK_SKIP_ROWS),
                xt = w.getParameter(w.UNPACK_SKIP_IMAGES),
                he = x.isCompressedTexture ? x.mipmaps[L] : x.image;
              w.pixelStorei(w.UNPACK_ROW_LENGTH, he.width),
                w.pixelStorei(w.UNPACK_IMAGE_HEIGHT, he.height),
                w.pixelStorei(w.UNPACK_SKIP_PIXELS, ft),
                w.pixelStorei(w.UNPACK_SKIP_ROWS, mt),
                x.isDataTexture
                  ? w.texSubImage2D(
                      w.TEXTURE_2D,
                      L,
                      St,
                      yt,
                      Q,
                      rt,
                      vt,
                      qt,
                      he.data
                    )
                  : x.isCompressedTexture
                  ? w.compressedTexSubImage2D(
                      w.TEXTURE_2D,
                      L,
                      St,
                      yt,
                      he.width,
                      he.height,
                      vt,
                      he.data
                    )
                  : w.texSubImage2D(w.TEXTURE_2D, L, St, yt, Q, rt, vt, qt, he),
                w.pixelStorei(w.UNPACK_ROW_LENGTH, Qt),
                w.pixelStorei(w.UNPACK_IMAGE_HEIGHT, ne),
                w.pixelStorei(w.UNPACK_SKIP_PIXELS, Ae),
                w.pixelStorei(w.UNPACK_SKIP_ROWS, kt),
                w.pixelStorei(w.UNPACK_SKIP_IMAGES, xt),
                L === 0 && C.generateMipmaps && w.generateMipmap(w.TEXTURE_2D),
                Tt.unbindTexture();
            }),
            (this.copyTextureToTexture3D = function (
              x,
              C,
              I = null,
              N = null,
              L = 0
            ) {
              x.isTexture !== !0 &&
                (Sr(
                  "WebGLRenderer: copyTextureToTexture3D function signature has changed."
                ),
                (I = arguments[0] || null),
                (N = arguments[1] || null),
                (x = arguments[2]),
                (C = arguments[3]),
                (L = arguments[4] || 0));
              let Q, rt, ft, mt, St, yt, vt, qt, Qt;
              const ne = x.isCompressedTexture ? x.mipmaps[L] : x.image;
              I !== null
                ? ((Q = I.max.x - I.min.x),
                  (rt = I.max.y - I.min.y),
                  (ft = I.max.z - I.min.z),
                  (mt = I.min.x),
                  (St = I.min.y),
                  (yt = I.min.z))
                : ((Q = ne.width),
                  (rt = ne.height),
                  (ft = ne.depth),
                  (mt = 0),
                  (St = 0),
                  (yt = 0)),
                N !== null
                  ? ((vt = N.x), (qt = N.y), (Qt = N.z))
                  : ((vt = 0), (qt = 0), (Qt = 0));
              const Ae = Ct.convert(C.format),
                kt = Ct.convert(C.type);
              let xt;
              if (C.isData3DTexture) y.setTexture3D(C, 0), (xt = w.TEXTURE_3D);
              else if (C.isDataArrayTexture || C.isCompressedArrayTexture)
                y.setTexture2DArray(C, 0), (xt = w.TEXTURE_2D_ARRAY);
              else {
                console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                );
                return;
              }
              w.pixelStorei(w.UNPACK_FLIP_Y_WEBGL, C.flipY),
                w.pixelStorei(
                  w.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                  C.premultiplyAlpha
                ),
                w.pixelStorei(w.UNPACK_ALIGNMENT, C.unpackAlignment);
              const he = w.getParameter(w.UNPACK_ROW_LENGTH),
                Wt = w.getParameter(w.UNPACK_IMAGE_HEIGHT),
                Oe = w.getParameter(w.UNPACK_SKIP_PIXELS),
                Wn = w.getParameter(w.UNPACK_SKIP_ROWS),
                be = w.getParameter(w.UNPACK_SKIP_IMAGES);
              w.pixelStorei(w.UNPACK_ROW_LENGTH, ne.width),
                w.pixelStorei(w.UNPACK_IMAGE_HEIGHT, ne.height),
                w.pixelStorei(w.UNPACK_SKIP_PIXELS, mt),
                w.pixelStorei(w.UNPACK_SKIP_ROWS, St),
                w.pixelStorei(w.UNPACK_SKIP_IMAGES, yt),
                x.isDataTexture || x.isData3DTexture
                  ? w.texSubImage3D(
                      xt,
                      L,
                      vt,
                      qt,
                      Qt,
                      Q,
                      rt,
                      ft,
                      Ae,
                      kt,
                      ne.data
                    )
                  : C.isCompressedArrayTexture
                  ? w.compressedTexSubImage3D(
                      xt,
                      L,
                      vt,
                      qt,
                      Qt,
                      Q,
                      rt,
                      ft,
                      Ae,
                      ne.data
                    )
                  : w.texSubImage3D(xt, L, vt, qt, Qt, Q, rt, ft, Ae, kt, ne),
                w.pixelStorei(w.UNPACK_ROW_LENGTH, he),
                w.pixelStorei(w.UNPACK_IMAGE_HEIGHT, Wt),
                w.pixelStorei(w.UNPACK_SKIP_PIXELS, Oe),
                w.pixelStorei(w.UNPACK_SKIP_ROWS, Wn),
                w.pixelStorei(w.UNPACK_SKIP_IMAGES, be),
                L === 0 && C.generateMipmaps && w.generateMipmap(xt),
                Tt.unbindTexture();
            }),
            (this.initRenderTarget = function (x) {
              wt.get(x).__webglFramebuffer === void 0 && y.setupRenderTarget(x);
            }),
            (this.initTexture = function (x) {
              x.isCubeTexture
                ? y.setTextureCube(x, 0)
                : x.isData3DTexture
                ? y.setTexture3D(x, 0)
                : x.isDataArrayTexture || x.isCompressedArrayTexture
                ? y.setTexture2DArray(x, 0)
                : y.setTexture2D(x, 0),
                Tt.unbindTexture();
            }),
            (this.resetState = function () {
              (O = 0), (P = 0), (b = null), Tt.reset(), $t.reset();
            }),
            typeof __THREE_DEVTOOLS__ < "u" &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        get coordinateSystem() {
          return on;
        }
        get outputColorSpace() {
          return this._outputColorSpace;
        }
        set outputColorSpace(t) {
          this._outputColorSpace = t;
          const e = this.getContext();
          (e.drawingBufferColorSpace = t === da ? "display-p3" : "srgb"),
            (e.unpackColorSpace =
              Xt.workingColorSpace === Lr ? "display-p3" : "srgb");
        }
      }
      class jp extends ue {
        constructor() {
          super(),
            (this.isScene = !0),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.backgroundBlurriness = 0),
            (this.backgroundIntensity = 1),
            (this.backgroundRotation = new je()),
            (this.environmentIntensity = 1),
            (this.environmentRotation = new je()),
            (this.overrideMaterial = null),
            typeof __THREE_DEVTOOLS__ < "u" &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            t.background !== null && (this.background = t.background.clone()),
            t.environment !== null &&
              (this.environment = t.environment.clone()),
            t.fog !== null && (this.fog = t.fog.clone()),
            (this.backgroundBlurriness = t.backgroundBlurriness),
            (this.backgroundIntensity = t.backgroundIntensity),
            this.backgroundRotation.copy(t.backgroundRotation),
            (this.environmentIntensity = t.environmentIntensity),
            this.environmentRotation.copy(t.environmentRotation),
            t.overrideMaterial !== null &&
              (this.overrideMaterial = t.overrideMaterial.clone()),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            this.fog !== null && (e.object.fog = this.fog.toJSON()),
            this.backgroundBlurriness > 0 &&
              (e.object.backgroundBlurriness = this.backgroundBlurriness),
            this.backgroundIntensity !== 1 &&
              (e.object.backgroundIntensity = this.backgroundIntensity),
            (e.object.backgroundRotation = this.backgroundRotation.toArray()),
            this.environmentIntensity !== 1 &&
              (e.object.environmentIntensity = this.environmentIntensity),
            (e.object.environmentRotation = this.environmentRotation.toArray()),
            e
          );
        }
      }
      class vl extends Si {
        constructor(t) {
          super(),
            (this.isLineBasicMaterial = !0),
            (this.type = "LineBasicMaterial"),
            (this.color = new Bt(16777215)),
            (this.map = null),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.linewidth = t.linewidth),
            (this.linecap = t.linecap),
            (this.linejoin = t.linejoin),
            (this.fog = t.fog),
            this
          );
        }
      }
      const wr = new D(),
        Rr = new D(),
        bo = new ee(),
        Ci = new pa(),
        fr = new Dr(),
        ps = new D(),
        wo = new D();
      class Zp extends ue {
        constructor(t = new cn(), e = new vl()) {
          super(),
            (this.isLine = !0),
            (this.type = "Line"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.material = Array.isArray(t.material)
              ? t.material.slice()
              : t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.index === null) {
            const e = t.attributes.position,
              n = [0];
            for (let r = 1, s = e.count; r < s; r++)
              wr.fromBufferAttribute(e, r - 1),
                Rr.fromBufferAttribute(e, r),
                (n[r] = n[r - 1]),
                (n[r] += wr.distanceTo(Rr));
            t.setAttribute("lineDistance", new Ye(n, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
          return this;
        }
        raycast(t, e) {
          const n = this.geometry,
            r = this.matrixWorld,
            s = t.params.Line.threshold,
            a = n.drawRange;
          if (
            (n.boundingSphere === null && n.computeBoundingSphere(),
            fr.copy(n.boundingSphere),
            fr.applyMatrix4(r),
            (fr.radius += s),
            t.ray.intersectsSphere(fr) === !1)
          )
            return;
          bo.copy(r).invert(), Ci.copy(t.ray).applyMatrix4(bo);
          const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = o * o,
            c = this.isLineSegments ? 2 : 1,
            h = n.index,
            p = n.attributes.position;
          if (h !== null) {
            const m = Math.max(0, a.start),
              v = Math.min(h.count, a.start + a.count);
            for (let M = m, u = v - 1; M < u; M += c) {
              const d = h.getX(M),
                T = h.getX(M + 1),
                E = pr(this, t, Ci, l, d, T);
              E && e.push(E);
            }
            if (this.isLineLoop) {
              const M = h.getX(v - 1),
                u = h.getX(m),
                d = pr(this, t, Ci, l, M, u);
              d && e.push(d);
            }
          } else {
            const m = Math.max(0, a.start),
              v = Math.min(p.count, a.start + a.count);
            for (let M = m, u = v - 1; M < u; M += c) {
              const d = pr(this, t, Ci, l, M, M + 1);
              d && e.push(d);
            }
            if (this.isLineLoop) {
              const M = pr(this, t, Ci, l, v - 1, m);
              M && e.push(M);
            }
          }
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes,
            n = Object.keys(e);
          if (n.length > 0) {
            const r = e[n[0]];
            if (r !== void 0) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let s = 0, a = r.length; s < a; s++) {
                const o = r[s].name || String(s);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[o] = s);
              }
            }
          }
        }
      }
      function pr(i, t, e, n, r, s) {
        const a = i.geometry.attributes.position;
        if (
          (wr.fromBufferAttribute(a, r),
          Rr.fromBufferAttribute(a, s),
          e.distanceSqToSegment(wr, Rr, ps, wo) > n)
        )
          return;
        ps.applyMatrix4(i.matrixWorld);
        const l = t.ray.origin.distanceTo(ps);
        if (!(l < t.near || l > t.far))
          return {
            distance: l,
            point: wo.clone().applyMatrix4(i.matrixWorld),
            index: r,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: i,
          };
      }
      const Ro = new D(),
        Co = new D();
      class $p extends Zp {
        constructor(t, e) {
          super(t, e), (this.isLineSegments = !0), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.index === null) {
            const e = t.attributes.position,
              n = [];
            for (let r = 0, s = e.count; r < s; r += 2)
              Ro.fromBufferAttribute(e, r),
                Co.fromBufferAttribute(e, r + 1),
                (n[r] = r === 0 ? 0 : n[r - 1]),
                (n[r + 1] = n[r] + Ro.distanceTo(Co));
            t.setAttribute("lineDistance", new Ye(n, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
          return this;
        }
      }
      class Le extends Si {
        constructor(t) {
          super(),
            (this.isMeshStandardMaterial = !0),
            (this.defines = { STANDARD: "" }),
            (this.type = "MeshStandardMaterial"),
            (this.color = new Bt(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Bt(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Qo),
            (this.normalScale = new Pt(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new je()),
            (this.envMapIntensity = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { STANDARD: "" }),
            this.color.copy(t.color),
            (this.roughness = t.roughness),
            (this.metalness = t.metalness),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.roughnessMap = t.roughnessMap),
            (this.metalnessMap = t.metalnessMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            this.envMapRotation.copy(t.envMapRotation),
            (this.envMapIntensity = t.envMapIntensity),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.flatShading = t.flatShading),
            (this.fog = t.fog),
            this
          );
        }
      }
      const Po = {
        enabled: !1,
        files: {},
        add: function (i, t) {
          this.enabled !== !1 && (this.files[i] = t);
        },
        get: function (i) {
          if (this.enabled !== !1) return this.files[i];
        },
        remove: function (i) {
          delete this.files[i];
        },
        clear: function () {
          this.files = {};
        },
      };
      class Jp {
        constructor(t, e, n) {
          const r = this;
          let s = !1,
            a = 0,
            o = 0,
            l;
          const c = [];
          (this.onStart = void 0),
            (this.onLoad = t),
            (this.onProgress = e),
            (this.onError = n),
            (this.itemStart = function (h) {
              o++,
                s === !1 && r.onStart !== void 0 && r.onStart(h, a, o),
                (s = !0);
            }),
            (this.itemEnd = function (h) {
              a++,
                r.onProgress !== void 0 && r.onProgress(h, a, o),
                a === o && ((s = !1), r.onLoad !== void 0 && r.onLoad());
            }),
            (this.itemError = function (h) {
              r.onError !== void 0 && r.onError(h);
            }),
            (this.resolveURL = function (h) {
              return l ? l(h) : h;
            }),
            (this.setURLModifier = function (h) {
              return (l = h), this;
            }),
            (this.addHandler = function (h, f) {
              return c.push(h, f), this;
            }),
            (this.removeHandler = function (h) {
              const f = c.indexOf(h);
              return f !== -1 && c.splice(f, 2), this;
            }),
            (this.getHandler = function (h) {
              for (let f = 0, p = c.length; f < p; f += 2) {
                const m = c[f],
                  v = c[f + 1];
                if ((m.global && (m.lastIndex = 0), m.test(h))) return v;
              }
              return null;
            });
        }
      }
      const Qp = new Jp();
      class ga {
        constructor(t) {
          (this.manager = t !== void 0 ? t : Qp),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(t, e) {
          const n = this;
          return new Promise(function (r, s) {
            n.load(t, r, e, s);
          });
        }
        parse() {}
        setCrossOrigin(t) {
          return (this.crossOrigin = t), this;
        }
        setWithCredentials(t) {
          return (this.withCredentials = t), this;
        }
        setPath(t) {
          return (this.path = t), this;
        }
        setResourcePath(t) {
          return (this.resourcePath = t), this;
        }
        setRequestHeader(t) {
          return (this.requestHeader = t), this;
        }
      }
      ga.DEFAULT_MATERIAL_NAME = "__DEFAULT";
      class tm extends ga {
        constructor(t) {
          super(t);
        }
        load(t, e, n, r) {
          this.path !== void 0 && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          const s = this,
            a = Po.get(t);
          if (a !== void 0)
            return (
              s.manager.itemStart(t),
              setTimeout(function () {
                e && e(a), s.manager.itemEnd(t);
              }, 0),
              a
            );
          const o = zi("img");
          function l() {
            h(), Po.add(t, this), e && e(this), s.manager.itemEnd(t);
          }
          function c(f) {
            h(), r && r(f), s.manager.itemError(t), s.manager.itemEnd(t);
          }
          function h() {
            o.removeEventListener("load", l, !1),
              o.removeEventListener("error", c, !1);
          }
          return (
            o.addEventListener("load", l, !1),
            o.addEventListener("error", c, !1),
            t.slice(0, 5) !== "data:" &&
              this.crossOrigin !== void 0 &&
              (o.crossOrigin = this.crossOrigin),
            s.manager.itemStart(t),
            (o.src = t),
            o
          );
        }
      }
      class yi extends ga {
        constructor(t) {
          super(t);
        }
        load(t, e, n, r) {
          const s = new xe(),
            a = new tm(this.manager);
          return (
            a.setCrossOrigin(this.crossOrigin),
            a.setPath(this.path),
            a.load(
              t,
              function (o) {
                (s.image = o), (s.needsUpdate = !0), e !== void 0 && e(s);
              },
              n,
              r
            ),
            s
          );
        }
      }
      class xl extends ue {
        constructor(t, e = 1) {
          super(),
            (this.isLight = !0),
            (this.type = "Light"),
            (this.color = new Bt(t)),
            (this.intensity = e);
        }
        dispose() {}
        copy(t, e) {
          return (
            super.copy(t, e),
            this.color.copy(t.color),
            (this.intensity = t.intensity),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.color = this.color.getHex()),
            (e.object.intensity = this.intensity),
            this.groundColor !== void 0 &&
              (e.object.groundColor = this.groundColor.getHex()),
            this.distance !== void 0 && (e.object.distance = this.distance),
            this.angle !== void 0 && (e.object.angle = this.angle),
            this.decay !== void 0 && (e.object.decay = this.decay),
            this.penumbra !== void 0 && (e.object.penumbra = this.penumbra),
            this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()),
            this.target !== void 0 && (e.object.target = this.target.uuid),
            e
          );
        }
      }
      const ms = new ee(),
        Lo = new D(),
        Do = new D();
      class em {
        constructor(t) {
          (this.camera = t),
            (this.intensity = 1),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new Pt(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new ee()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new ma()),
            (this._frameExtents = new Pt(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new Zt(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(t) {
          const e = this.camera,
            n = this.matrix;
          Lo.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(Lo),
            Do.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(Do),
            e.updateMatrixWorld(),
            ms.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(ms),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(ms);
        }
        getViewport(t) {
          return this._viewports[t];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(t) {
          return (
            (this.camera = t.camera.clone()),
            (this.intensity = t.intensity),
            (this.bias = t.bias),
            (this.radius = t.radius),
            this.mapSize.copy(t.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t = {};
          return (
            this.intensity !== 1 && (t.intensity = this.intensity),
            this.bias !== 0 && (t.bias = this.bias),
            this.normalBias !== 0 && (t.normalBias = this.normalBias),
            this.radius !== 1 && (t.radius = this.radius),
            (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
              (t.mapSize = this.mapSize.toArray()),
            (t.camera = this.camera.toJSON(!1).object),
            delete t.camera.matrix,
            t
          );
        }
      }
      const Uo = new ee(),
        Pi = new D(),
        _s = new D();
      class nm extends em {
        constructor() {
          super(new Pe(90, 1, 0.5, 500)),
            (this.isPointLightShadow = !0),
            (this._frameExtents = new Pt(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new Zt(2, 1, 1, 1),
              new Zt(0, 1, 1, 1),
              new Zt(3, 1, 1, 1),
              new Zt(1, 1, 1, 1),
              new Zt(3, 0, 1, 1),
              new Zt(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new D(1, 0, 0),
              new D(-1, 0, 0),
              new D(0, 0, 1),
              new D(0, 0, -1),
              new D(0, 1, 0),
              new D(0, -1, 0),
            ]),
            (this._cubeUps = [
              new D(0, 1, 0),
              new D(0, 1, 0),
              new D(0, 1, 0),
              new D(0, 1, 0),
              new D(0, 0, 1),
              new D(0, 0, -1),
            ]);
        }
        updateMatrices(t, e = 0) {
          const n = this.camera,
            r = this.matrix,
            s = t.distance || n.far;
          s !== n.far && ((n.far = s), n.updateProjectionMatrix()),
            Pi.setFromMatrixPosition(t.matrixWorld),
            n.position.copy(Pi),
            _s.copy(n.position),
            _s.add(this._cubeDirections[e]),
            n.up.copy(this._cubeUps[e]),
            n.lookAt(_s),
            n.updateMatrixWorld(),
            r.makeTranslation(-Pi.x, -Pi.y, -Pi.z),
            Uo.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Uo);
        }
      }
      class im extends xl {
        constructor(t, e, n = 0, r = 2) {
          super(t, e),
            (this.isPointLight = !0),
            (this.type = "PointLight"),
            (this.distance = n),
            (this.decay = r),
            (this.shadow = new nm());
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(t) {
          this.intensity = t / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.distance = t.distance),
            (this.decay = t.decay),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      }
      class rm extends xl {
        constructor(t, e) {
          super(t, e), (this.isAmbientLight = !0), (this.type = "AmbientLight");
        }
      }
      class Io {
        constructor(t = 1, e = 0, n = 0) {
          return (this.radius = t), (this.phi = e), (this.theta = n), this;
        }
        set(t, e, n) {
          return (this.radius = t), (this.phi = e), (this.theta = n), this;
        }
        copy(t) {
          return (
            (this.radius = t.radius),
            (this.phi = t.phi),
            (this.theta = t.theta),
            this
          );
        }
        makeSafe() {
          return (
            (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
            this
          );
        }
        setFromVector3(t) {
          return this.setFromCartesianCoords(t.x, t.y, t.z);
        }
        setFromCartesianCoords(t, e, n) {
          return (
            (this.radius = Math.sqrt(t * t + e * e + n * n)),
            this.radius === 0
              ? ((this.theta = 0), (this.phi = 0))
              : ((this.theta = Math.atan2(t, n)),
                (this.phi = Math.acos(me(e / this.radius, -1, 1)))),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class sm extends $p {
        constructor(t = 1) {
          const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
            n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
            r = new cn();
          r.setAttribute("position", new Ye(e, 3)),
            r.setAttribute("color", new Ye(n, 3));
          const s = new vl({ vertexColors: !0, toneMapped: !1 });
          super(r, s), (this.type = "AxesHelper");
        }
        setColors(t, e, n) {
          const r = new Bt(),
            s = this.geometry.attributes.color.array;
          return (
            r.set(t),
            r.toArray(s, 0),
            r.toArray(s, 3),
            r.set(e),
            r.toArray(s, 6),
            r.toArray(s, 9),
            r.set(n),
            r.toArray(s, 12),
            r.toArray(s, 15),
            (this.geometry.attributes.color.needsUpdate = !0),
            this
          );
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      class am extends kn {
        constructor(t, e = null) {
          super(),
            (this.object = t),
            (this.domElement = e),
            (this.enabled = !0),
            (this.state = -1),
            (this.keys = {}),
            (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
            (this.touches = { ONE: null, TWO: null });
        }
        connect() {}
        disconnect() {}
        dispose() {}
        update() {}
      }
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: sa } })
        );
      typeof window < "u" &&
        (window.__THREE__
          ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
            )
          : (window.__THREE__ = sa));
      const No = { type: "change" },
        va = { type: "start" },
        Ml = { type: "end" },
        mr = new pa(),
        Fo = new gn(),
        om = Math.cos(70 * Dc.DEG2RAD),
        ae = new D(),
        Ee = 2 * Math.PI,
        jt = {
          NONE: -1,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_PAN: 4,
          TOUCH_DOLLY_PAN: 5,
          TOUCH_DOLLY_ROTATE: 6,
        },
        gs = 1e-6;
      class lm extends am {
        constructor(t, e = null) {
          super(t, e),
            (this.state = jt.NONE),
            (this.enabled = !0),
            (this.target = new D()),
            (this.cursor = new D()),
            (this.minDistance = 0),
            (this.maxDistance = 1 / 0),
            (this.minZoom = 0),
            (this.maxZoom = 1 / 0),
            (this.minTargetRadius = 0),
            (this.maxTargetRadius = 1 / 0),
            (this.minPolarAngle = 0),
            (this.maxPolarAngle = Math.PI),
            (this.minAzimuthAngle = -1 / 0),
            (this.maxAzimuthAngle = 1 / 0),
            (this.enableDamping = !1),
            (this.dampingFactor = 0.05),
            (this.enableZoom = !0),
            (this.zoomSpeed = 1),
            (this.enableRotate = !0),
            (this.rotateSpeed = 1),
            (this.enablePan = !0),
            (this.panSpeed = 1),
            (this.screenSpacePanning = !0),
            (this.keyPanSpeed = 7),
            (this.zoomToCursor = !1),
            (this.autoRotate = !1),
            (this.autoRotateSpeed = 2),
            (this.keys = {
              LEFT: "ArrowLeft",
              UP: "ArrowUp",
              RIGHT: "ArrowRight",
              BOTTOM: "ArrowDown",
            }),
            (this.mouseButtons = {
              LEFT: li.ROTATE,
              MIDDLE: li.DOLLY,
              RIGHT: li.PAN,
            }),
            (this.touches = { ONE: ai.ROTATE, TWO: ai.DOLLY_PAN }),
            (this.target0 = this.target.clone()),
            (this.position0 = this.object.position.clone()),
            (this.zoom0 = this.object.zoom),
            (this._domElementKeyEvents = null),
            (this._lastPosition = new D()),
            (this._lastQuaternion = new Vn()),
            (this._lastTargetPosition = new D()),
            (this._quat = new Vn().setFromUnitVectors(t.up, new D(0, 1, 0))),
            (this._quatInverse = this._quat.clone().invert()),
            (this._spherical = new Io()),
            (this._sphericalDelta = new Io()),
            (this._scale = 1),
            (this._panOffset = new D()),
            (this._rotateStart = new Pt()),
            (this._rotateEnd = new Pt()),
            (this._rotateDelta = new Pt()),
            (this._panStart = new Pt()),
            (this._panEnd = new Pt()),
            (this._panDelta = new Pt()),
            (this._dollyStart = new Pt()),
            (this._dollyEnd = new Pt()),
            (this._dollyDelta = new Pt()),
            (this._dollyDirection = new D()),
            (this._mouse = new Pt()),
            (this._performCursorZoom = !1),
            (this._pointers = []),
            (this._pointerPositions = {}),
            (this._controlActive = !1),
            (this._onPointerMove = hm.bind(this)),
            (this._onPointerDown = cm.bind(this)),
            (this._onPointerUp = um.bind(this)),
            (this._onContextMenu = vm.bind(this)),
            (this._onMouseWheel = pm.bind(this)),
            (this._onKeyDown = mm.bind(this)),
            (this._onTouchStart = _m.bind(this)),
            (this._onTouchMove = gm.bind(this)),
            (this._onMouseDown = dm.bind(this)),
            (this._onMouseMove = fm.bind(this)),
            (this._interceptControlDown = xm.bind(this)),
            (this._interceptControlUp = Mm.bind(this)),
            this.domElement !== null && this.connect(),
            this.update();
        }
        connect() {
          this.domElement.addEventListener("pointerdown", this._onPointerDown),
            this.domElement.addEventListener(
              "pointercancel",
              this._onPointerUp
            ),
            this.domElement.addEventListener(
              "contextmenu",
              this._onContextMenu
            ),
            this.domElement.addEventListener("wheel", this._onMouseWheel, {
              passive: !1,
            }),
            this.domElement
              .getRootNode()
              .addEventListener("keydown", this._interceptControlDown, {
                passive: !0,
                capture: !0,
              }),
            (this.domElement.style.touchAction = "none");
        }
        disconnect() {
          this.domElement.removeEventListener(
            "pointerdown",
            this._onPointerDown
          ),
            this.domElement.removeEventListener(
              "pointermove",
              this._onPointerMove
            ),
            this.domElement.removeEventListener("pointerup", this._onPointerUp),
            this.domElement.removeEventListener(
              "pointercancel",
              this._onPointerUp
            ),
            this.domElement.removeEventListener("wheel", this._onMouseWheel),
            this.domElement.removeEventListener(
              "contextmenu",
              this._onContextMenu
            ),
            this.stopListenToKeyEvents(),
            this.domElement
              .getRootNode()
              .removeEventListener("keydown", this._interceptControlDown, {
                capture: !0,
              }),
            (this.domElement.style.touchAction = "auto");
        }
        dispose() {
          this.disconnect();
        }
        getPolarAngle() {
          return this._spherical.phi;
        }
        getAzimuthalAngle() {
          return this._spherical.theta;
        }
        getDistance() {
          return this.object.position.distanceTo(this.target);
        }
        listenToKeyEvents(t) {
          t.addEventListener("keydown", this._onKeyDown),
            (this._domElementKeyEvents = t);
        }
        stopListenToKeyEvents() {
          this._domElementKeyEvents !== null &&
            (this._domElementKeyEvents.removeEventListener(
              "keydown",
              this._onKeyDown
            ),
            (this._domElementKeyEvents = null));
        }
        saveState() {
          this.target0.copy(this.target),
            this.position0.copy(this.object.position),
            (this.zoom0 = this.object.zoom);
        }
        reset() {
          this.target.copy(this.target0),
            this.object.position.copy(this.position0),
            (this.object.zoom = this.zoom0),
            this.object.updateProjectionMatrix(),
            this.dispatchEvent(No),
            this.update(),
            (this.state = jt.NONE);
        }
        update(t = null) {
          const e = this.object.position;
          ae.copy(e).sub(this.target),
            ae.applyQuaternion(this._quat),
            this._spherical.setFromVector3(ae),
            this.autoRotate &&
              this.state === jt.NONE &&
              this._rotateLeft(this._getAutoRotationAngle(t)),
            this.enableDamping
              ? ((this._spherical.theta +=
                  this._sphericalDelta.theta * this.dampingFactor),
                (this._spherical.phi +=
                  this._sphericalDelta.phi * this.dampingFactor))
              : ((this._spherical.theta += this._sphericalDelta.theta),
                (this._spherical.phi += this._sphericalDelta.phi));
          let n = this.minAzimuthAngle,
            r = this.maxAzimuthAngle;
          isFinite(n) &&
            isFinite(r) &&
            (n < -Math.PI ? (n += Ee) : n > Math.PI && (n -= Ee),
            r < -Math.PI ? (r += Ee) : r > Math.PI && (r -= Ee),
            n <= r
              ? (this._spherical.theta = Math.max(
                  n,
                  Math.min(r, this._spherical.theta)
                ))
              : (this._spherical.theta =
                  this._spherical.theta > (n + r) / 2
                    ? Math.max(n, this._spherical.theta)
                    : Math.min(r, this._spherical.theta))),
            (this._spherical.phi = Math.max(
              this.minPolarAngle,
              Math.min(this.maxPolarAngle, this._spherical.phi)
            )),
            this._spherical.makeSafe(),
            this.enableDamping === !0
              ? this.target.addScaledVector(this._panOffset, this.dampingFactor)
              : this.target.add(this._panOffset),
            this.target.sub(this.cursor),
            this.target.clampLength(this.minTargetRadius, this.maxTargetRadius),
            this.target.add(this.cursor);
          let s = !1;
          if (
            (this.zoomToCursor && this._performCursorZoom) ||
            this.object.isOrthographicCamera
          )
            this._spherical.radius = this._clampDistance(
              this._spherical.radius
            );
          else {
            const a = this._spherical.radius;
            (this._spherical.radius = this._clampDistance(
              this._spherical.radius * this._scale
            )),
              (s = a != this._spherical.radius);
          }
          if (
            (ae.setFromSpherical(this._spherical),
            ae.applyQuaternion(this._quatInverse),
            e.copy(this.target).add(ae),
            this.object.lookAt(this.target),
            this.enableDamping === !0
              ? ((this._sphericalDelta.theta *= 1 - this.dampingFactor),
                (this._sphericalDelta.phi *= 1 - this.dampingFactor),
                this._panOffset.multiplyScalar(1 - this.dampingFactor))
              : (this._sphericalDelta.set(0, 0, 0),
                this._panOffset.set(0, 0, 0)),
            this.zoomToCursor && this._performCursorZoom)
          ) {
            let a = null;
            if (this.object.isPerspectiveCamera) {
              const o = ae.length();
              a = this._clampDistance(o * this._scale);
              const l = o - a;
              this.object.position.addScaledVector(this._dollyDirection, l),
                this.object.updateMatrixWorld(),
                (s = !!l);
            } else if (this.object.isOrthographicCamera) {
              const o = new D(this._mouse.x, this._mouse.y, 0);
              o.unproject(this.object);
              const l = this.object.zoom;
              (this.object.zoom = Math.max(
                this.minZoom,
                Math.min(this.maxZoom, this.object.zoom / this._scale)
              )),
                this.object.updateProjectionMatrix(),
                (s = l !== this.object.zoom);
              const c = new D(this._mouse.x, this._mouse.y, 0);
              c.unproject(this.object),
                this.object.position.sub(c).add(o),
                this.object.updateMatrixWorld(),
                (a = ae.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (this.zoomToCursor = !1);
            a !== null &&
              (this.screenSpacePanning
                ? this.target
                    .set(0, 0, -1)
                    .transformDirection(this.object.matrix)
                    .multiplyScalar(a)
                    .add(this.object.position)
                : (mr.origin.copy(this.object.position),
                  mr.direction
                    .set(0, 0, -1)
                    .transformDirection(this.object.matrix),
                  Math.abs(this.object.up.dot(mr.direction)) < om
                    ? this.object.lookAt(this.target)
                    : (Fo.setFromNormalAndCoplanarPoint(
                        this.object.up,
                        this.target
                      ),
                      mr.intersectPlane(Fo, this.target))));
          } else if (this.object.isOrthographicCamera) {
            const a = this.object.zoom;
            (this.object.zoom = Math.max(
              this.minZoom,
              Math.min(this.maxZoom, this.object.zoom / this._scale)
            )),
              a !== this.object.zoom &&
                (this.object.updateProjectionMatrix(), (s = !0));
          }
          return (
            (this._scale = 1),
            (this._performCursorZoom = !1),
            s ||
            this._lastPosition.distanceToSquared(this.object.position) > gs ||
            8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > gs ||
            this._lastTargetPosition.distanceToSquared(this.target) > gs
              ? (this.dispatchEvent(No),
                this._lastPosition.copy(this.object.position),
                this._lastQuaternion.copy(this.object.quaternion),
                this._lastTargetPosition.copy(this.target),
                !0)
              : !1
          );
        }
        _getAutoRotationAngle(t) {
          return t !== null
            ? (Ee / 60) * this.autoRotateSpeed * t
            : (Ee / 60 / 60) * this.autoRotateSpeed;
        }
        _getZoomScale(t) {
          const e = Math.abs(t * 0.01);
          return Math.pow(0.95, this.zoomSpeed * e);
        }
        _rotateLeft(t) {
          this._sphericalDelta.theta -= t;
        }
        _rotateUp(t) {
          this._sphericalDelta.phi -= t;
        }
        _panLeft(t, e) {
          ae.setFromMatrixColumn(e, 0),
            ae.multiplyScalar(-t),
            this._panOffset.add(ae);
        }
        _panUp(t, e) {
          this.screenSpacePanning === !0
            ? ae.setFromMatrixColumn(e, 1)
            : (ae.setFromMatrixColumn(e, 0),
              ae.crossVectors(this.object.up, ae)),
            ae.multiplyScalar(t),
            this._panOffset.add(ae);
        }
        _pan(t, e) {
          const n = this.domElement;
          if (this.object.isPerspectiveCamera) {
            const r = this.object.position;
            ae.copy(r).sub(this.target);
            let s = ae.length();
            (s *= Math.tan(((this.object.fov / 2) * Math.PI) / 180)),
              this._panLeft((2 * t * s) / n.clientHeight, this.object.matrix),
              this._panUp((2 * e * s) / n.clientHeight, this.object.matrix);
          } else
            this.object.isOrthographicCamera
              ? (this._panLeft(
                  (t * (this.object.right - this.object.left)) /
                    this.object.zoom /
                    n.clientWidth,
                  this.object.matrix
                ),
                this._panUp(
                  (e * (this.object.top - this.object.bottom)) /
                    this.object.zoom /
                    n.clientHeight,
                  this.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (this.enablePan = !1));
        }
        _dollyOut(t) {
          this.object.isPerspectiveCamera || this.object.isOrthographicCamera
            ? (this._scale /= t)
            : (console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
              ),
              (this.enableZoom = !1));
        }
        _dollyIn(t) {
          this.object.isPerspectiveCamera || this.object.isOrthographicCamera
            ? (this._scale *= t)
            : (console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
              ),
              (this.enableZoom = !1));
        }
        _updateZoomParameters(t, e) {
          if (!this.zoomToCursor) return;
          this._performCursorZoom = !0;
          const n = this.domElement.getBoundingClientRect(),
            r = t - n.left,
            s = e - n.top,
            a = n.width,
            o = n.height;
          (this._mouse.x = (r / a) * 2 - 1),
            (this._mouse.y = -(s / o) * 2 + 1),
            this._dollyDirection
              .set(this._mouse.x, this._mouse.y, 1)
              .unproject(this.object)
              .sub(this.object.position)
              .normalize();
        }
        _clampDistance(t) {
          return Math.max(this.minDistance, Math.min(this.maxDistance, t));
        }
        _handleMouseDownRotate(t) {
          this._rotateStart.set(t.clientX, t.clientY);
        }
        _handleMouseDownDolly(t) {
          this._updateZoomParameters(t.clientX, t.clientX),
            this._dollyStart.set(t.clientX, t.clientY);
        }
        _handleMouseDownPan(t) {
          this._panStart.set(t.clientX, t.clientY);
        }
        _handleMouseMoveRotate(t) {
          this._rotateEnd.set(t.clientX, t.clientY),
            this._rotateDelta
              .subVectors(this._rotateEnd, this._rotateStart)
              .multiplyScalar(this.rotateSpeed);
          const e = this.domElement;
          this._rotateLeft((Ee * this._rotateDelta.x) / e.clientHeight),
            this._rotateUp((Ee * this._rotateDelta.y) / e.clientHeight),
            this._rotateStart.copy(this._rotateEnd),
            this.update();
        }
        _handleMouseMoveDolly(t) {
          this._dollyEnd.set(t.clientX, t.clientY),
            this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart),
            this._dollyDelta.y > 0
              ? this._dollyOut(this._getZoomScale(this._dollyDelta.y))
              : this._dollyDelta.y < 0 &&
                this._dollyIn(this._getZoomScale(this._dollyDelta.y)),
            this._dollyStart.copy(this._dollyEnd),
            this.update();
        }
        _handleMouseMovePan(t) {
          this._panEnd.set(t.clientX, t.clientY),
            this._panDelta
              .subVectors(this._panEnd, this._panStart)
              .multiplyScalar(this.panSpeed),
            this._pan(this._panDelta.x, this._panDelta.y),
            this._panStart.copy(this._panEnd),
            this.update();
        }
        _handleMouseWheel(t) {
          this._updateZoomParameters(t.clientX, t.clientY),
            t.deltaY < 0
              ? this._dollyIn(this._getZoomScale(t.deltaY))
              : t.deltaY > 0 && this._dollyOut(this._getZoomScale(t.deltaY)),
            this.update();
        }
        _handleKeyDown(t) {
          let e = !1;
          switch (t.code) {
            case this.keys.UP:
              t.ctrlKey || t.metaKey || t.shiftKey
                ? this._rotateUp(
                    (Ee * this.rotateSpeed) / this.domElement.clientHeight
                  )
                : this._pan(0, this.keyPanSpeed),
                (e = !0);
              break;
            case this.keys.BOTTOM:
              t.ctrlKey || t.metaKey || t.shiftKey
                ? this._rotateUp(
                    (-Ee * this.rotateSpeed) / this.domElement.clientHeight
                  )
                : this._pan(0, -this.keyPanSpeed),
                (e = !0);
              break;
            case this.keys.LEFT:
              t.ctrlKey || t.metaKey || t.shiftKey
                ? this._rotateLeft(
                    (Ee * this.rotateSpeed) / this.domElement.clientHeight
                  )
                : this._pan(this.keyPanSpeed, 0),
                (e = !0);
              break;
            case this.keys.RIGHT:
              t.ctrlKey || t.metaKey || t.shiftKey
                ? this._rotateLeft(
                    (-Ee * this.rotateSpeed) / this.domElement.clientHeight
                  )
                : this._pan(-this.keyPanSpeed, 0),
                (e = !0);
              break;
          }
          e && (t.preventDefault(), this.update());
        }
        _handleTouchStartRotate(t) {
          if (this._pointers.length === 1)
            this._rotateStart.set(t.pageX, t.pageY);
          else {
            const e = this._getSecondPointerPosition(t),
              n = 0.5 * (t.pageX + e.x),
              r = 0.5 * (t.pageY + e.y);
            this._rotateStart.set(n, r);
          }
        }
        _handleTouchStartPan(t) {
          if (this._pointers.length === 1) this._panStart.set(t.pageX, t.pageY);
          else {
            const e = this._getSecondPointerPosition(t),
              n = 0.5 * (t.pageX + e.x),
              r = 0.5 * (t.pageY + e.y);
            this._panStart.set(n, r);
          }
        }
        _handleTouchStartDolly(t) {
          const e = this._getSecondPointerPosition(t),
            n = t.pageX - e.x,
            r = t.pageY - e.y,
            s = Math.sqrt(n * n + r * r);
          this._dollyStart.set(0, s);
        }
        _handleTouchStartDollyPan(t) {
          this.enableZoom && this._handleTouchStartDolly(t),
            this.enablePan && this._handleTouchStartPan(t);
        }
        _handleTouchStartDollyRotate(t) {
          this.enableZoom && this._handleTouchStartDolly(t),
            this.enableRotate && this._handleTouchStartRotate(t);
        }
        _handleTouchMoveRotate(t) {
          if (this._pointers.length == 1) this._rotateEnd.set(t.pageX, t.pageY);
          else {
            const n = this._getSecondPointerPosition(t),
              r = 0.5 * (t.pageX + n.x),
              s = 0.5 * (t.pageY + n.y);
            this._rotateEnd.set(r, s);
          }
          this._rotateDelta
            .subVectors(this._rotateEnd, this._rotateStart)
            .multiplyScalar(this.rotateSpeed);
          const e = this.domElement;
          this._rotateLeft((Ee * this._rotateDelta.x) / e.clientHeight),
            this._rotateUp((Ee * this._rotateDelta.y) / e.clientHeight),
            this._rotateStart.copy(this._rotateEnd);
        }
        _handleTouchMovePan(t) {
          if (this._pointers.length === 1) this._panEnd.set(t.pageX, t.pageY);
          else {
            const e = this._getSecondPointerPosition(t),
              n = 0.5 * (t.pageX + e.x),
              r = 0.5 * (t.pageY + e.y);
            this._panEnd.set(n, r);
          }
          this._panDelta
            .subVectors(this._panEnd, this._panStart)
            .multiplyScalar(this.panSpeed),
            this._pan(this._panDelta.x, this._panDelta.y),
            this._panStart.copy(this._panEnd);
        }
        _handleTouchMoveDolly(t) {
          const e = this._getSecondPointerPosition(t),
            n = t.pageX - e.x,
            r = t.pageY - e.y,
            s = Math.sqrt(n * n + r * r);
          this._dollyEnd.set(0, s),
            this._dollyDelta.set(
              0,
              Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)
            ),
            this._dollyOut(this._dollyDelta.y),
            this._dollyStart.copy(this._dollyEnd);
          const a = (t.pageX + e.x) * 0.5,
            o = (t.pageY + e.y) * 0.5;
          this._updateZoomParameters(a, o);
        }
        _handleTouchMoveDollyPan(t) {
          this.enableZoom && this._handleTouchMoveDolly(t),
            this.enablePan && this._handleTouchMovePan(t);
        }
        _handleTouchMoveDollyRotate(t) {
          this.enableZoom && this._handleTouchMoveDolly(t),
            this.enableRotate && this._handleTouchMoveRotate(t);
        }
        _addPointer(t) {
          this._pointers.push(t.pointerId);
        }
        _removePointer(t) {
          delete this._pointerPositions[t.pointerId];
          for (let e = 0; e < this._pointers.length; e++)
            if (this._pointers[e] == t.pointerId) {
              this._pointers.splice(e, 1);
              return;
            }
        }
        _isTrackingPointer(t) {
          for (let e = 0; e < this._pointers.length; e++)
            if (this._pointers[e] == t.pointerId) return !0;
          return !1;
        }
        _trackPointer(t) {
          let e = this._pointerPositions[t.pointerId];
          e === void 0 &&
            ((e = new Pt()), (this._pointerPositions[t.pointerId] = e)),
            e.set(t.pageX, t.pageY);
        }
        _getSecondPointerPosition(t) {
          const e =
            t.pointerId === this._pointers[0]
              ? this._pointers[1]
              : this._pointers[0];
          return this._pointerPositions[e];
        }
        _customWheelEvent(t) {
          const e = t.deltaMode,
            n = { clientX: t.clientX, clientY: t.clientY, deltaY: t.deltaY };
          switch (e) {
            case 1:
              n.deltaY *= 16;
              break;
            case 2:
              n.deltaY *= 100;
              break;
          }
          return t.ctrlKey && !this._controlActive && (n.deltaY *= 10), n;
        }
      }
      function cm(i) {
        this.enabled !== !1 &&
          (this._pointers.length === 0 &&
            (this.domElement.setPointerCapture(i.pointerId),
            this.domElement.addEventListener(
              "pointermove",
              this._onPointerMove
            ),
            this.domElement.addEventListener("pointerup", this._onPointerUp)),
          !this._isTrackingPointer(i) &&
            (this._addPointer(i),
            i.pointerType === "touch"
              ? this._onTouchStart(i)
              : this._onMouseDown(i)));
      }
      function hm(i) {
        this.enabled !== !1 &&
          (i.pointerType === "touch"
            ? this._onTouchMove(i)
            : this._onMouseMove(i));
      }
      function um(i) {
        switch ((this._removePointer(i), this._pointers.length)) {
          case 0:
            this.domElement.releasePointerCapture(i.pointerId),
              this.domElement.removeEventListener(
                "pointermove",
                this._onPointerMove
              ),
              this.domElement.removeEventListener(
                "pointerup",
                this._onPointerUp
              ),
              this.dispatchEvent(Ml),
              (this.state = jt.NONE);
            break;
          case 1:
            const t = this._pointers[0],
              e = this._pointerPositions[t];
            this._onTouchStart({ pointerId: t, pageX: e.x, pageY: e.y });
            break;
        }
      }
      function dm(i) {
        let t;
        switch (i.button) {
          case 0:
            t = this.mouseButtons.LEFT;
            break;
          case 1:
            t = this.mouseButtons.MIDDLE;
            break;
          case 2:
            t = this.mouseButtons.RIGHT;
            break;
          default:
            t = -1;
        }
        switch (t) {
          case li.DOLLY:
            if (this.enableZoom === !1) return;
            this._handleMouseDownDolly(i), (this.state = jt.DOLLY);
            break;
          case li.ROTATE:
            if (i.ctrlKey || i.metaKey || i.shiftKey) {
              if (this.enablePan === !1) return;
              this._handleMouseDownPan(i), (this.state = jt.PAN);
            } else {
              if (this.enableRotate === !1) return;
              this._handleMouseDownRotate(i), (this.state = jt.ROTATE);
            }
            break;
          case li.PAN:
            if (i.ctrlKey || i.metaKey || i.shiftKey) {
              if (this.enableRotate === !1) return;
              this._handleMouseDownRotate(i), (this.state = jt.ROTATE);
            } else {
              if (this.enablePan === !1) return;
              this._handleMouseDownPan(i), (this.state = jt.PAN);
            }
            break;
          default:
            this.state = jt.NONE;
        }
        this.state !== jt.NONE && this.dispatchEvent(va);
      }
      function fm(i) {
        switch (this.state) {
          case jt.ROTATE:
            if (this.enableRotate === !1) return;
            this._handleMouseMoveRotate(i);
            break;
          case jt.DOLLY:
            if (this.enableZoom === !1) return;
            this._handleMouseMoveDolly(i);
            break;
          case jt.PAN:
            if (this.enablePan === !1) return;
            this._handleMouseMovePan(i);
            break;
        }
      }
      function pm(i) {
        this.enabled === !1 ||
          this.enableZoom === !1 ||
          this.state !== jt.NONE ||
          (i.preventDefault(),
          this.dispatchEvent(va),
          this._handleMouseWheel(this._customWheelEvent(i)),
          this.dispatchEvent(Ml));
      }
      function mm(i) {
        this.enabled === !1 || this.enablePan === !1 || this._handleKeyDown(i);
      }
      function _m(i) {
        switch ((this._trackPointer(i), this._pointers.length)) {
          case 1:
            switch (this.touches.ONE) {
              case ai.ROTATE:
                if (this.enableRotate === !1) return;
                this._handleTouchStartRotate(i), (this.state = jt.TOUCH_ROTATE);
                break;
              case ai.PAN:
                if (this.enablePan === !1) return;
                this._handleTouchStartPan(i), (this.state = jt.TOUCH_PAN);
                break;
              default:
                this.state = jt.NONE;
            }
            break;
          case 2:
            switch (this.touches.TWO) {
              case ai.DOLLY_PAN:
                if (this.enableZoom === !1 && this.enablePan === !1) return;
                this._handleTouchStartDollyPan(i),
                  (this.state = jt.TOUCH_DOLLY_PAN);
                break;
              case ai.DOLLY_ROTATE:
                if (this.enableZoom === !1 && this.enableRotate === !1) return;
                this._handleTouchStartDollyRotate(i),
                  (this.state = jt.TOUCH_DOLLY_ROTATE);
                break;
              default:
                this.state = jt.NONE;
            }
            break;
          default:
            this.state = jt.NONE;
        }
        this.state !== jt.NONE && this.dispatchEvent(va);
      }
      function gm(i) {
        switch ((this._trackPointer(i), this.state)) {
          case jt.TOUCH_ROTATE:
            if (this.enableRotate === !1) return;
            this._handleTouchMoveRotate(i), this.update();
            break;
          case jt.TOUCH_PAN:
            if (this.enablePan === !1) return;
            this._handleTouchMovePan(i), this.update();
            break;
          case jt.TOUCH_DOLLY_PAN:
            if (this.enableZoom === !1 && this.enablePan === !1) return;
            this._handleTouchMoveDollyPan(i), this.update();
            break;
          case jt.TOUCH_DOLLY_ROTATE:
            if (this.enableZoom === !1 && this.enableRotate === !1) return;
            this._handleTouchMoveDollyRotate(i), this.update();
            break;
          default:
            this.state = jt.NONE;
        }
      }
      function vm(i) {
        this.enabled !== !1 && i.preventDefault();
      }
      function xm(i) {
        i.key === "Control" &&
          ((this._controlActive = !0),
          this.domElement
            .getRootNode()
            .addEventListener("keyup", this._interceptControlUp, {
              passive: !0,
              capture: !0,
            }));
      }
      function Mm(i) {
        i.key === "Control" &&
          ((this._controlActive = !1),
          this.domElement
            .getRootNode()
            .removeEventListener("keyup", this._interceptControlUp, {
              passive: !0,
              capture: !0,
            }));
      }
      var Fi = function () {
        var i = 0,
          t = document.createElement("div");
        (t.style.cssText =
          "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000"),
          t.addEventListener(
            "click",
            function (h) {
              h.preventDefault(), n(++i % t.children.length);
            },
            !1
          );
        function e(h) {
          return t.appendChild(h.dom), h;
        }
        function n(h) {
          for (var f = 0; f < t.children.length; f++)
            t.children[f].style.display = f === h ? "block" : "none";
          i = h;
        }
        var r = (performance || Date).now(),
          s = r,
          a = 0,
          o = e(new Fi.Panel("FPS", "#0ff", "#002")),
          l = e(new Fi.Panel("MS", "#0f0", "#020"));
        if (self.performance && self.performance.memory)
          var c = e(new Fi.Panel("MB", "#f08", "#201"));
        return (
          n(0),
          {
            REVISION: 16,
            dom: t,
            addPanel: e,
            showPanel: n,
            begin: function () {
              r = (performance || Date).now();
            },
            end: function () {
              a++;
              var h = (performance || Date).now();
              if (
                (l.update(h - r, 200),
                h >= s + 1e3 &&
                  (o.update((a * 1e3) / (h - s), 100), (s = h), (a = 0), c))
              ) {
                var f = performance.memory;
                c.update(
                  f.usedJSHeapSize / 1048576,
                  f.jsHeapSizeLimit / 1048576
                );
              }
              return h;
            },
            update: function () {
              r = this.end();
            },
            domElement: t,
            setMode: n,
          }
        );
      };
      Fi.Panel = function (i, t, e) {
        var n = 1 / 0,
          r = 0,
          s = Math.round,
          a = s(window.devicePixelRatio || 1),
          o = 80 * a,
          l = 48 * a,
          c = 3 * a,
          h = 2 * a,
          f = 3 * a,
          p = 15 * a,
          m = 74 * a,
          v = 30 * a,
          M = document.createElement("canvas");
        (M.width = o),
          (M.height = l),
          (M.style.cssText = "width:80px;height:48px");
        var u = M.getContext("2d");
        return (
          (u.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif"),
          (u.textBaseline = "top"),
          (u.fillStyle = e),
          u.fillRect(0, 0, o, l),
          (u.fillStyle = t),
          u.fillText(i, c, h),
          u.fillRect(f, p, m, v),
          (u.fillStyle = e),
          (u.globalAlpha = 0.9),
          u.fillRect(f, p, m, v),
          {
            dom: M,
            update: function (d, T) {
              (n = Math.min(n, d)),
                (r = Math.max(r, d)),
                (u.fillStyle = e),
                (u.globalAlpha = 1),
                u.fillRect(0, 0, o, p),
                (u.fillStyle = t),
                u.fillText(
                  s(d) + " " + i + " (" + s(n) + "-" + s(r) + ")",
                  c,
                  h
                ),
                u.drawImage(M, f + a, p, m - a, v, f, p, m - a, v),
                u.fillRect(f + m - a, p, a, v),
                (u.fillStyle = e),
                (u.globalAlpha = 0.9),
                u.fillRect(f + m - a, p, a, s((1 - d / T) * v));
            },
          }
        );
      };
      const Sl = new yi().load(
          "data:image/webp;base64,UklGRhoBAABXRUJQVlA4TA0BAAAvn8AnAIWjtpEECdnA2N0DsTROy7xUqfrWw0jbyLkJKTz0+I20jTT/Bo89e1YR/Wfktm0Y+wNKLobT7QP/n/B7Z/naW26QHoTpHB7LFouyKHlzeHxfCStSuj9KdbC8z1IJ5iWiyQed48vtYJ+lUu0t4VwranS1XMIutSiLYlbb8G54uf2p3VPSfRZtSrlsPFjOzZZrd/us3B3uK+HcHJQql+xbLMrS/WqNpm6DeZ/VIPVYaN/KzUbp91nd9xl5pYu50dU2W417nbdTj5l2Ne92uM9qXNpyf6+oXkabHKXaZ1HS4Iaqpim+1KIJ+0M49/LjNbTGP5mrrMZEuc7Uzcb1ViOJ6TuOt4NGJs+zDgA="
        ),
        El = new yi().load(
          "data:image/webp;base64,UklGRvQBAABXRUJQVlA4TOcBAAAvn8AnADXIjm3btK2o7/ezDzaPjX3PtW07rVYngPV04OhbhvZ/AsbgFByBOXPtgRWwDa6BU7AJ1sAGGIHvwA4YPpuAbXA29sfhWAXrYAxWwK1xfRyBEdgGa2ALDJ+tjJfj0ZiCDbAO9pnrGFwHN8e9sQZ+Bavg2Rg++wJmYBMswAE4A0vgT7ACJmAHLMAe2AK7YAkMn22BCbg3JuDuuD9G43+8Gj+DVXBj3BnLYB3sgOGzGbgIfgPXxwicghNwPNbACVgHE/AbWAe74BgMn5XBybg29sEhmIBNsAKmYA08HXfHAbgxFmB9DJ/1wBo4HVtgH/wF7oApWIB7Yw2MwB44Gyvg1hg+i8DxeDZuj7tjBO6Nk/F43B5jcAhmYHssM9fwWQHG4PnYAdvgYNweq2ANHIBD8BDsgsdjD4zA8NkyWIwFuDbG4NnYBdvjw/gd3AcTsAfWwRzsgOGzFNwbc3BlLMAUHIINsACHYBv8CVaYawlsguGzq7EAI7AJzsABmIE/wAVwADbBErg4ro3fwQwMn52Pm+MX8DNYAqtgBD6PS+PbuDkugxtgHdwc98fw2cr4HxvgT/B43BnH4AgsgxPmWgO3xunYAmdj+CwDp2AdfAfugIugXIxd8H78BUZgCvbBOrgGhs8AAA=="
        ),
        Di = new yi().load(
          "data:image/webp;base64,UklGRngBAABXRUJQVlA4TGsBAAAvn8AnAHXArW1bVVUZZVgRtMEgJSN0d/ju7n2tcfY56fluSNpI0gk5eOjx+08tjCMkbSTp/AsoH1XHnj07Ef2H2DaSI6mYQPW86XUR7AL2ATuAISYrQAswB5wDaI4pYASYADqABmAByM/ZA9BsRwXWBbYFCntgDOgC6KyuC1wUoBOn06B56dRmgPyc0wI070uBPoD2IGUNoC60py8AVwXuC1DTJqANoFZpOSbVGfBpsgF8ij4AdVkAqEvxPqD2tlb5OdX3gK1L7S+gztjU5FP0D2xTZuqoE1HUU/s08ZvtV0Q/j7Qck19RfQb4zaG28tvs+Tl+U6q7Vt26EZ3zcyKa2rqo91t+s6nt83Ni38/gUzo3EfdqOTsRz+tsZ2rrrN6r2Z4d5udEPGlT9+A/oPsy9U5ObZWfozZ1PKFQ6hbP1FE3bGUP+L35sd2h2fal+u1CVk7ERH73TLG7MXsnYhOr73FsZxCxk9NzPgEA"
        );
      Sl.colorSpace = pe;
      El.colorSpace = pe;
      Di.colorSpace = pe;
      const Sm = [
        new Le({ map: Di }),
        new Le({ map: Di }),
        new Le({ map: El }),
        new Le({ map: Sl }),
        new Le({ map: Di }),
        new Le({ map: Di }),
      ];
      class Em {
        constructor() {
          const t = new wn(1, 1, 1),
            e = new Fe(t, Sm);
          return (e.receiveShadow = !0), e;
        }
      }
      class ym {
        constructor(t) {
          const e = new ue();
          for (let n = 0; n < t; n++)
            for (let r = 0; r < t; r++) {
              const s = new Em();
              s.position.set(-t / 2 + n + 0.5, 0, -t / 2 + r + 0.5), e.add(s);
            }
          return e;
        }
      }
      const ra = new yi().load(
          "data:image/webp;base64,UklGRgYBAABXRUJQVlA4TPoAAAAvn8AnAEegqG0jNvXq7c3n1ARAwgZvuMAdSgVt27Cpdv/h2PzH/89000tId2NwXAUYSgVHke2GjSiIQiiEgiiIgiiIQng/zbfbo04R/Z8Ap9H50Gl08aHRRaNfXWXGvlpsFj+W2FdNXGXO4RVDTAbzaogfXdxsn9hXi306NDdbMdisvx2SxaVmbCaVEFMMUQkOJq4yZzFY4su6qoxD08WllmwOwSHFITk0k8XlFxyCSnCzGX91nBxGxcRV5hyCR+PLYIpDMzm4uNSSyl8Owc1mbCrj0Pc/Hpm4ypxKMBn/3XRxqaklNkv8WGKfbjajnxpdfGh00fjQT1cZ"
        ),
        Ui = new yi().load(
          "data:image/webp;base64,UklGRvAAAABXRUJQVlA4TOQAAAAvn8AnAC+gpm0jODl2au+/A3FEAqTByAA0+kO1bduwqcktbc78x/9nDgVvuw0gcBRJbhiJwlIQhaUgCuYPZlSbu69eEf2fAFMcOiwOHRbNoTg0m5ftsZk8Nv/g8LIVO/yDuCg8b8PFTEQzaS7FZHjZxE/F5DFpmuJiHjVTNIfiIiZD8cY1f9OhOTQXh4eumJjL0OHSXJqXbRWXR4efmsnwxq3ibxwm4mIWz9s6XJpmMTGvnfivR4fFx0U8ao/JOlyGSTNx2Lxsppg4FIeJmKT3bJgMHQ6Lppisw2snJuKn9VPzngE="
        );
      Ui.colorSpace = pe;
      ra.colorSpace = pe;
      const Oo = [
        new Le({ map: Ui }),
        new Le({ map: Ui }),
        new Le({ map: ra }),
        new Le({ map: ra }),
        new Le({ map: Ui }),
        new Le({ map: Ui }),
      ];
      class Tm {
        constructor() {
          const t = new wn(),
            e = new Fe(t, Oo);
          return (
            Oo.forEach((n) => {
              (n.roughness = 0.7), (n.metalness = 0.1);
            }),
            (e.castShadow = !0),
            e
          );
        }
      }
      const yl = new yi().load(
        "data:image/webp;base64,UklGRgIBAABXRUJQVlA4TPYAAAAvn8AnECegqG0bOFUM92uMpiYAATZmZXBJQlHbNlBvKOMPcI/5DwD+9zpbMQ9oIkkNFrDwFrCAf1P380lNFdH/CRCLTYXDpcJihxWKw3tmje1ww6cJl8YetabR1w6XE27YNB2esuXQLIdJ0Vi93jhbNLa+KiwOl8bes2eFTx1WuOGE92wpNosdDvdVbBbFG2eNNeLT0FhjNzxlzQqXQ3Go0FjRWGPvWdo01iyHyYTL4oT3zBprxKKxwwo3vHEVdigOxXodKiwetWJTYWKL4nDDoWlWeM8mXE7YTPb1yd4z0SyHy8RWqLA5YfGopRtW+GQ7TPT1gAE="
      );
      yl.colorSpace = pe;
      const Bo = new Le({ map: yl });
      class Am {
        constructor() {
          const t = new wn(),
            e = new Fe(t, Bo);
          return (Bo.roughness = 1), (e.castShadow = !0), e;
        }
      }
      const bm = (i, t) => {
        const e = [];
        for (let n = 0; n < 4; n++) {
          let r;
          n < 2 ? (r = 1) : (r = 2);
          for (let s = -r; s <= r; s++)
            for (let a = -r; a <= r; a++) {
              if (
                (Math.abs(a) === Math.abs(s) && Math.abs(a) === r) ||
                ((Math.abs(a) === Math.abs(s)) === 0 && n !== 0)
              )
                continue;
              let o = i.x + a,
                l = i.z + s,
                c = i.y + t - n;
              e.push(new D(o, c, l));
            }
        }
        return e;
      };
      var di, Cr;
      class wm {
        constructor(t) {
          Ra(this, "obj");
          Ue(this, di);
          Ue(this, Cr);
          return (
            we(this, di, t > 3 ? t : 3),
            (this.obj = new ue()),
            this.createLog(),
            this.createLeaves(),
            (this.obj.animate = this.animate.bind(this)),
            we(this, Cr, Math.PI / 100),
            (this.obj.castShadow = !0),
            this.obj
          );
        }
        createLog() {
          for (let t = 0; t < Mt(this, di) - 1; t++) {
            const e = new Tm();
            e.position.set(
              this.obj.position.x,
              this.obj.position.y + t,
              this.obj.position.z
            ),
              this.obj.add(e);
          }
        }
        createLeaves() {
          const t = bm(this.obj.position, Mt(this, di));
          for (let e of t) {
            const n = new Am();
            n.position.set(e.x, e.y, e.z), this.obj.add(n);
          }
        }
        animate() {}
      }
      (di = new WeakMap()), (Cr = new WeakMap());
      var Hi, Ge, xn, Ve, fi, Mn, ve, rn, Sn;
      class Rm {
        constructor(t) {
          Ue(this, Hi);
          Ue(this, Ge);
          Ue(this, xn);
          Ue(this, Ve);
          Ue(this, fi);
          Ue(this, Mn);
          Ue(this, ve);
          Ue(this, rn);
          Ue(this, Sn);
          we(this, Hi, t),
            we(this, Ge, new jp()),
            we(this, rn, 0),
            we(this, Sn, 40),
            we(
              this,
              xn,
              new Pe(75, window.innerWidth / window.innerHeight, 0.1, 1e3)
            ),
            we(this, Ve, new Kp({ alpha: !0 })),
            Mt(this, Ve).setSize(window.innerWidth, window.innerHeight),
            document.body.appendChild(Mt(this, Ve).domElement),
            we(this, fi, new lm(Mt(this, xn), Mt(this, Ve).domElement)),
            Mt(this, xn).position.set(10, 10, 10),
            Mt(this, xn).lookAt(new D(0, 0, 0)),
            Mt(this, fi).update(),
            (Mt(this, Ve).shadowMap.enabled = !0),
            (Mt(this, Ve).shadowMap.type = Ho),
            we(this, ve, new im(16776960, 5e3, 100)),
            (Mt(this, ve).position.y = 30),
            (Mt(this, ve).position.z = Mt(this, Sn) * Math.cos(Mt(this, rn))),
            (Mt(this, ve).position.x = Mt(this, Sn) * Math.sin(Mt(this, rn))),
            (Mt(this, ve).castShadow = !0);
          const e = 5048;
          (Mt(this, ve).shadow.mapSize.width = e),
            (Mt(this, ve).shadow.mapSize.height = e),
            (Mt(this, ve).shadow.camera.near = 0.5),
            (Mt(this, ve).shadow.camera.far = 500),
            Mt(this, Ge).add(new rm("white", 0.4)),
            Mt(this, Ge).add(Mt(this, ve)),
            we(this, Mn, new Fi()),
            Mt(this, Mn).showPanel(0),
            document.body.appendChild(Mt(this, Mn).dom);
          const n = new sm(5);
          Mt(this, Ge).add(n),
            this.createMap(),
            Mt(this, Ve).setAnimationLoop(this.animate.bind(this));
        }
        animate() {
          Mt(this, Mn).begin(),
            Mt(this, fi).update(),
            Mt(this, Ge).children.forEach((t) => {
              t.animate && (t == null || t.animate());
            }),
            we(this, rn, Mt(this, rn) + 1e-4 * Math.PI),
            (Mt(this, ve).position.z = Mt(this, Sn) * Math.cos(Mt(this, rn))),
            (Mt(this, ve).position.x = Mt(this, Sn) * Math.sin(Mt(this, rn))),
            Mt(this, Mn).end(),
            Mt(this, Ve).render(Mt(this, Ge), Mt(this, xn));
        }
        createMap() {
          this.createGrassField(), this.createTree();
        }
        createGrassField() {
          const t = new ym(Mt(this, Hi));
          Mt(this, Ge).add(t);
        }
        createTree() {
          const e = new wm(6);
          e.position.set(0, 1, 0), Mt(this, Ge).add(e);
        }
      }
      (Hi = new WeakMap()),
        (Ge = new WeakMap()),
        (xn = new WeakMap()),
        (Ve = new WeakMap()),
        (fi = new WeakMap()),
        (Mn = new WeakMap()),
        (ve = new WeakMap()),
        (rn = new WeakMap()),
        (Sn = new WeakMap());
      new Rm(10);
    </script>
  </head>
  <body></body>
</html>
